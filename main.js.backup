import {joinRoom, selfId} from 'trystero/mqtt'
import DiceBox from '@3d-dice/dice-box-threejs'

const byId = document.getElementById.bind(document)
const canvas = byId('canvas')
const rollHistory = byId('roll-history')
const peerCount = byId('peer-count')
const dicePool = byId('dice-pool')
const rollPoolBtn = byId('roll-pool-btn')
const config = {
  appId: 'vampire-diceroom'
}

const peerNames = {}
const peerColors = {}
const cursors = {}
const pool = []
let room
let sendRoll
let sendName
let sendMove
let sendColor
let diceBox

let mouseX = 0
let mouseY = 0

const roomId = window.location.hash.slice(1) || 'main'

let myName = localStorage.getItem('playerName')
if (!myName) {
  const playerName = prompt('Enter your name:')
  myName =
    playerName && playerName.trim() ? playerName.trim() : selfId.slice(0, 8)
  localStorage.setItem('playerName', myName)
}

let myColor = localStorage.getItem('playerColor') || '#ff6b6b'
peerNames[selfId] = myName
peerColors[selfId] = myColor

// Initialize 3D dice box with dynamic theme based on player color
diceBox = new DiceBox('#dice-box-container', {
  assetPath: '/assets/dice-box-assets/',
  theme_customColorset: {
    background: myColor,
    foreground: '#ffffff',
    texture: 'none',
    material: 'plastic'
  },
  light_intensity: 1,
  gravity_multiplier: 400,
  baseScale: 100,
  strength: 11,
  onRollComplete: results => {
    console.log('Roll complete:', results)
  }
})

diceBox
  .initialize()
  .then(() => {
    console.log('DiceBox initialized')
  })
  .catch(err => {
    console.error('DiceBox initialization failed:', err)
  })

async function reinitializeDiceBox(color) {
  // Clear the container first - remove all canvas elements
  const container = byId('dice-box-container')
  const canvases = container.querySelectorAll('canvas')
  canvases.forEach(canvas => canvas.remove())

  // Create new DiceBox with the specified color
  diceBox = new DiceBox('#dice-box-container', {
    assetPath: '/assets/dice-box-assets/',
    theme_customColorset: {
      background: color,
      foreground: '#ffffff',
      texture: 'none',
      material: 'plastic'
    },
    light_intensity: 1,
    gravity_multiplier: 400,
    baseScale: 100,
    strength: 11,
    onRollComplete: results => {
      console.log('Roll complete:', results)
    }
  })

  await diceBox.initialize().catch(err => {
    console.error('DiceBox initialization failed:', err)
  })
}

init(roomId)
renderPool()
document.documentElement.className = 'ready'
addCursor(selfId, true)

document.querySelectorAll('.dice-type-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const sides = parseInt(btn.dataset.sides)
    addDieToPool(sides)
  })

  btn.addEventListener('contextmenu', e => {
    e.preventDefault()
    const sides = parseInt(btn.dataset.sides)
    clearPool()
    addDieToPool(sides)
    setTimeout(() => {
      if (pool.length > 0) {
        handleRollPool()
      }
    }, 50)
  })
})

rollPoolBtn.addEventListener('click', handleRollPool)
byId('create-room-btn').addEventListener('click', createNewRoom)

byId('name-btn').addEventListener('click', () => {
  const newName = prompt('Enter your name:', myName)
  if (newName && newName.trim()) {
    myName = newName.trim()
    peerNames[selfId] = myName
    localStorage.setItem('playerName', myName)

    // Update cursor label if it exists
    const cursorEl = byId(`cursor-${selfId}`)
    if (cursorEl) {
      const labelEl = cursorEl.querySelector('p')
      if (labelEl) {
        labelEl.textContent = myName
      }
    }

    // Send updated name to peers
    sendName(myName)
  }
})

const colorPicker = byId('color-picker')
colorPicker.value = myColor
colorPicker.addEventListener('input', async e => {
  myColor = e.target.value
  peerColors[selfId] = myColor
  localStorage.setItem('playerColor', myColor)

  // Update own cursor color
  const cursorEl = byId(`cursor-${selfId}`)
  if (cursorEl) {
    const labelEl = cursorEl.querySelector('p')
    if (labelEl) {
      labelEl.style.color = myColor
    }
  }

  // Update dice color by reinitializing
  await reinitializeDiceBox(myColor)

  // Send color to peers
  if (sendColor) {
    sendColor(myColor)
  }
})

addEventListener('mousemove', ({clientX, clientY}) => {
  mouseX = clientX / innerWidth
  mouseY = clientY / innerHeight
  moveCursor([mouseX, mouseY], selfId)
  if (room && sendMove) {
    sendMove([mouseX, mouseY])
  }
})

addEventListener('touchmove', e => {
  const x = e.touches[0].clientX / innerWidth
  const y = e.touches[0].clientY / innerHeight
  moveCursor([x, y], selfId)
  if (room && sendMove) {
    sendMove([x, y])
  }
})

function init(roomName) {
  let getRoll
  let getName
  let getMove
  let getColor

  room = joinRoom(config, roomName)
  ;[sendRoll, getRoll] = room.makeAction('diceRoll')
  ;[sendName, getName] = room.makeAction('playerName')
  ;[sendMove, getMove] = room.makeAction('mouseMove')
  ;[sendColor, getColor] = room.makeAction('playerColor')

  byId('room-num').innerText = `Room: ${roomName}`

  room.onPeerJoin(peerId => {
    sendName(myName, peerId)
    sendColor(myColor, peerId)
    addCursor(peerId)
    if (sendMove) {
      sendMove([Math.random() * 0.93, Math.random() * 0.93], peerId)
    }
    updatePeerCount()
  })

  room.onPeerLeave(peerId => {
    delete peerNames[peerId]
    delete peerColors[peerId]
    removeCursor(peerId)
    updatePeerCount()
  })

  getRoll(displayRoll)
  getName((name, peerId) => {
    peerNames[peerId] = name
    if (cursors[peerId]) {
      const nameLabel = cursors[peerId].querySelector('p')
      if (nameLabel) {
        nameLabel.textContent = name
      }
    }
  })
  getColor((color, peerId) => {
    peerColors[peerId] = color
    if (cursors[peerId]) {
      const nameLabel = cursors[peerId].querySelector('p')
      if (nameLabel) {
        nameLabel.style.color = color
      }
    }
  })
  getMove(moveCursor)

  sendName(myName)
  sendColor(myColor)
}

function addDieToPool(sides) {
  const dieId = Date.now() + Math.random()
  pool.push({id: dieId, sides})
  renderPool()
  updateRollButton()
}

function removeDieFromPool(dieId) {
  const index = pool.findIndex(d => d.id === dieId)
  if (index !== -1) {
    pool.splice(index, 1)
    renderPool()
    updateRollButton()
  }
}

function clearPool() {
  pool.length = 0
  renderPool()
  updateRollButton()
}

function renderPool() {
  if (pool.length === 0) {
    dicePool.innerHTML =
      '<div class="w-full text-center text-gray-500 text-lg p-4 italic">Pool is empty. Click dice above to add them.</div>'
    updatePoolSummary()
    return
  }

  dicePool.innerHTML = ''
  pool.forEach(die => {
    const dieEl = document.createElement('button')
    const colorClasses = {
      4: 'bg-dice-4 text-black hover:border-white',
      6: 'bg-dice-6 text-white hover:border-white',
      8: 'bg-dice-8 text-white hover:border-white',
      10: 'bg-dice-10 text-white hover:border-white',
      12: 'bg-dice-12 text-black hover:border-white',
      20: 'bg-dice-20 text-black hover:border-white'
    }
    dieEl.className = `w-[70px] h-[70px] text-lg font-bold border-[3px] border-black rounded-xl cursor-pointer transition-all shadow-[0_3px_6px_rgb(0_0_0/0.3)] hover:scale-110 hover:shadow-[0_5px_10px_rgb(255_255_255/0.3)] ${colorClasses[die.sides]}`
    dieEl.textContent = `d${die.sides}`
    dieEl.addEventListener('click', () => removeDieFromPool(die.id))
    dicePool.appendChild(dieEl)
  })

  updatePoolSummary()
}

function updatePoolSummary() {
  const summaryEl = byId('pool-summary')

  if (pool.length === 0) {
    summaryEl.textContent = ''
    return
  }

  const grouped = {}
  pool.forEach(die => {
    grouped[die.sides] = (grouped[die.sides] || 0) + 1
  })

  const summary = Object.keys(grouped)
    .sort((a, b) => a - b)
    .map(sides => `${grouped[sides]}d${sides}`)
    .join(', ')

  summaryEl.textContent = summary
}

function updateRollButton() {
  rollPoolBtn.disabled = pool.length === 0
  if (pool.length === 0) {
    rollPoolBtn.textContent = 'Roll Pool'
  } else {
    rollPoolBtn.textContent = `Roll ${pool.length} ${pool.length === 1 ? 'Die' : 'Dice'}`
  }
}

async function handleRollPool() {
  if (pool.length === 0) {
    return
  }

  rollPoolBtn.disabled = true
  rollPoolBtn.textContent = 'Rolling...'

  const diceToRoll = [...pool]
  clearPool()

  const results = diceToRoll.map(die => ({
    sides: die.sides,
    value: Math.floor(Math.random() * die.sides) + 1
  }))

  const total = results.reduce((sum, r) => sum + r.value, 0)

  const rollData = {
    peerId: selfId,
    dice: diceToRoll.map(d => d.sides),
    results,
    total,
    timestamp: Date.now()
  }

  sendRoll(rollData)

  // Roll in 3D with predetermined results (with own color)
  await roll3DDice(rollData, selfId)

  // Add to history after 3D animation
  displayRollInHistory(rollData, selfId)

  rollPoolBtn.disabled = false
  updateRollButton()
}

async function roll3DDice(rollData, peerId) {
  if (!diceBox) return

  console.log('roll3DDice called with rollData:', rollData)
  console.log(
    'Predetermined results:',
    rollData.results.map(r => `d${r.sides}=${r.value}`).join(', ')
  )

  // Get the color of the player who rolled
  const rollerColor = peerColors[peerId] || '#ffffff'

  // Reinitialize DiceBox with the roller's color and wait for it to complete
  await reinitializeDiceBox(rollerColor)

  // Build notation: "1d6+1d8+1d6@4,2,3"
  // All dice types listed with +, then single @ with all values
  const diceTypes = rollData.results.map(r => `1d${r.sides}`).join('+')
  const values = rollData.results.map(r => r.value).join(',')
  const notation = `${diceTypes}@${values}`

  console.log('Rolling with notation:', notation, 'in color:', rollerColor)

  try {
    const result = await diceBox.roll(notation)
    console.log('3D roll result:', result)
  } catch (err) {
    console.error('3D dice roll error:', err, rollData)
  }
}

function displayRollWithAnimation(rollData, peerId, duration) {
  return new Promise(resolve => {
    const {dice, results, total, timestamp} = rollData
    const playerName = peerNames[peerId] || peerId.slice(0, 8)
    const isYou = peerId === selfId

    const rollEl = document.createElement('div')
    rollEl.className = `glass rounded-xl p-8 animate-[slideIn_0.3s_ease-out] ${
      isYou ? 'ring-2 ring-white/30' : ''
    }`

    const header = document.createElement('div')
    header.className = 'flex justify-between mb-6 text-base items-start'

    const leftInfo = document.createElement('div')
    leftInfo.className = 'flex flex-col'

    const player = document.createElement('span')
    player.className = `font-bold text-xl ${isYou ? 'text-orange-400' : 'text-white'}`
    player.textContent = playerName

    leftInfo.appendChild(player)

    const rightInfo = document.createElement('div')
    rightInfo.className = 'flex flex-col items-end gap-2'

    const time = document.createElement('span')
    time.className = 'text-gray-500 text-base'
    time.textContent = new Date(timestamp).toLocaleTimeString()

    const totalEl = document.createElement('div')
    totalEl.className = 'text-2xl font-bold text-white'
    totalEl.textContent = 'Rolling...'

    rightInfo.appendChild(time)
    rightInfo.appendChild(totalEl)

    header.appendChild(leftInfo)
    header.appendChild(rightInfo)

    const diceContainer = document.createElement('div')
    diceContainer.className = 'flex gap-1 flex-wrap'

    const diceElements = []
    results.forEach((result, index) => {
      const die = document.createElement('span')
      const diceColors = {
        4: 'bg-dice-4 text-black border-black',
        6: 'bg-dice-6 text-white border-black',
        8: 'bg-dice-8 text-white border-black',
        10: 'bg-dice-10 text-white border-black',
        12: 'bg-dice-12 text-black border-black',
        20: 'bg-dice-20 text-black border-black'
      }
      die.className = `min-w-[60px] h-[60px] px-4 flex items-center justify-center text-2xl font-bold rounded-lg shadow-[0_4px_6px_rgb(0_0_0/0.3)] relative border-[3px] ${diceColors[result.sides]}`
      die.dataset.sides = result.sides
      die.textContent = Math.floor(Math.random() * result.sides) + 1

      const label = document.createElement('span')
      label.className =
        'absolute bottom-[2px] right-1 text-base text-black/40 font-normal'
      label.textContent = `d${result.sides}`
      die.appendChild(label)

      diceContainer.appendChild(die)
      diceElements.push({element: die, result, label})
    })

    rollEl.appendChild(header)
    rollEl.appendChild(diceContainer)

    rollHistory.insertBefore(rollEl, rollHistory.firstChild)

    const maxRolls = 50
    while (rollHistory.children.length > maxRolls) {
      rollHistory.removeChild(rollHistory.lastChild)
    }

    const scrambleInterval = setInterval(() => {
      diceElements.forEach(({element, result, label}) => {
        element.textContent = Math.floor(Math.random() * result.sides) + 1
        element.appendChild(label)
      })
    }, 80)

    setTimeout(() => {
      clearInterval(scrambleInterval)

      // Check for natural 20s
      const hasNat20 = results.some(r => r.sides === 20 && r.value === 20)

      diceElements.forEach(({element, result, label}) => {
        element.textContent = result.value
        element.appendChild(label)
        element.classList.add('animate-[diceReveal_0.3s_ease-out]')

        if (result.value === result.sides) {
          setTimeout(() => {
            const rect = element.getBoundingClientRect()
            const x = (rect.left + rect.width / 2) / window.innerWidth
            const y = (rect.top + rect.height / 2) / window.innerHeight

            confetti({
              particleCount: 50,
              spread: 70,
              origin: {x, y},
              colors: getDiceColor(result.sides),
              scalar: 1.2,
              gravity: 1.5,
              ticks: 200
            })
          }, 100)
        }
      })

      // MEGA CONFETTI for natural 20!
      if (hasNat20) {
        setTimeout(() => {
          // Multiple bursts from different positions
          const duration = 3000
          const animationEnd = Date.now() + duration
          const defaults = {
            startVelocity: 30,
            spread: 360,
            ticks: 60,
            zIndex: 0,
            colors: ['#ffffff', '#f5f5f5', '#ffd700', '#ffed4e']
          }

          function randomInRange(min, max) {
            return Math.random() * (max - min) + min
          }

          const interval = setInterval(function () {
            const timeLeft = animationEnd - Date.now()

            if (timeLeft <= 0) {
              return clearInterval(interval)
            }

            const particleCount = 50 * (timeLeft / duration)

            // Burst from random positions
            confetti(
              Object.assign({}, defaults, {
                particleCount,
                origin: {x: randomInRange(0.1, 0.3), y: Math.random() - 0.2}
              })
            )
            confetti(
              Object.assign({}, defaults, {
                particleCount,
                origin: {x: randomInRange(0.7, 0.9), y: Math.random() - 0.2}
              })
            )
          }, 250)

          // Big center burst
          confetti({
            particleCount: 200,
            spread: 160,
            origin: {x: 0.5, y: 0.5},
            colors: ['#ffffff', '#f5f5f5', '#ffd700', '#ffed4e'],
            scalar: 1.5,
            gravity: 1,
            ticks: 300
          })
        }, 150)
      }

      totalEl.textContent = `Total: ${total}`

      resolve()
    }, duration)
  })
}

async function displayRoll(rollData, peerId) {
  // Roll in 3D for peers (with their color)
  await roll3DDice(rollData, peerId)
  // Add to history
  displayRollInHistory(rollData, peerId)
}

function displayRollInHistory(rollData, peerId) {
  const {results, total, timestamp} = rollData
  const playerName = peerNames[peerId] || peerId.slice(0, 8)
  const isYou = peerId === selfId

  const rollEl = document.createElement('div')
  rollEl.className = `glass rounded-xl p-8 animate-[slideIn_0.3s_ease-out] ${
    isYou ? 'ring-2 ring-white/30' : ''
  }`

  const header = document.createElement('div')
  header.className = 'flex justify-between mb-6 text-base items-start'

  const leftInfo = document.createElement('div')
  leftInfo.className = 'flex flex-col'

  const player = document.createElement('span')
  player.className = `font-bold text-xl ${isYou ? 'text-orange-400' : 'text-white'}`
  player.textContent = playerName

  leftInfo.appendChild(player)

  const rightInfo = document.createElement('div')
  rightInfo.className = 'flex flex-col items-end gap-2'

  const time = document.createElement('span')
  time.className = 'text-gray-500 text-base'
  time.textContent = new Date(timestamp).toLocaleTimeString()

  const totalEl = document.createElement('div')
  totalEl.className = 'text-2xl font-bold text-white'
  totalEl.textContent = `Total: ${total}`

  rightInfo.appendChild(time)
  rightInfo.appendChild(totalEl)

  header.appendChild(leftInfo)
  header.appendChild(rightInfo)

  const diceContainer = document.createElement('div')
  diceContainer.className = 'flex gap-1 flex-wrap'

  results.forEach(result => {
    const die = document.createElement('span')
    const diceColors = {
      4: 'bg-dice-4 text-black border-black',
      6: 'bg-dice-6 text-white border-black',
      8: 'bg-dice-8 text-white border-black',
      10: 'bg-dice-10 text-white border-black',
      12: 'bg-dice-12 text-black border-black',
      20: 'bg-dice-20 text-black border-black'
    }
    die.className = `min-w-[60px] h-[60px] px-4 flex items-center justify-center text-2xl font-bold rounded-lg shadow-[0_4px_6px_rgb(0_0_0/0.3)] relative border-[3px] ${diceColors[result.sides]}`
    die.textContent = result.value

    const label = document.createElement('span')
    label.className =
      'absolute bottom-[2px] right-1 text-base text-black/40 font-normal'
    label.textContent = `d${result.sides}`
    die.appendChild(label)

    diceContainer.appendChild(die)

    // Confetti for max rolls
    if (result.value === result.sides) {
      setTimeout(() => {
        const rect = die.getBoundingClientRect()
        const x = (rect.left + rect.width / 2) / window.innerWidth
        const y = (rect.top + rect.height / 2) / window.innerHeight

        confetti({
          particleCount: 50,
          spread: 70,
          origin: {x, y},
          colors: getDiceColor(result.sides),
          scalar: 1.2,
          gravity: 1.5,
          ticks: 200
        })
      }, 100)
    }
  })

  // MEGA CONFETTI for natural 20!
  const hasNat20 = results.some(r => r.sides === 20 && r.value === 20)
  if (hasNat20) {
    setTimeout(() => {
      const duration = 3000
      const animationEnd = Date.now() + duration
      const defaults = {
        startVelocity: 30,
        spread: 360,
        ticks: 60,
        zIndex: 0,
        colors: ['#ffffff', '#f5f5f5', '#ffd700', '#ffed4e']
      }

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min
      }

      const interval = setInterval(function () {
        const timeLeft = animationEnd - Date.now()

        if (timeLeft <= 0) {
          return clearInterval(interval)
        }

        const particleCount = 50 * (timeLeft / duration)

        confetti(
          Object.assign({}, defaults, {
            particleCount,
            origin: {x: randomInRange(0.1, 0.3), y: Math.random() - 0.2}
          })
        )
        confetti(
          Object.assign({}, defaults, {
            particleCount,
            origin: {x: randomInRange(0.7, 0.9), y: Math.random() - 0.2}
          })
        )
      }, 250)

      confetti({
        particleCount: 200,
        spread: 160,
        origin: {x: 0.5, y: 0.5},
        colors: ['#ffffff', '#f5f5f5', '#ffd700', '#ffed4e'],
        scalar: 1.5,
        gravity: 1,
        ticks: 300
      })
    }, 150)
  }

  rollEl.appendChild(header)
  rollEl.appendChild(diceContainer)

  rollHistory.insertBefore(rollEl, rollHistory.firstChild)

  const maxRolls = 50
  while (rollHistory.children.length > maxRolls) {
    rollHistory.removeChild(rollHistory.lastChild)
  }
}

function updatePeerCount() {
  const count = Object.keys(room.getPeers()).length
  peerCount.textContent =
    count === 0
      ? 'No peers connected'
      : count === 1
        ? '1 peer connected'
        : `${count} peers connected`
}

function moveCursor([x, y], id) {
  const el = cursors[id]

  if (el && typeof x === 'number' && typeof y === 'number') {
    el.style.left = x * innerWidth + 'px'
    el.style.top = y * innerHeight + 'px'
  }
}

function addCursor(id, isSelf) {
  const el = document.createElement('div')
  const img = document.createElement('img')
  const txt = document.createElement('p')

  el.className = 'absolute -ml-[10px] -mt-[2px]'
  el.style.left = el.style.top = '-99px'
  img.src = 'assets/images/hand.png'
  img.className = 'w-[34px] h-[46px]'
  img.style.imageRendering = 'pixelated'
  txt.className = `text-center text-base font-bold ${isSelf ? 'bg-white/80 px-2 rounded' : ''}`
  txt.innerText = peerNames[id] || id.slice(0, 4)
  txt.style.color = peerColors[id] || (isSelf ? myColor : '#ffffff')
  el.appendChild(img)
  el.appendChild(txt)
  canvas.appendChild(el)
  cursors[id] = el

  return el
}

function removeCursor(id) {
  if (cursors[id]) {
    canvas.removeChild(cursors[id])
    delete cursors[id]
  }
}

function getDiceColor(sides) {
  const colorMap = {
    4: ['#ffd700', '#ffed4e', '#fff176'],
    6: ['#dc143c', '#ff1744', '#ff5252'],
    8: ['#4169e1', '#5e7ce2', '#7c9aef'],
    10: ['#9370db', '#a98ee0', '#c5b3e6'],
    12: ['#00ced1', '#33d9dc', '#66e4e7'],
    20: ['#f5f5f5', '#ffffff', '#e8e8e8']
  }
  return colorMap[sides] || ['#ffffff', '#f0f0f0', '#e0e0e0']
}

function simpleMD5Hash(str) {
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i)
    hash = (hash << 5) - hash + char
    hash = hash & hash
  }
  return Math.abs(hash).toString(16).substring(0, 8)
}

function createNewRoom() {
  const roomName = prompt('Enter a name for your new room:')

  if (!roomName) {
    return
  }

  const sanitized = roomName
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')

  if (!sanitized) {
    alert('Please enter a valid room name (letters, numbers, and hyphens only)')
    return
  }

  const timestamp = Date.now()
  const hash = simpleMD5Hash(sanitized + timestamp)
  const newRoomId = `${sanitized}-${hash}`

  window.location.hash = newRoomId
  window.location.reload()
}
