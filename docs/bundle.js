function e(e=0){return new Uint8Array(e)}function t(e=0){return new Uint8Array(e)}const n=268435456,r=34359738368,i=4398046511104,s=Math.pow(2,49),o=128,a=127;function l(e){if(e<128)return 1;if(e<16384)return 2;if(e<2097152)return 3;if(e<n)return 4;if(e<r)return 5;if(e<i)return 6;if(e<s)return 7;if(null!=Number.MAX_SAFE_INTEGER&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function c(e,t,n=0){switch(l(e)){case 8:t[n++]=255&e|o,e/=128;case 7:t[n++]=255&e|o,e/=128;case 6:t[n++]=255&e|o,e/=128;case 5:t[n++]=255&e|o,e/=128;case 4:t[n++]=255&e|o,e>>>=7;case 3:t[n++]=255&e|o,e>>>=7;case 2:t[n++]=255&e|o,e>>>=7;case 1:t[n++]=255&e,e>>>=7;break;default:throw Error("unreachable")}return t}function h(e,t){let l=e[t],c=0;if(c+=l&a,l<o)return c;if(l=e[t+1],c+=(l&a)<<7,l<o)return c;if(l=e[t+2],c+=(l&a)<<14,l<o)return c;if(l=e[t+3],c+=(l&a)<<21,l<o)return c;if(l=e[t+4],c+=(l&a)*n,l<o)return c;if(l=e[t+5],c+=(l&a)*r,l<o)return c;if(l=e[t+6],c+=(l&a)*i,l<o)return c;if(l=e[t+7],c+=(l&a)*s,l<o)return c;throw new RangeError("Could not decode varint")}function u(e,n,r=0){return null==n&&(n=t(l(e))),n instanceof Uint8Array?c(e,n,r):function(e,t,n=0){switch(l(e)){case 8:t.set(n++,255&e|o),e/=128;case 7:t.set(n++,255&e|o),e/=128;case 6:t.set(n++,255&e|o),e/=128;case 5:t.set(n++,255&e|o),e/=128;case 4:t.set(n++,255&e|o),e>>>=7;case 3:t.set(n++,255&e|o),e>>>=7;case 2:t.set(n++,255&e|o),e>>>=7;case 1:t.set(n++,255&e),e>>>=7;break;default:throw Error("unreachable")}return t}(e,n,r)}function d(e,t=0){return e instanceof Uint8Array?h(e,t):function(e,t){let l=e.get(t),c=0;if(c+=l&a,l<o)return c;if(l=e.get(t+1),c+=(l&a)<<7,l<o)return c;if(l=e.get(t+2),c+=(l&a)<<14,l<o)return c;if(l=e.get(t+3),c+=(l&a)<<21,l<o)return c;if(l=e.get(t+4),c+=(l&a)*n,l<o)return c;if(l=e.get(t+5),c+=(l&a)*r,l<o)return c;if(l=e.get(t+6),c+=(l&a)*i,l<o)return c;if(l=e.get(t+7),c+=(l&a)*s,l<o)return c;throw new RangeError("Could not decode varint")}(e,t)}const p=new Float32Array([-0]),f=new Uint8Array(p.buffer);function m(e,t,n){p[0]=e,t[n]=f[0],t[n+1]=f[1],t[n+2]=f[2],t[n+3]=f[3]}const g=new Float64Array([-0]),y=new Uint8Array(g.buffer);function b(e,t,n){g[0]=e,t[n]=y[0],t[n+1]=y[1],t[n+2]=y[2],t[n+3]=y[3],t[n+4]=y[4],t[n+5]=y[5],t[n+6]=y[6],t[n+7]=y[7]}const v=BigInt(Number.MAX_SAFE_INTEGER),w=BigInt(Number.MIN_SAFE_INTEGER);class x{lo;hi;constructor(e,t){this.lo=0|e,this.hi=0|t}toNumber(e=!1){if(!e&&this.hi>>>31>0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(e+4294967296*t)}return this.lo+4294967296*this.hi}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31!=0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(BigInt(e)+(BigInt(t)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(0n===e)return _;if(e<v&&e>w)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,r=e-(n<<32n);return t&&(n=0n|~n,r=0n|~r,++r>E&&(r=0n,++n>E&&(n=0n))),new x(Number(r),Number(n))}static fromNumber(e){if(0===e)return _;const t=e<0;t&&(e=-e);let n=e>>>0,r=(e-n)/4294967296>>>0;return t&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new x(n,r)}static from(e){return"number"==typeof e?x.fromNumber(e):"bigint"==typeof e?x.fromBigInt(e):"string"==typeof e?x.fromBigInt(BigInt(e)):null!=e.low||null!=e.high?new x(e.low>>>0,e.high>>>0):_}}const _=new x(0,0);_.toBigInt=()=>0n,_.zzEncode=_.zzDecode=function(){return this},_.length=()=>1;const E=4294967296n;function S(e,t,n){const r=n;let i,s;for(let r=0;r<e.length;++r)i=e.charCodeAt(r),i<128?t[n++]=i:i<2048?(t[n++]=i>>6|192,t[n++]=63&i|128):55296==(64512&i)&&56320==(64512&(s=e.charCodeAt(r+1)))?(i=65536+((1023&i)<<10)+(1023&s),++r,t[n++]=i>>18|240,t[n++]=i>>12&63|128,t[n++]=i>>6&63|128,t[n++]=63&i|128):(t[n++]=i>>12|224,t[n++]=i>>6&63|128,t[n++]=63&i|128);return n-r}function M(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function A(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class C{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return e;if((this.pos+=5)>this.len)throw this.pos=this.len,M(this,10);return e}int32(){return 0|this.uint32()}sint32(){const e=this.uint32();return e>>>1^-(1&e)}bool(){return 0!==this.uint32()}fixed32(){if(this.pos+4>this.len)throw M(this,4);return A(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw M(this,4);return 0|A(this.buf,this.pos+=4)}float(){if(this.pos+4>this.len)throw M(this,4);const e=(t=this.buf,n=this.pos,f[0]=t[n],f[1]=t[n+1],f[2]=t[n+2],f[3]=t[n+3],p[0]);var t,n;return this.pos+=4,e}double(){if(this.pos+8>this.len)throw M(this,4);const e=(t=this.buf,n=this.pos,y[0]=t[n],y[1]=t[n+1],y[2]=t[n+2],y[3]=t[n+3],y[4]=t[n+4],y[5]=t[n+5],y[6]=t[n+6],y[7]=t[n+7],g[0]);var t,n;return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw M(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return function(e,t,n){if(n-t<1)return"";let r;const i=[];let s,o=0;for(;t<n;)s=e[t++],s<128?i[o++]=s:s>191&&s<224?i[o++]=(31&s)<<6|63&e[t++]:s>239&&s<365?(s=((7&s)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,i[o++]=55296+(s>>10),i[o++]=56320+(1023&s)):i[o++]=(15&s)<<12|(63&e[t++])<<6|63&e[t++],o>8191&&((r??(r=[])).push(String.fromCharCode.apply(String,i)),o=0);return null!=r?(o>0&&r.push(String.fromCharCode.apply(String,i.slice(0,o))),r.join("")):String.fromCharCode.apply(String,i.slice(0,o))}(e,0,e.length)}skip(e){if("number"==typeof e){if(this.pos+e>this.len)throw M(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw M(this)}while(128&this.buf[this.pos++]);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new x(0,0);let t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw M(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw M(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw M(this,8);const e=A(this.buf,this.pos+=4),t=A(this.buf,this.pos+=4);return new x(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=h(this.buf,this.pos);return this.pos+=l(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function T(e,t,n){const r=function(e){return new C(e instanceof Uint8Array?e:e.subarray())}(e);return t.decode(r,void 0,n)}function I(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw Error("Unknown type, must be binary type")}var L=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var s=e.charAt(i),o=s.charCodeAt(0);if(255!==n[o])throw new TypeError(s+" is ambiguous");n[o]=i}var a=e.length,l=e.charAt(0),c=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function u(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===l;)r++,t++;for(var s=(e.length-t)*c+1>>>0,o=new Uint8Array(s);e[t];){var h=n[e.charCodeAt(t)];if(255===h)return;for(var u=0,d=s-1;(0!==h||u<i)&&-1!==d;d--,u++)h+=a*o[d]>>>0,o[d]=h%256>>>0,h=h/256>>>0;if(0!==h)throw Error("Non-zero carry");i=u,t++}if(" "!==e[t]){for(var p=s-i;p!==s&&0===o[p];)p++;for(var f=new Uint8Array(r+(s-p)),m=r;p!==s;)f[m++]=o[p++];return f}}}return{encode(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,s=t.length;i!==s&&0===t[i];)i++,n++;for(var o=(s-i)*h+1>>>0,c=new Uint8Array(o);i!==s;){for(var u=t[i],d=0,p=o-1;(0!==u||d<r)&&-1!==p;p--,d++)u+=256*c[p]>>>0,c[p]=u%a>>>0,u=u/a>>>0;if(0!==u)throw Error("Non-zero carry");r=d,i++}for(var f=o-r;f!==o&&0===c[f];)f++;for(var m=l.repeat(n);f<o;++f)m+=e.charAt(c[f]);return m},decodeUnsafe:u,decode(e){var n=u(e);if(n)return n;throw Error(`Non-${t} character`)}}},P=L;let R=class{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},D=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const r=t.codePointAt(0);if(void 0===r)throw Error("Invalid prefix character");this.prefixCodePoint=r,this.baseDecode=n}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return N(this,e)}};class k{decoders;constructor(e){this.decoders=e}or(e){return N(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(null!=n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function N(e,t){return new k({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class F{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new R(e,t,n),this.decoder=new D(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function O({name:e,prefix:t,encode:n,decode:r}){return new F(e,t,n,r)}function B({name:e,prefix:t,alphabet:n}){const{encode:r,decode:i}=P(n,e);return O({prefix:t,name:e,encode:r,decode(e){return I(i(e))}})}function z({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const i=function(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}(r);return O({prefix:t,name:e,encode:e=>function(e,t,n){const r="="===t[t.length-1],i=(1<<n)-1;let s="",o=0,a=0;for(let r=0;r<e.length;++r)for(a=a<<8|e[r],o+=8;o>n;)o-=n,s+=t[i&a>>o];if(0!==o&&(s+=t[i&a<<n-o]),r)for(;s.length*n&7;)s+="=";return s}(e,r,n),decode:t=>function(e,t,n,r){let i=e.length;for(;"="===e[i-1];)--i;const s=new Uint8Array(i*n/8|0);let o=0,a=0,l=0;for(let c=0;c<i;++c){const i=t[e[c]];if(void 0===i)throw new SyntaxError(`Non-${r} character`);a=a<<n|i,o+=n,o>=8&&(o-=8,s[l++]=255&a>>o)}if(o>=n||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return s}(t,i,n,e)})}const U=B({prefix:"9",name:"base10",alphabet:"0123456789"});var H=Object.freeze({__proto__:null,base10:U});const q=z({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),V=z({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var G=Object.freeze({__proto__:null,base16:q,base16upper:V});const W=z({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var j=Object.freeze({__proto__:null,base2:W});const $=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),K=$.reduce((e,t,n)=>(e[n]=t,e),[]),X=$.reduce((e,t,n)=>{const r=t.codePointAt(0);if(null==r)throw Error("Invalid character: "+t);return e[r]=n,e},[]);const Y=O({prefix:"🚀",name:"base256emoji",encode(e){return e.reduce((e,t)=>e+=K[t],"")},decode(e){const t=[];for(const n of e){const e=n.codePointAt(0);if(null==e)throw Error("Invalid character: "+n);const r=X[e];if(null==r)throw Error("Non-base256emoji character: "+n);t.push(r)}return new Uint8Array(t)}});var Z=Object.freeze({__proto__:null,base256emoji:Y});const J=z({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Q=z({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ee=z({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),te=z({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ne=z({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),re=z({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ie=z({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),se=z({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),oe=z({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ae=Object.freeze({__proto__:null,base32:J,base32hex:ne,base32hexpad:ie,base32hexpadupper:se,base32hexupper:re,base32pad:ee,base32padupper:te,base32upper:Q,base32z:oe});const le=B({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ce=B({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var he=Object.freeze({__proto__:null,base36:le,base36upper:ce});const ue=B({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),de=B({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var pe=Object.freeze({__proto__:null,base58btc:ue,base58flickr:de});const fe=z({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),me=z({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ge=z({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ye=z({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var be=Object.freeze({__proto__:null,base64:fe,base64pad:me,base64url:ge,base64urlpad:ye});const ve=z({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var we=Object.freeze({__proto__:null,base8:ve});const xe=O({prefix:"\0",name:"identity",encode(e){return function(e){return(new TextDecoder).decode(e)}(e)},decode(e){return function(e){return(new TextEncoder).encode(e)}(e)}});var _e=Object.freeze({__proto__:null,identity:xe});new TextEncoder,new TextDecoder;var Ee=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=Ae;)n[r++]=255&t|Se,t/=128;for(;t&Me;)n[r++]=255&t|Se,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},Se=128,Me=-128,Ae=2147483648;var Ce=function e(t,n){var r,i=0,s=0,o=n=n||0,a=t.length;do{if(o>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[o++],i+=s<28?(r&Ie)<<s:(r&Ie)*Math.pow(2,s),s+=7}while(r>=Te);return e.bytes=o-n,i},Te=128,Ie=127;var Le=Math.pow(2,63),Pe={encode:Ee,decode:Ce,encodingLength(e){return e<128?1:e<16384?2:e<2097152?3:e<268435456?4:e<34359738368?5:e<4398046511104?6:e<562949953421312?7:e<72057594037927940?8:e<Le?9:10}},Re=Pe;function De(e,t=0){return[Re.decode(e,t),Re.decode.bytes]}function ke(e,t,n=0){return Re.encode(e,t,n),t}function Ne(e){return Re.encodingLength(e)}function Fe(e,t){const n=t.byteLength,r=Ne(e),i=r+Ne(n),s=new Uint8Array(i+n);return ke(e,s,0),ke(n,s,r),s.set(t,i),new Be(e,n,t,s)}function Oe(e){const t=I(e),[n,r]=De(t),[i,s]=De(t.subarray(r)),o=t.subarray(r+s);if(o.byteLength!==i)throw Error("Incorrect length");return new Be(n,i,o,t)}class Be{code;size;digest;bytes;constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const ze=I;const Ue={code:0,name:"identity",encode:ze,digest(e,t){if(null!=t?.truncate&&t.truncate!==e.byteLength){if(t.truncate<0||t.truncate>e.byteLength)throw Error("Invalid truncate option, must be less than or equal to "+e.byteLength);e=e.subarray(0,t.truncate)}return Fe(0,ze(e))}};class He{name;code;encode;minDigestLength;maxDigestLength;constructor(e,t,n,r,i){this.name=e,this.code=t,this.encode=n,this.minDigestLength=r??20,this.maxDigestLength=i}digest(e,t){if(null!=t?.truncate){if(t.truncate<this.minDigestLength)throw Error("Invalid truncate option, must be greater than or equal to "+this.minDigestLength);if(null!=this.maxDigestLength&&t.truncate>this.maxDigestLength)throw Error("Invalid truncate option, must be less than or equal to "+this.maxDigestLength)}if(e instanceof Uint8Array){const n=this.encode(e);return n instanceof Uint8Array?qe(n,this.code,t?.truncate):n.then(e=>qe(e,this.code,t?.truncate))}throw Error("Unknown type, must be binary type")}}function qe(e,t,n){if(null!=n&&n!==e.byteLength){if(n>e.byteLength)throw Error("Invalid truncate option, must be less than or equal to "+e.byteLength);e=e.subarray(0,n)}return Fe(t,e)}const Ve=function({name:e,code:t,encode:n,minDigestLength:r,maxDigestLength:i}){return new He(e,t,n,r,i)}({name:"sha2-256",code:18,encode:function(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}("SHA-256")});function Ge(e,t){const{bytes:n,version:r}=e;return 0===r?function(e,t,n){const{prefix:r}=n;if(r!==ue.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i}(n,je(e),t??ue.encoder):function(e,t,n){const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i}(n,je(e),t??J.encoder)}const We=new WeakMap;function je(e){const t=We.get(e);if(null==t){const t=new Map;return We.set(e,t),t}return t}class $e{code;version;multihash;bytes;"/";constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Ke)throw Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Xe)throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");return $e.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=Fe(e,t);return $e.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return $e.equals(this,e)}static equals(e,t){const n=t;return null!=n&&e.code===n.code&&e.version===n.version&&function(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}}(e.multihash,n.multihash)}toString(e){return Ge(this,e)}toJSON(){return{"/":Ge(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof $e)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new $e(e,n,r,i??Ye(e,n,r.bytes))}if(!0===t[Ze]){const{version:e,multihash:n,code:r}=t,i=Oe(n);return $e.create(e,r,i)}return null}static create(e,t,n){if("number"!=typeof t)throw Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw Error("Invalid digest");switch(e){case 0:if(t!==Ke)throw Error(`Version 0 CID must use dag-pb (code: ${Ke}) block encoding`);return new $e(e,t,n,n.bytes);case 1:{const r=Ye(e,t,n.bytes);return new $e(e,t,n,r)}default:throw Error("Invalid version")}}static createV0(e){return $e.create(0,Ke,e)}static createV1(e,t){return $e.create(1,e,t)}static decode(e){const[t,n]=$e.decodeFirst(e);if(0!==n.length)throw Error("Incorrect length");return t}static decodeFirst(e){const t=$e.inspectBytes(e),n=t.size-t.multihashSize,r=I(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),s=new Be(t.multihashCode,t.digestSize,i,r);return[0===t.version?$e.createV0(s):$e.createV1(t.codec,s),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=De(e.subarray(t));return t+=r,n};let r=n(),i=Ke;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version "+r);const s=t,o=n(),a=n(),l=t+a;return{version:r,codec:i,multihashCode:o,digestSize:a,multihashSize:l-s,size:l}}static parse(e,t){const[n,r]=function(e,t){switch(e[0]){case"Q":{const n=t??ue;return[ue.prefix,n.decode(`${ue.prefix}${e}`)]}case ue.prefix:{const n=t??ue;return[ue.prefix,n.decode(e)]}case J.prefix:{const n=t??J;return[J.prefix,n.decode(e)]}case le.prefix:{const n=t??le;return[le.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),i=$e.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return je(i).set(n,e),i}}const Ke=112,Xe=18;function Ye(e,t,n){const r=Ne(e),i=r+Ne(t),s=new Uint8Array(i+n.byteLength);return ke(e,s,0),ke(t,s,r),s.set(n,i),s}const Ze=Symbol.for("@ipld/js-cid/CID"),Je={..._e,...j,...we,...H,...G,...ae,...he,...pe,...be,...Z};function Qe(e,t,n,r){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:n},decoder:{decode:r}}}const et=Qe("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>(new TextEncoder).encode(e.substring(1))),tt=Qe("ascii","a",e=>{let t="a";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},e=>{const n=t((e=e.substring(1)).length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);return n}),nt={utf8:et,"utf-8":et,hex:Je.base16,latin1:tt,ascii:tt,binary:tt,...Je};function rt(e,t="utf8"){const n=nt[t];if(null==n)throw Error(`Unsupported encoding "${t}"`);return n.decoder.decode(`${n.prefix}${e}`)}class it{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function st(){}class ot{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const at=function(){const e=8192;let n,r=e;return function(i){if(i<1||i>4096)return t(i);r+i>e&&(n=t(e),r=0);const s=n.subarray(r,r+=i);return 7&r&&(r=1+(7|r)),s}}();class lt{len;head;tail;states;constructor(){this.len=0,this.head=new it(st,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new it(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new ut((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(dt,10,x.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=x.fromBigInt(e);return this._push(dt,t.length(),t)}uint64Number(e){return this._push(c,l(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=x.fromBigInt(e).zzEncode();return this._push(dt,t.length(),t)}sint64Number(e){const t=x.fromNumber(e).zzEncode();return this._push(dt,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(ct,1,e?1:0)}fixed32(e){return this._push(pt,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=x.fromBigInt(e);return this._push(pt,4,t.lo)._push(pt,4,t.hi)}fixed64Number(e){const t=x.fromNumber(e);return this._push(pt,4,t.lo)._push(pt,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(m,4,e)}double(e){return this._push(b,8,e)}bytes(e){const t=e.length>>>0;return 0===t?this._push(ct,1,0):this.uint32(t)._push(ft,t,e)}string(e){const t=function(e){let t=0,n=0;for(let r=0;r<e.length;++r)n=e.charCodeAt(r),n<128?t+=1:n<2048?t+=2:55296==(64512&n)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t}(e);return 0!==t?this.uint32(t)._push(S,t,e):this._push(ct,1,0)}fork(){return this.states=new ot(this),this.head=this.tail=new it(st,0,0),this.len=0,this}reset(){return null!=this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new it(st,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),0!==n&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const n=(r=this.len,null!=globalThis.Buffer?t(r):at(r));var r;let i=0;for(;null!=e;)e.fn(e.val,n,i),i+=e.len,e=e.next;return n}}function ct(e,t,n){t[n]=255&e}function ht(e,t,n){for(;e>127;)t[n++]=127&e|128,e>>>=7;t[n]=e}class ut extends it{next;constructor(e,t){super(ht,e,t),this.next=void 0}}function dt(e,t,n){for(;0!==e.hi;)t[n++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=127&e.lo|128,e.lo=e.lo>>>7;t[n++]=e.lo}function pt(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function ft(e,t,n){t.set(e,n)}function mt(e,t,n){t.set(e,n)}function gt(e,t,n){e.length<40?S(e,t,n):null!=t.utf8Write?t.utf8Write(e,n):t.set(rt(e),n)}function yt(e,t){const n=new lt;return t.encode(e,n,{lengthDelimited:!1}),n.finish()}var bt,vt,wt,xt,_t,Et,St,Mt,At,Ct,Tt,It,Lt,Pt,Rt,Dt,kt,Nt,Ft,Ot,Bt,zt,Ut,Ht,qt,Vt,Gt,Wt,jt,$t,Kt,Xt;function Yt(e,t,n,r){return{name:e,type:t,encode:n,decode:r}}function Zt(e){function t(t){if(null==e[t.toString()])throw Error("Invalid enum value");return e[t]}return Yt("enum",bt.VARINT,function(e,n){const r=t(e);n.int32(r)},function(e){return t(e.int32())})}function Jt(e,t){return Yt("message",bt.LENGTH_DELIMITED,e,t)}null!=globalThis.Buffer&&(lt.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(mt,t,e),this},lt.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(gt,t,e),this}),(e=>{e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(bt||(bt={}));class Qt extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class en extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}function tn(e){return!!e}function nn(e){const t=new Map;return e.forEach(e=>{let n=t.get(e.contentTopic);n||(t.set(e.contentTopic,[]),n=t.get(e.contentTopic)),n.push(e)}),t}(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.proof=t.bytes();break;case 2:r.merkleRoot=t.bytes();break;case 3:r.epoch=t.bytes();break;case 4:r.shareX=t.bytes();break;case 5:r.shareY=t.bytes();break;case 6:r.nullifier=t.bytes();break;case 7:r.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(vt||(vt={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),vt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==n.lengthDelimited&&t.ldelim()},(t,n,r={})=>{const i={payload:e(0),contentTopic:""},s=null==n?t.len:t.pos+n;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:i.payload=t.bytes();break;case 2:i.contentTopic=t.string();break;case 3:i.version=t.uint32();break;case 10:i.timestamp=t.sint64();break;case 11:i.meta=t.bytes();break;case 21:i.rateLimitProof=vt.codec().decode(t,t.uint32(),{limits:r.limits?.rateLimitProof});break;case 31:i.ephemeral=t.bool();break;default:t.skipType(7&e)}}return i})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(wt||(wt={})),(e=>{let t;(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(10),t.string(e.contentTopic)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={contentTopic:""},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3==1)n.contentTopic=e.string();else e.skipType(7&t)}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(e.ContentFilter||(e.ContentFilter={})),e.codec=()=>(null==t&&(t=Jt((t,n,r={})=>{if(!1!==r.lengthDelimited&&n.fork(),null!=t.subscribe&&!1!==t.subscribe&&(n.uint32(8),n.bool(t.subscribe)),null!=t.topic&&""!==t.topic&&(n.uint32(18),n.string(t.topic)),null!=t.contentFilters)for(const r of t.contentFilters)n.uint32(26),e.ContentFilter.codec().encode(r,n);!1!==r.lengthDelimited&&n.ldelim()},(t,n,r={})=>{const i={subscribe:!1,topic:"",contentFilters:[]},s=null==n?t.len:t.pos+n;for(;t.pos<s;){const n=t.uint32();switch(n>>>3){case 1:i.subscribe=t.bool();break;case 2:i.topic=t.string();break;case 3:if(null!=r.limits?.contentFilters&&i.contentFilters.length===r.limits.contentFilters)throw new Qt('Decode error - map field "contentFilters" had too many elements');i.contentFilters.push(e.ContentFilter.codec().decode(t,t.uint32(),{limits:r.limits?.contentFilters$}));break;default:t.skipType(7&n)}}return i})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(xt||(xt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.messages)for(const n of e.messages)t.uint32(10),Mt.codec().encode(n,t);!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={messages:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();if(t>>>3==1){if(null!=n.limits?.messages&&r.messages.length===n.limits.messages)throw new Qt('Decode error - map field "messages" had too many elements');r.messages.push(Mt.codec().decode(e,e.uint32(),{limits:n.limits?.messages$}))}else e.skipType(7&t)}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(_t||(_t={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.request&&(t.uint32(18),xt.codec().encode(e.request,t)),null!=e.push&&(t.uint32(26),_t.codec().encode(e.push,t)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={requestId:""},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 2:r.request=xt.codec().decode(e,e.uint32(),{limits:n.limits?.request});break;case 3:r.push=_t.codec().decode(e,e.uint32(),{limits:n.limits?.push});break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Et||(Et={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.proof=t.bytes();break;case 2:r.merkleRoot=t.bytes();break;case 3:r.epoch=t.bytes();break;case 4:r.shareX=t.bytes();break;case 5:r.shareY=t.bytes();break;case 6:r.nullifier=t.bytes();break;case 7:r.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(St||(St={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),St.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==n.lengthDelimited&&t.ldelim()},(t,n,r={})=>{const i={payload:e(0),contentTopic:""},s=null==n?t.len:t.pos+n;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:i.payload=t.bytes();break;case 2:i.contentTopic=t.string();break;case 3:i.version=t.uint32();break;case 10:i.timestamp=t.sint64();break;case 11:i.meta=t.bytes();break;case 21:i.rateLimitProof=St.codec().decode(t,t.uint32(),{limits:r.limits?.rateLimitProof});break;case 31:i.ephemeral=t.bool();break;default:t.skipType(7&e)}}return i})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Mt||(Mt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={contentTopic:""},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3==2)n.contentTopic=e.string();else e.skipType(7&t)}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(At||(At={})),(e=>{let t,n,r;(e=>{e.SUBSCRIBER_PING="SUBSCRIBER_PING",e.SUBSCRIBE="SUBSCRIBE",e.UNSUBSCRIBE="UNSUBSCRIBE",e.UNSUBSCRIBE_ALL="UNSUBSCRIBE_ALL"})(t=e.FilterSubscribeType||(e.FilterSubscribeType={})),(e=>{e[e.SUBSCRIBER_PING=0]="SUBSCRIBER_PING",e[e.SUBSCRIBE=1]="SUBSCRIBE",e[e.UNSUBSCRIBE=2]="UNSUBSCRIBE",e[e.UNSUBSCRIBE_ALL=3]="UNSUBSCRIBE_ALL"})(n||(n={})),(e=>{e.codec=()=>Zt(n)})(t=e.FilterSubscribeType||(e.FilterSubscribeType={})),e.codec=()=>(null==r&&(r=Jt((t,r,i={})=>{if(!1!==i.lengthDelimited&&r.fork(),null!=t.requestId&&""!==t.requestId&&(r.uint32(10),r.string(t.requestId)),null!=t.filterSubscribeType&&0!==n[t.filterSubscribeType]&&(r.uint32(16),e.FilterSubscribeType.codec().encode(t.filterSubscribeType,r)),null!=t.pubsubTopic&&(r.uint32(82),r.string(t.pubsubTopic)),null!=t.contentTopics)for(const e of t.contentTopics)r.uint32(90),r.string(e);!1!==i.lengthDelimited&&r.ldelim()},(n,r,i={})=>{const s={requestId:"",filterSubscribeType:t.SUBSCRIBER_PING,contentTopics:[]},o=null==r?n.len:n.pos+r;for(;n.pos<o;){const t=n.uint32();switch(t>>>3){case 1:s.requestId=n.string();break;case 2:s.filterSubscribeType=e.FilterSubscribeType.codec().decode(n);break;case 10:s.pubsubTopic=n.string();break;case 11:if(null!=i.limits?.contentTopics&&s.contentTopics.length===i.limits.contentTopics)throw new Qt('Decode error - map field "contentTopics" had too many elements');s.contentTopics.push(n.string());break;default:n.skipType(7&t)}}return s})),r),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Ct||(Ct={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&0!==e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={requestId:"",statusCode:0},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 10:n.statusCode=e.uint32();break;case 11:n.statusDesc=e.string();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Tt||(Tt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.wakuMessage&&(t.uint32(10),Pt.codec().encode(e.wakuMessage,t)),null!=e.pubsubTopic&&(t.uint32(18),t.string(e.pubsubTopic)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.wakuMessage=Pt.codec().decode(e,e.uint32(),{limits:n.limits?.wakuMessage});break;case 2:r.pubsubTopic=e.string();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(It||(It={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.proof=t.bytes();break;case 2:r.merkleRoot=t.bytes();break;case 3:r.epoch=t.bytes();break;case 4:r.shareX=t.bytes();break;case 5:r.shareY=t.bytes();break;case 6:r.nullifier=t.bytes();break;case 7:r.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Lt||(Lt={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Lt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==n.lengthDelimited&&t.ldelim()},(t,n,r={})=>{const i={payload:e(0),contentTopic:""},s=null==n?t.len:t.pos+n;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:i.payload=t.bytes();break;case 2:i.contentTopic=t.string();break;case 3:i.version=t.uint32();break;case 10:i.timestamp=t.sint64();break;case 11:i.meta=t.bytes();break;case 21:i.rateLimitProof=Lt.codec().decode(t,t.uint32(),{limits:r.limits?.rateLimitProof});break;case 31:i.ephemeral=t.bool();break;default:t.skipType(7&e)}}return i})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Pt||(Pt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.pubsubTopic&&""!==e.pubsubTopic&&(t.uint32(10),t.string(e.pubsubTopic)),null!=e.message&&(t.uint32(18),Ft.codec().encode(e.message,t)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={pubsubTopic:""},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.pubsubTopic=e.string();break;case 2:r.message=Ft.codec().decode(e,e.uint32(),{limits:n.limits?.message});break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Rt||(Rt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.isSuccess&&!1!==e.isSuccess&&(t.uint32(8),t.bool(e.isSuccess)),null!=e.info&&(t.uint32(18),t.string(e.info)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={isSuccess:!1},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.isSuccess=e.bool();break;case 2:n.info=e.string();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Dt||(Dt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.request&&(t.uint32(18),Rt.codec().encode(e.request,t)),null!=e.response&&(t.uint32(26),Dt.codec().encode(e.response,t)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={requestId:""},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 2:r.request=Rt.codec().decode(e,e.uint32(),{limits:n.limits?.request});break;case 3:r.response=Dt.codec().decode(e,e.uint32(),{limits:n.limits?.response});break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(kt||(kt={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.proof=t.bytes();break;case 2:r.merkleRoot=t.bytes();break;case 3:r.epoch=t.bytes();break;case 4:r.shareX=t.bytes();break;case 5:r.shareY=t.bytes();break;case 6:r.nullifier=t.bytes();break;case 7:r.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Nt||(Nt={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Nt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==n.lengthDelimited&&t.ldelim()},(t,n,r={})=>{const i={payload:e(0),contentTopic:""},s=null==n?t.len:t.pos+n;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:i.payload=t.bytes();break;case 2:i.contentTopic=t.string();break;case 3:i.version=t.uint32();break;case 10:i.timestamp=t.sint64();break;case 11:i.meta=t.bytes();break;case 21:i.rateLimitProof=Nt.codec().decode(t,t.uint32(),{limits:r.limits?.rateLimitProof});break;case 31:i.ephemeral=t.bool();break;default:t.skipType(7&e)}}return i})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Ft||(Ft={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.messageHash&&(t.uint32(10),t.bytes(e.messageHash)),null!=e.message&&(t.uint32(18),Ht.codec().encode(e.message,t)),null!=e.pubsubTopic&&(t.uint32(26),t.string(e.pubsubTopic)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.messageHash=e.bytes();break;case 2:r.message=Ht.codec().decode(e,e.uint32(),{limits:n.limits?.message});break;case 3:r.pubsubTopic=e.string();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Ot||(Ot={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.includeData&&!1!==e.includeData&&(t.uint32(16),t.bool(e.includeData)),null!=e.pubsubTopic&&(t.uint32(82),t.string(e.pubsubTopic)),null!=e.contentTopics)for(const n of e.contentTopics)t.uint32(90),t.string(n);if(null!=e.timeStart&&(t.uint32(96),t.sint64(e.timeStart)),null!=e.timeEnd&&(t.uint32(104),t.sint64(e.timeEnd)),null!=e.messageHashes)for(const n of e.messageHashes)t.uint32(162),t.bytes(n);null!=e.paginationCursor&&(t.uint32(410),t.bytes(e.paginationCursor)),null!=e.paginationForward&&!1!==e.paginationForward&&(t.uint32(416),t.bool(e.paginationForward)),null!=e.paginationLimit&&(t.uint32(424),t.uint64(e.paginationLimit)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={requestId:"",includeData:!1,contentTopics:[],messageHashes:[],paginationForward:!1},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 2:r.includeData=e.bool();break;case 10:r.pubsubTopic=e.string();break;case 11:if(null!=n.limits?.contentTopics&&r.contentTopics.length===n.limits.contentTopics)throw new Qt('Decode error - map field "contentTopics" had too many elements');r.contentTopics.push(e.string());break;case 12:r.timeStart=e.sint64();break;case 13:r.timeEnd=e.sint64();break;case 20:if(null!=n.limits?.messageHashes&&r.messageHashes.length===n.limits.messageHashes)throw new Qt('Decode error - map field "messageHashes" had too many elements');r.messageHashes.push(e.bytes());break;case 51:r.paginationCursor=e.bytes();break;case 52:r.paginationForward=e.bool();break;case 53:r.paginationLimit=e.uint64();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Bt||(Bt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),null!=e.messages)for(const n of e.messages)t.uint32(162),Ot.codec().encode(n,t);null!=e.paginationCursor&&(t.uint32(410),t.bytes(e.paginationCursor)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={requestId:"",messages:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 10:r.statusCode=e.uint32();break;case 11:r.statusDesc=e.string();break;case 20:if(null!=n.limits?.messages&&r.messages.length===n.limits.messages)throw new Qt('Decode error - map field "messages" had too many elements');r.messages.push(Ot.codec().decode(e,e.uint32(),{limits:n.limits?.messages$}));break;case 51:r.paginationCursor=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(zt||(zt={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.proof=t.bytes();break;case 2:r.merkleRoot=t.bytes();break;case 3:r.epoch=t.bytes();break;case 4:r.shareX=t.bytes();break;case 5:r.shareY=t.bytes();break;case 6:r.nullifier=t.bytes();break;case 7:r.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Ut||(Ut={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Ut.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==n.lengthDelimited&&t.ldelim()},(t,n,r={})=>{const i={payload:e(0),contentTopic:""},s=null==n?t.len:t.pos+n;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:i.payload=t.bytes();break;case 2:i.contentTopic=t.string();break;case 3:i.version=t.uint32();break;case 10:i.timestamp=t.sint64();break;case 11:i.meta=t.bytes();break;case 21:i.rateLimitProof=Ut.codec().decode(t,t.uint32(),{limits:r.limits?.rateLimitProof});break;case 31:i.ephemeral=t.bool();break;default:t.skipType(7&e)}}return i})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Ht||(Ht={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.enr&&(t.uint32(10),t.bytes(e.enr)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3==1)n.enr=e.bytes();else e.skipType(7&t)}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(qt||(qt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.numPeers&&(t.uint32(8),t.uint64(e.numPeers)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3==1)n.numPeers=e.uint64();else e.skipType(7&t)}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Vt||(Vt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.peerInfos)for(const n of e.peerInfos)t.uint32(10),qt.codec().encode(n,t);!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={peerInfos:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();if(t>>>3==1){if(null!=n.limits?.peerInfos&&r.peerInfos.length===n.limits.peerInfos)throw new Qt('Decode error - map field "peerInfos" had too many elements');r.peerInfos.push(qt.codec().decode(e,e.uint32(),{limits:n.limits?.peerInfos$}))}else e.skipType(7&t)}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Gt||(Gt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.query&&(t.uint32(10),Vt.codec().encode(e.query,t)),null!=e.response&&(t.uint32(18),Gt.codec().encode(e.response,t)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.query=Vt.codec().decode(e,e.uint32(),{limits:n.limits?.query});break;case 2:r.response=Gt.codec().decode(e,e.uint32(),{limits:n.limits?.response});break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Wt||(Wt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.clusterId&&(t.uint32(8),t.uint32(e.clusterId)),null!=e.shards)for(const n of e.shards)t.uint32(16),t.uint32(n);!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={shards:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.clusterId=e.uint32();break;case 2:if(null!=n.limits?.shards&&r.shards.length===n.limits.shards)throw new Qt('Decode error - map field "shards" had too many elements');r.shards.push(e.uint32());break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(jt||(jt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.clusterId&&(t.uint32(8),t.uint32(e.clusterId)),null!=e.shards)for(const n of e.shards)t.uint32(16),t.uint32(n);!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={shards:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.clusterId=e.uint32();break;case 2:if(null!=n.limits?.shards&&r.shards.length===n.limits.shards)throw new Qt('Decode error - map field "shards" had too many elements');r.shards.push(e.uint32());break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})($t||($t={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.messageId&&""!==e.messageId&&(t.uint32(10),t.string(e.messageId)),null!=e.retrievalHint&&(t.uint32(18),t.bytes(e.retrievalHint)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={messageId:""},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.messageId=e.string();break;case 2:n.retrievalHint=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Kt||(Kt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.messageId&&""!==e.messageId&&(t.uint32(18),t.string(e.messageId)),null!=e.channelId&&""!==e.channelId&&(t.uint32(26),t.string(e.channelId)),null!=e.lamportTimestamp&&(t.uint32(80),t.int32(e.lamportTimestamp)),null!=e.causalHistory)for(const n of e.causalHistory)t.uint32(90),Kt.codec().encode(n,t);null!=e.bloomFilter&&(t.uint32(98),t.bytes(e.bloomFilter)),null!=e.content&&(t.uint32(162),t.bytes(e.content)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={messageId:"",channelId:"",causalHistory:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 2:r.messageId=e.string();break;case 3:r.channelId=e.string();break;case 10:r.lamportTimestamp=e.int32();break;case 11:if(null!=n.limits?.causalHistory&&r.causalHistory.length===n.limits.causalHistory)throw new Qt('Decode error - map field "causalHistory" had too many elements');r.causalHistory.push(Kt.codec().decode(e,e.uint32(),{limits:n.limits?.causalHistory$}));break;case 12:r.bloomFilter=e.bytes();break;case 20:r.content=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Xt||(Xt={}));function rn(e){return new Promise(t=>{setTimeout(t,e)})}const sn=e=>e.length/1048576<=1;function on(e,...t){if(!function(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function an(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function ln(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function cn(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function hn(e,t){return e<<32-t|e>>>t}function un(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),on(e),e}let dn=class{};function pn(e){const t=t=>e().update(un(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function fn(e,t,n){return e&t^~e&n}function mn(e,t,n){return e&t^e&n^t&n}let gn=class extends dn{constructor(e,t,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(e),this.view=cn(this.buffer)}update(e){an(this),on(e=un(e));const{view:t,buffer:n,blockLen:r}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);if(o===r){const t=cn(e);for(;r<=i-s;s+=r)this.process(t,s);continue}n.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){an(this),function(e,t){on(e);const n=t.outputLen;if(e.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:i}=this;let{pos:s}=this;t[s++]=128,ln(this.buffer.subarray(s)),this.padOffset>r-s&&(this.process(n,0),s=0);for(let e=s;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const i=BigInt(32),s=BigInt(4294967295),o=Number(n>>i&s),a=Number(n&s),l=r?4:0,c=r?0:4;e.setUint32(t+l,o,r),e.setUint32(t+c,a,r)}(n,r-8,BigInt(8*this.length),i),this.process(n,0);const o=cn(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen should be aligned to 32bit");const l=a/4,c=this.get();if(l>c.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)o.setUint32(4*e,c[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:i,destroyed:s,pos:o}=this;return e.destroyed=s,e.finished=i,e.length=r,e.pos=o,r%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}};const yn=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),vn=new Uint32Array(64);let wn=class extends gn{constructor(e=32){super(64,e,8,!1),this.A=0|yn[0],this.B=0|yn[1],this.C=0|yn[2],this.D=0|yn[3],this.E=0|yn[4],this.F=0|yn[5],this.G=0|yn[6],this.H=0|yn[7]}get(){const{A:e,B:t,C:n,D:r,E:i,F:s,G:o,H:a}=this;return[e,t,n,r,i,s,o,a]}set(e,t,n,r,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)vn[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=vn[e-15],n=vn[e-2],r=hn(t,7)^hn(t,18)^t>>>3,i=hn(n,17)^hn(n,19)^n>>>10;vn[e]=i+vn[e-7]+r+vn[e-16]|0}let{A:n,B:r,C:i,D:s,E:o,F:a,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(hn(o,6)^hn(o,11)^hn(o,25))+fn(o,a,l)+bn[e]+vn[e]|0,h=(hn(n,2)^hn(n,13)^hn(n,22))+mn(n,r,i)|0;c=l,l=a,a=o,o=s+t|0,s=i,i=r,r=n,n=t+h|0}n=n+this.A|0,r=r+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,r,i,s,o,a,l,c)}roundClean(){ln(vn)}destroy(){this.set(0,0,0,0,0,0,0,0),ln(this.buffer)}};const xn=pn(()=>new wn);var _n,En,Sn,Mn,An;(e=>{e.Relay="relay",e.Store="store",e.LightPush="lightpush",e.Filter="filter"})(_n||(_n={})),(e=>{e.GENERIC_FAIL="Generic error",e.REMOTE_PEER_REJECTED="Remote peer rejected",e.DECODE_FAILED="Failed to decode",e.NO_PEER_AVAILABLE="No peer available",e.NO_STREAM_AVAILABLE="No stream available",e.NO_RESPONSE="No response received",e.ENCODE_FAILED="Failed to encode",e.EMPTY_PAYLOAD="Payload is empty",e.SIZE_TOO_BIG="Size is too big",e.TOPIC_NOT_CONFIGURED="Topic not configured",e.STREAM_ABORTED="Stream aborted",e.RLN_PROOF_GENERATION="Proof generation failed",e.TOPIC_DECODER_MISMATCH="Topic decoder mismatch",e.INVALID_DECODER_TOPICS="Invalid decoder topics"})(En||(En={})),(e=>{e.BOOTSTRAP="bootstrap",e.PEER_EXCHANGE="peer-exchange",e.LOCAL="local-peer-cache"})(Sn||(Sn={})),(e=>{e.PEER_DISCOVERY_BOOTSTRAP="peer:discovery:bootstrap",e.PEER_DISCOVERY_PEER_EXCHANGE="peer:discovery:peer-exchange",e.PEER_CONNECT_BOOTSTRAP="peer:connected:bootstrap",e.PEER_CONNECT_PEER_EXCHANGE="peer:connected:peer-exchange"})(Mn||(Mn={})),(e=>{e.CONNECTION_STATUS="waku:connection"})(An||(An={}));const Cn="@waku/bootstrap",Tn={clusterId:1,shards:[0,1,2,3,4,5,6,7,8]};var In,Ln;function Pn(e,t="utf8"){const n=nt[t];if(null==n)throw Error(`Unsupported encoding "${t}"`);return n.encoder.encode(e).substring(1)}function Rn(e){if("string"==typeof e){return rt(e.replace(/^0x/i,"").toLowerCase(),"base16")}return e}(e=>{e.StatusChange="health:change"})(In||(In={})),(e=>{e.Unhealthy="Unhealthy",e.MinimallyHealthy="MinimallyHealthy",e.SufficientlyHealthy="SufficientlyHealthy"})(Ln||(Ln={}));const Dn=e=>Pn(e,"base16"),kn=e=>Pn(e,"utf8"),Nn=e=>rt(e,"utf8");function Fn(e){const t=e.reduce((e,t)=>e+t.length,0),n=new Uint8Array(t);let r=0;for(const t of e)n.set(t,r),r+=t.length;return n}const On=e=>{if("contentTopics"in e&&e.contentTopics)return Array.from(new Set(e.contentTopics.map(t=>qn(t,e.clusterId))));if("shards"in e){if(void 0===e.shards)throw Error("Invalid shard");return Array.from(new Set(e.shards.map(t=>`/waku/2/rs/${e.clusterId??1}/${t}`)))}if("application"in e&&"version"in e)return[qn(`/${e.application}/${e.version}/default/default`,e.clusterId)];throw Error("Missing required configuration in shard parameters")},Bn=e=>{const t=e.split("/");if(6!=t.length||"waku"!==t[1]||"2"!==t[2]||"rs"!==t[3])throw Error("Invalid pubsub topic");const n=parseInt(t[4]),r=parseInt(t[5]);if(isNaN(n)||isNaN(r))throw Error("Invalid clusterId or shard");return{clusterId:n,shard:r}},zn=e=>{const t=new Set,n=new Set;for(const r of e){const{clusterId:e,shard:i}=Bn(r);t.add(`${e}:${i}`),n.add(e)}if(0===t.size)throw Error("No valid pubsub topics provided");if(n.size>1)throw Error("Pubsub topics from multiple cluster IDs are not supported");return{clusterId:n.values().next().value,shards:Array.from(t).map(e=>parseInt(e.split(":")[1]))}};function Un(e,t){if(!t.includes(e))throw Error(`Pubsub topic ${e} has not been configured on this instance. Configured topics are: ${t}. Please update your configuration by passing in the topic during Waku node instantiation.`)}function Hn(e,t=8){const{application:n,version:r}=function(e){const t=e.split("/");if(t.length<5||t.length>6)throw Error("Content topic format is invalid");let n=0;if(6==t.length){if(n=parseInt(t[1]),isNaN(n))throw Error("Invalid generation field in content topic");if(n>0)throw Error("Generation greater than 0 is not supported")}const r=t.splice(-4);if(0==r[0].length)throw Error("Application field cannot be empty");if(0==r[1].length)throw Error("Version field cannot be empty");if(0==r[2].length)throw Error("Topic name field cannot be empty");if(0==r[3].length)throw Error("Encoding field cannot be empty");return{generation:n,application:r[0],version:r[1],topicName:r[2],encoding:r[3]}}(e),i=xn(Fn([Nn(n),Nn(r)])),s=new DataView(i.buffer.slice(-8));return Number(s.getBigUint64(0,!1)%BigInt(t))}function qn(e,t=1,n=8){if(!e)throw Error("Content topic must be specified");return`/waku/2/rs/${t}/${Hn(e,n)}`}function Vn(e,t){return"string"==typeof t?t:void 0!==t?.shard?(e=>{if(void 0===e.shard)throw Error("Invalid shard");return`/waku/2/rs/${e.clusterId??1}/${e.shard}`})(t):qn(e,t?.clusterId??1)}const Gn=e=>{if((e=new Uint8Array(e)).length<3)throw Error("Insufficient data");const t=new DataView(e.buffer),n=t.getUint16(0),r=[];if(130===e.length)for(let e=0;e<1024;e++){const n=Math.floor(e/8)+2,i=7-e%8;t.getUint8(n)&1<<i&&r.push(e)}else{const n=t.getUint8(2);for(let i=0,s=3;i<n;i++,s+=2){if(s+1>=e.length)throw Error("Unexpected end of data");r.push(t.getUint16(s))}}return{clusterId:n,shards:r}},Wn=e=>{const{clusterId:t,shards:n}=e,r=n.length>=64?130:3+2*n.length,i=new ArrayBuffer(r),s=new DataView(i);if(s.setUint16(0,t),n.length>=64)for(const e of n){const t=Math.floor(e/8)+2,n=7-e%8;s.setUint8(t,s.getUint8(t)|1<<n)}else{s.setUint8(2,n.length);for(let e=0,t=3;e<n.length;e++,t+=2)s.setUint16(t,n[e])}return new Uint8Array(i)};var jn="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function $n(e){return e&&e.__esModule&&{}.hasOwnProperty.call(e,"default")?e.default:e}var Kn,Xn,Yn,Zn,Jn,Qn={exports:{}};function er(){if(Xn)return Kn;Xn=1;var e=1e3,t=60*e,n=60*t,r=24*n,i=7*r,s=365.25*r;function o(e,t,n,r){var i=t>=1.5*n;return Math.round(e/n)+" "+r+(i?"s":"")}return Kn=(a,l)=>{l=l||{};var c=typeof a;if("string"===c&&a.length>0)return function(o){if((o+="").length>100)return;var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(o);if(!a)return;var l=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return l*s;case"weeks":case"week":case"w":return l*i;case"days":case"day":case"d":return l*r;case"hours":case"hour":case"hrs":case"hr":case"h":return l*n;case"minutes":case"minute":case"mins":case"min":case"m":return l*t;case"seconds":case"second":case"secs":case"sec":case"s":return l*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return l;default:return}}(a);if("number"===c&&isFinite(a))return l.long?function(i){var s=Math.abs(i);if(s>=r)return o(i,s,r,"day");if(s>=n)return o(i,s,n,"hour");if(s>=t)return o(i,s,t,"minute");if(s>=e)return o(i,s,e,"second");return i+" ms"}(a):function(i){var s=Math.abs(i);if(s>=r)return Math.round(i/r)+"d";if(s>=n)return Math.round(i/n)+"h";if(s>=t)return Math.round(i/t)+"m";if(s>=e)return Math.round(i/e)+"s";return i+"ms"}(a);throw Error("val is not a non-empty string or a valid number. val="+JSON.stringify(a))},Kn}var tr=(Jn||(Jn=1,function(e,t){t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let r=0,i=0;t[0].replace(/%[a-zA-Z%]/g,e=>{"%%"!==e&&(r++,"%c"===e&&(i=r))}),t.splice(i,0,n)},t.save=e=>{try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=()=>{let e;try{e=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e},t.useColors=()=>{if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let e;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&(e=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(e[1],10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=(()=>{try{return localStorage}catch(e){}})(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=(Zn||(Zn=1,Yn=function(e){function t(e){let r,i,s,o=null;function a(...e){if(!a.enabled)return;const n=a,i=Number(new Date),s=i-(r||i);n.diff=s,n.prev=r,n.curr=i,r=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let o=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(r,i)=>{if("%%"===r)return"%";o++;const s=t.formatters[i];if("function"==typeof s){const t=e[o];r=s.call(n,t),e.splice(o,1),o--}return r}),t.formatArgs.call(n,e),(n.log||t.log).apply(n,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=n,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==o?o:(i!==t.namespaces&&(i=t.namespaces,s=t.enabled(e)),s),set(e){o=e}}),"function"==typeof t.init&&t.init(a),a}function n(e,n){const r=t(this.namespace+(void 0===n?":":n)+e);return r.log=this.log,r}function r(e,t){let n=0,r=0,i=-1,s=0;for(;n<e.length;)if(r<t.length&&(t[r]===e[n]||"*"===t[r]))"*"===t[r]?(i=r,s=n,r++):(n++,r++);else{if(-1===i)return!1;r=i+1,s++,n=s}for(;r<t.length&&"*"===t[r];)r++;return r===t.length}return t.debug=t,t.default=t,t.coerce=e=>e instanceof Error?e.stack||e.message:e,t.disable=()=>{const e=[...t.names,...t.skips.map(e=>"-"+e)].join(",");return t.enable(""),e},t.enable=e=>{t.save(e),t.namespaces=e,t.names=[],t.skips=[];const n=("string"==typeof e?e:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const e of n)"-"===e[0]?t.skips.push(e.slice(1)):t.names.push(e)},t.enabled=e=>{for(const n of t.skips)if(r(e,n))return!1;for(const n of t.names)if(r(e,n))return!0;return!1},t.humanize=er(),t.destroy=()=>{console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach(n=>{t[n]=e[n]}),t.names=[],t.skips=[],t.formatters={},t.selectColor=e=>{let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t}),Yn)(t);const{formatters:n}=e.exports;n.j=e=>{try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}(Qn,Qn.exports)),Qn.exports),nr=$n(tr);const rr="waku";let ir=class e{_info;_warn;_error;static createDebugNamespace(e,t){return t?`${rr}:${e}:${t}`:`${rr}:${e}`}constructor(t){this._info=nr(e.createDebugNamespace("info",t)),this._warn=nr(e.createDebugNamespace("warn",t)),this._error=nr(e.createDebugNamespace("error",t))}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}log(e,...t){(0,this[e])(...t)}};const sr=new ir("message:version-0"),or=BigInt(1e6);class ar{pubsubTopic;proto;constructor(e,t){this.pubsubTopic=e,this.proto=t}get ephemeral(){return!!this.proto.ephemeral}get payload(){return this.proto.payload}get contentTopic(){return this.proto.contentTopic}get _rawTimestamp(){return this.proto.timestamp}get timestamp(){try{if(this.proto.timestamp){const e=this.proto.timestamp/or;return new Date(Number(e))}return}catch(e){return}}get meta(){return this.proto.meta}get version(){return this.proto.version??0}get rateLimitProof(){return this.proto.rateLimitProof}}let lr=class{contentTopic;ephemeral;pubsubTopic;metaSetter;constructor(e,t=!1,n,r){if(this.contentTopic=e,this.ephemeral=t,this.pubsubTopic=n,this.metaSetter=r,!e||""===e)throw Error("Content topic must be specified")}async toWire(e){return wt.encode(await this.toProtoObj(e))}async toProtoObj(e){const t=e.timestamp??new Date,n={payload:e.payload,version:0,contentTopic:this.contentTopic,timestamp:BigInt(t.valueOf())*or,meta:void 0,rateLimitProof:e.rateLimitProof,ephemeral:this.ephemeral};if(this.metaSetter){const e=this.metaSetter(n);return{...n,meta:e}}return n}};function cr({pubsubTopic:e,pubsubTopicShardInfo:t,contentTopic:n,ephemeral:r,metaSetter:i}){return new lr(n,r,Vn(n,e??t),i)}let hr=class{pubsubTopic;contentTopic;constructor(e,t){if(this.pubsubTopic=e,this.contentTopic=t,!t||""===t)throw Error("Content topic must be specified")}fromWireToProtoObj(e){const t=wt.decode(e);return Promise.resolve({payload:t.payload,contentTopic:t.contentTopic,version:t.version??void 0,timestamp:t.timestamp??void 0,meta:t.meta??void 0,rateLimitProof:t.rateLimitProof??void 0,ephemeral:t.ephemeral??!1})}async fromProtoObj(e,t){return t.version?(sr.error("Failed to decode due to incorrect version, expected:",0,", actual:",t.version),Promise.resolve(void 0)):new ar(e,t)}};function ur(e,t){return new hr(Vn(e,t),e)}function dr(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const n of e)t.push(n);return t})();const t=[];for(const n of e)t.push(n);return t}function pr(e,n){null==n&&(n=e.reduce((e,t)=>e+t.length,0));const r=t(n);let i=0;for(const t of e)r.set(t,i),i+=t.length;return r}function fr(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}const mr=Symbol.for("@achingbrain/uint8arraylist");function gr(e,t){if(null==t||t<0)throw new RangeError("index is out of bounds");let n=0;for(const r of e){const e=n+r.byteLength;if(t<e)return{buf:r,index:t-n};n=e}throw new RangeError("index is out of bounds")}function yr(e){return!!e?.[mr]}class br{bufs;length;[mr]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else{if(!yr(n))throw Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");t+=n.byteLength,this.bufs.push(...n.bufs)}this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else{if(!yr(n))throw Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");t+=n.byteLength,this.bufs.unshift(...n.bufs)}this.length+=t}get(e){const t=gr(this.bufs,e);return t.buf[t.index]}set(e,t){const n=gr(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else{if(!yr(e))throw Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");for(let n=0;n<e.length;n++)this.set(t+n,e.get(n))}}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength)return this.bufs=[],void(this.length=0);for(;this.bufs.length>0;){if(!(e>=this.bufs[0].byteLength)){this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift()}}}slice(e,t){const{bufs:n,length:r}=this._subList(e,t);return pr(n,r)}subarray(e,t){const{bufs:n,length:r}=this._subList(e,t);return 1===n.length?n[0]:pr(n,r)}sublist(e,t){const{bufs:n,length:r}=this._subList(e,t),i=new br;return i.length=r,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(0===e&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let r=0;for(let i=0;i<this.bufs.length;i++){const s=this.bufs[i],o=r,a=o+s.byteLength;if(r=a,e>=a)continue;const l=e>=o&&e<a,c=t>o&&t<=a;if(l&&c){if(e===o&&t===a){n.push(s);break}const r=e-o;n.push(s.subarray(r,r+(t-e)));break}if(l){if(0===e){n.push(s);continue}n.push(s.subarray(e-o))}else{if(c){if(t===a){n.push(s);break}n.push(s.subarray(0,t-o));break}n.push(s)}}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!(yr(e)||e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(isNaN(t=Number(t??0))&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const r=n.byteLength;if(0===r)throw new TypeError("search must be at least 1 byte long");const i=new Int32Array(256);for(let e=0;e<256;e++)i[e]=-1;for(let e=0;e<r;e++)i[n[e]]=e;const s=i,o=this.byteLength-n.byteLength,a=n.byteLength-1;let l;for(let e=t;e<=o;e+=l){l=0;for(let t=a;t>=0;t--){const r=this.get(e+t);if(n[t]!==r){l=Math.max(1,t-s[r]);break}}if(0===l)return e}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,n){const r=t(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,n),this.write(r,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(t,n,r){const i=e(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,n,r),this.write(i,t)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(t,n,r){const i=e(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,n,r),this.write(i,t)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(t,n,r){const i=e(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,n,r),this.write(i,t)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,n){const r=t(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,n),this.write(r,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(t,n,r){const i=e(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,n,r),this.write(i,t)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(t,n,r){const i=e(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,n,r),this.write(i,t)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(t,n,r){const i=e(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,n,r),this.write(i,t)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(t,n,r){const i=e(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,n,r),this.write(i,t)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(t,n,r){const i=e(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,n,r),this.write(i,t)}equals(e){if(null==e)return!1;if(!(e instanceof br))return!1;if(e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!fr(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new br;return n.bufs=e,null==t&&(t=e.reduce((e,t)=>e+t.byteLength,0)),n.length=t,n}}function vr(e){return null!=e[Symbol.asyncIterator]}const wr=e=>{const n=l(e),r=t(n);return u(e,r),wr.bytes=n,r};function xr(e,t){const n=(t=t??{}).lengthEncoder??wr;function*r(e){const t=n(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return vr(e)?async function*(){for await(const t of e)yield*r(t)}():function*(){for(const t of e)yield*r(t)}()}wr.bytes=0,xr.single=(e,t)=>{const n=(t=t??{}).lengthEncoder??wr;return new br(n(e.byteLength),e)};let _r=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Er=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Sr=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Mr=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var Ar;(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(Ar||(Ar={}));const Cr=e=>{const t=d(e);return Cr.bytes=l(t),t};function Tr(e,t){const n=new br;let r=Ar.LENGTH,i=-1;const s=t?.lengthDecoder??Cr,o=t?.maxLengthLength??8,a=t?.maxDataLength??4194304;function*l(){for(;n.byteLength>0;){if(r===Ar.LENGTH)try{if(i=s(n),i<0)throw new _r("Invalid message length");if(i>a)throw new Er("Message length too long");const e=s.bytes;n.consume(e),null!=t?.onLength&&t.onLength(i),r=Ar.DATA}catch(e){if(e instanceof RangeError){if(n.byteLength>o)throw new Sr("Message length length too long");break}throw e}if(r===Ar.DATA){if(n.byteLength<i)break;const e=n.sublist(0,i);n.consume(i),null!=t?.onData&&t.onData(e),yield e,r=Ar.LENGTH}}}return vr(e)?async function*(){for await(const t of e)n.append(t),yield*l();if(n.byteLength>0)throw new Mr("Unexpected end of input")}():function*(){for(const t of e)n.append(t),yield*l();if(n.byteLength>0)throw new Mr("Unexpected end of input")}()}function Ir(){const e={};return e.promise=new Promise((t,n)=>{e.resolve=t,e.reject=n}),e}Cr.bytes=0,Tr.fromReader=(e,t)=>{let n=1;const r=async function*(){for(;;)try{const{done:t,value:r}=await e.next(n);if(!0===t)return;null!=r&&(yield r)}catch(e){if("ERR_UNDER_READ"===e.code)return{done:!0,value:null};throw e}finally{n=1}}();return Tr(r,{...t??{},onLength(e){n=e}})};class Lr{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw Error("Max size for a FixedFIFO should be a power of two");this.buffer=Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class Pr{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Lr(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=e?.byteLength?e.byteLength:1}push(e){if(null!=e?.value&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Lr(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(void 0===e&&null!=this.tail.next){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return null!=e?.value&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Rr=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Dr(e={}){return function(e,t){t=t??{};let n,r,i,s=t.onEnd,o=new Pr,a=Ir();const l=async()=>{try{return o.isEmpty()?i?{done:!0}:await new Promise((t,i)=>{r=s=>{r=null,o.push(s);try{t(e(o))}catch(e){i(e)}return n}}):e(o)}finally{o.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=Ir()})}},c=e=>null!=r?r(e):(o.push(e),n),h=e=>(o=new Pr,null!=r?r({error:e}):(o.push({error:e}),n)),u=e=>{if(i)return n;if(!0!==t?.objectMode&&null==e?.byteLength)throw Error("objectMode was not true but tried to push non-Uint8Array value");return c({done:!1,value:e})},d=e=>i?n:(i=!0,null!=e?h(e):c({done:!0})),p=()=>(o=new Pr,d(),{done:!0}),f=e=>(d(e),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:l,return:p,throw:f,push:u,end:d,get readableLength(){return o.size},async onEmpty(e){const t=e?.signal;if(t?.throwIfAborted(),o.isEmpty())return;let n,r;null!=t&&(n=new Promise((e,n)=>{r=()=>{n(new Rr)},t.addEventListener("abort",r)}));try{await Promise.race([a.promise,n])}finally{null!=r&&null!=t&&t?.removeEventListener("abort",r)}}},null==s)return n;const m=n;return n={[Symbol.asyncIterator](){return this},next:()=>m.next(),throw:e=>(m.throw(e),null!=s&&(s(e),s=void 0),{done:!0}),return:()=>(m.return(),null!=s&&(s(),s=void 0),{done:!0}),push:u,end:e=>(m.end(e),null!=s&&(s(e),s=void 0),n),get readableLength(){return m.readableLength},onEmpty(e){return m.onEmpty(e)}},n}(e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}},e)}let kr=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function Nr(e,t,n){if(null==t)return e;if(t.aborted)return e.catch(()=>{}),Promise.reject(new kr(n?.errorMessage,n?.errorCode,n?.errorName));let r;const i=new kr(n?.errorMessage,n?.errorCode,n?.errorName);try{return await Promise.race([e,new Promise((e,n)=>{r=()=>{n(i)},t.addEventListener("abort",r)})])}finally{null!=r&&t.removeEventListener("abort",r)}}let Fr=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=Ir(),this.haveNext=Ir()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Ir(),e}async throw(e){this.ended=!0,this.error=e,null!=e&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw this.error??Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Ir(),await Nr(this.readNext.promise,t?.signal,t)}};function Or(e){return null!=e[Symbol.asyncIterator]}async function*Br(e){const t=new AbortController,n=new Fr;(async function(e,t,n){try{await Promise.all(e.map(async e=>{for await(const r of e)await t.push(r,{signal:n}),n.throwIfAborted()})),await t.end(void 0,{signal:n})}catch(e){await t.end(e,{signal:n}).catch(()=>{})}})(e,n,t.signal).catch(()=>{});try{yield*n}finally{t.abort()}}function zr(...e){const t=[];for(const n of e)Or(n)||t.push(n);return t.length===e.length?function*(e){for(const t of e)yield*t}(t):Br(e)}function Ur(e,...t){if(null==e)throw Error("Empty pipeline");if(Gr(e)){const t=e;e=()=>t.source}else if(Vr(e)||qr(e)){const t=e;e=()=>t}const n=[e,...t];if(n.length>1&&Gr(n[n.length-1])&&(n[n.length-1]=n[n.length-1].sink),n.length>2)for(let e=1;e<n.length-1;e++)Gr(n[e])&&(n[e]=Wr(n[e]));return Hr(...n)}const Hr=(...e)=>{let t;for(;e.length>0;)t=e.shift()(t);return t},qr=e=>null!=e?.[Symbol.asyncIterator],Vr=e=>null!=e?.[Symbol.iterator],Gr=e=>null!=e&&(null!=e.sink&&null!=e.source),Wr=e=>t=>{const n=e.sink(t);if(null!=n?.then){const t=Dr({objectMode:!0});let r;n.then(()=>{t.end()},e=>{t.end(e)});const i=e.source;if(qr(i))r=async function*(){yield*i,t.end()};else{if(!Vr(i))throw Error("Unknown duplex source type - must be Iterable or AsyncIterable");r=function*(){yield*i,t.end()}}return zr(t,r())}return e.source};function jr(e){return e.filter(e=>"open"===e.status).sort((e,t)=>t.timeline.open-e.timeline.open).at(0)}const $r="consumed";let Kr,Xr=class{multicodec;getConnections;addEventListener;log;ongoingCreation=new Set;streamPool=new Map;constructor(e,t,n){this.multicodec=e,this.getConnections=t,this.addEventListener=n,this.log=new ir("stream-manager:"+e),this.addEventListener("peer:update",this.handlePeerUpdateStreamPool)}async getStream(e){const t=e.toString(),n=this.streamPool.get(t);n&&(this.streamPool.delete(t),await n);let r=this.getOpenStreamForCodec(e);return r?(this.log.info(`Found existing stream peerId=${t} multicodec=${this.multicodec}`),this.lockStream(t,r),r):(r=await this.createStream(e),this.lockStream(t,r),r)}async createStream(e,t=0){const n=jr(this.getConnections(e));if(!n)throw Error(`Failed to get a connection to the peer peerId=${e.toString()} multicodec=${this.multicodec}`);let r,i;for(let s=0;s<t+1;s++)try{this.log.info(`Attempting to create a stream for peerId=${e.toString()} multicodec=${this.multicodec}`),i=await n.newStream(this.multicodec),this.log.info(`Created stream for peerId=${e.toString()} multicodec=${this.multicodec}`);break}catch(e){r=e}if(!i)throw Error(`Failed to create a new stream for ${e.toString()} -- `+r);return i}async createStreamWithLock(e){const t=e.id.toString();if(this.ongoingCreation.has(t))this.log.info(`Skipping creation of a stream due to lock for peerId=${t} multicodec=${this.multicodec}`);else try{this.ongoingCreation.add(t),await this.createStream(e.id)}catch(e){this.log.error("Failed to createStreamWithLock:",e)}finally{this.ongoingCreation.delete(t)}}handlePeerUpdateStreamPool=e=>{const{peer:t}=e.detail;if(!t.protocols.includes(this.multicodec))return;this.getOpenStreamForCodec(t.id)||this.scheduleNewStream(t)};scheduleNewStream(e){this.log.info(`Scheduling creation of a stream for peerId=${e.id.toString()} multicodec=${this.multicodec}`),this.streamPool.has(e.id.toString())&&this.streamPool.delete(e.id.toString()),this.streamPool.set(e.id.toString(),this.createStreamWithLock(e))}getOpenStreamForCodec(e){const t=jr(this.getConnections(e));if(!t)return;const n=t.streams.find(e=>e.protocol===this.multicodec);if(!n)return;return["done","closed","closing"].includes(n.writeStatus||"")||this.isStreamLocked(n)?void 0:n}lockStream(e,t){this.log.info(`Locking stream for peerId:${e}\tstreamId:${t.id}`),t.metadata[$r]=!0}isStreamLocked(e){return!!e.metadata[$r]}},Yr=class{multicodec;components;pubsubTopics;addLibp2pEventListener;removeLibp2pEventListener;streamManager;constructor(e,t,n){this.multicodec=e,this.components=t,this.pubsubTopics=n,this.addLibp2pEventListener=t.events.addEventListener.bind(t.events),this.removeLibp2pEventListener=t.events.removeEventListener.bind(t.events),this.streamManager=new Xr(e,t.connectionManager.getConnections.bind(t.connectionManager),this.addLibp2pEventListener)}async getStream(e){return this.streamManager.getStream(e)}};const Zr=new Uint8Array(16);function Jr(){if(!Kr&&(Kr="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!Kr))throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Kr(Zr)}const Qr=[];for(let e=0;e<256;++e)Qr.push((e+256).toString(16).slice(1));var ei={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function ti(e){if(ei.randomUUID&&!e)return ei.randomUUID();const t=(e=e||{}).random||(e.rng||Jr)();return t[6]=15&t[6]|64,t[8]=63&t[8]|128,function(e,t=0){return Qr[e[t+0]]+Qr[e[t+1]]+Qr[e[t+2]]+Qr[e[t+3]]+"-"+Qr[e[t+4]]+Qr[e[t+5]]+"-"+Qr[e[t+6]]+Qr[e[t+7]]+"-"+Qr[e[t+8]]+Qr[e[t+9]]+"-"+Qr[e[t+10]]+Qr[e[t+11]]+Qr[e[t+12]]+Qr[e[t+13]]+Qr[e[t+14]]+Qr[e[t+15]]}(t)}class ni{proto;constructor(e){this.proto=e}static decode(e){const t=It.decode(e);return new ni(t)}encode(){return It.encode(this.proto)}get wakuMessage(){return this.proto.wakuMessage}get pubsubTopic(){return this.proto.pubsubTopic}}class ri{proto;constructor(e){this.proto=e}static createSubscribeRequest(e,t){return new ri({requestId:ti(),filterSubscribeType:Ct.FilterSubscribeType.SUBSCRIBE,pubsubTopic:e,contentTopics:t})}static createUnsubscribeRequest(e,t){return new ri({requestId:ti(),filterSubscribeType:Ct.FilterSubscribeType.UNSUBSCRIBE,pubsubTopic:e,contentTopics:t})}static createUnsubscribeAllRequest(e){return new ri({requestId:ti(),filterSubscribeType:Ct.FilterSubscribeType.UNSUBSCRIBE_ALL,pubsubTopic:e,contentTopics:[]})}static createSubscriberPingRequest(){return new ri({requestId:ti(),filterSubscribeType:Ct.FilterSubscribeType.SUBSCRIBER_PING,pubsubTopic:"",contentTopics:[]})}static decode(e){const t=Ct.decode(e);return new ri(t)}encode(){return Ct.encode(this.proto)}get filterSubscribeType(){return this.proto.filterSubscribeType}get requestId(){return this.proto.requestId}get pubsubTopic(){return this.proto.pubsubTopic}get contentTopics(){return this.proto.contentTopics}}class ii{proto;constructor(e){this.proto=e}static decode(e){const t=Tt.decode(e);return new ii(t)}encode(){return Tt.encode(this.proto)}get statusCode(){return this.proto.statusCode}get statusDesc(){return this.proto.statusDesc}get requestId(){return this.proto.requestId}}const si=new ir("filter:v2"),oi="/vac/waku/filter-subscribe/2.0.0-beta1",ai="/vac/waku/filter-push/2.0.0-beta1";class li extends Yr{handleIncomingMessage;pubsubTopics;constructor(e,t,n){super(oi,n.components,t),this.handleIncomingMessage=e,this.pubsubTopics=t,n.handle(ai,this.onRequest.bind(this),{maxInboundStreams:100}).catch(e=>{si.error("Failed to register ",ai,e)})}async subscribe(e,t,n){const r=await this.getStream(t),i=ri.createSubscribeRequest(e,n);let s;try{s=await Ur([i.encode()],xr,r,Tr,async e=>await dr(e))}catch(e){return si.error("Failed to send subscribe request",e),{success:null,failure:{error:En.GENERIC_FAIL,peerId:t}}}const{statusCode:o,requestId:a,statusDesc:l}=ii.decode(s[0].slice());return o<200||o>=300?(si.error(`Filter subscribe request ${a} failed with status code ${o}: ${l}`),{failure:{error:En.REMOTE_PEER_REJECTED,peerId:t},success:null}):{failure:null,success:t}}async unsubscribe(e,t,n){let r;try{r=await this.getStream(t)}catch(e){return si.error("Failed to get a stream for remote peer"+t.toString(),e),{success:null,failure:{error:En.NO_STREAM_AVAILABLE,peerId:t}}}const i=ri.createUnsubscribeRequest(e,n);try{await Ur([i.encode()],xr,r.sink)}catch(e){return si.error("Failed to send unsubscribe request",e),{success:null,failure:{error:En.GENERIC_FAIL,peerId:t}}}return{success:t,failure:null}}async unsubscribeAll(e,t){const n=await this.getStream(t),r=ri.createUnsubscribeAllRequest(e),i=await Ur([r.encode()],xr,n,Tr,async e=>await dr(e));if(!i||!i.length)return{failure:{error:En.NO_RESPONSE,peerId:t},success:null};const{statusCode:s,requestId:o,statusDesc:a}=ii.decode(i[0].slice());return s<200||s>=300?(si.error(`Filter unsubscribe all request ${o} failed with status code ${s}: ${a}`),{failure:{error:En.REMOTE_PEER_REJECTED,peerId:t},success:null}):{failure:null,success:t}}async ping(e){let t;try{t=await this.getStream(e)}catch(t){return si.error("Failed to get a stream for remote peer"+e.toString(),t),{success:null,failure:{error:En.NO_STREAM_AVAILABLE,peerId:e}}}const n=ri.createSubscriberPingRequest();let r;try{r=await Ur([n.encode()],xr,t,Tr,async e=>await dr(e))}catch(t){return si.error("Failed to send ping request",t),{success:null,failure:{error:En.GENERIC_FAIL,peerId:e}}}if(!r||!r.length)return{success:null,failure:{error:En.NO_RESPONSE,peerId:e}};const{statusCode:i,requestId:s,statusDesc:o}=ii.decode(r[0].slice());return i<200||i>=300?(si.error(`Filter ping request ${s} failed with status code ${i}: ${o}`),{success:null,failure:{error:En.REMOTE_PEER_REJECTED,peerId:e}}):{success:e,failure:null}}onRequest(e){const{connection:t,stream:n}=e,{remotePeer:r}=t;si.info("Received message from "+r.toString());try{Ur(n,Tr,async e=>{for await(const n of e){const e=ni.decode(n.slice()),{pubsubTopic:r,wakuMessage:i}=e;if(!i)return void si.error("Received empty message");if(!r)return void si.error("Pubsub topic missing from push message");await this.handleIncomingMessage(r,i,t.remotePeer.toString())}}).then(()=>{si.info("Receiving pipe closed.")},async e=>{si.error(`Error with receiving pipe on peer:${t.remotePeer.toString()} -- stream:${n.id} -- protocol:${n.protocol}: `,e)})}catch(e){si.error("Error decoding message",e)}}}class ci{proto;constructor(e){this.proto=e}static createRequest(e,t){return new ci({requestId:ti(),request:{message:e,pubsubTopic:t},response:void 0})}static decode(e){const t=kt.decode(e);return new ci(t)}encode(){return kt.encode(this.proto)}get query(){return this.proto.request}get response(){return this.proto.response}}const hi=new ir("light-push"),ui="/vac/waku/lightpush/2.0.0-beta1";class di extends Yr{pubsubTopics;constructor(e,t){super(ui,t.components,e),this.pubsubTopics=e}async preparePushMessage(e,t){try{if(!t.payload||0===t.payload.length)return hi.error("Failed to send waku light push: payload is empty"),{query:null,error:En.EMPTY_PAYLOAD};if(!await async function(e,t){const n=await e.toWire(t);return!!n&&sn(n)}(e,t))return hi.error("Failed to send waku light push: message is bigger than 1MB"),{query:null,error:En.SIZE_TOO_BIG};const n=await e.toProtoObj(t);if(!n)return hi.error("Failed to encode to protoMessage, aborting push"),{query:null,error:En.ENCODE_FAILED};return{query:ci.createRequest(n,e.pubsubTopic),error:null}}catch(e){return hi.error("Failed to prepare push message",e),{query:null,error:En.GENERIC_FAIL}}}async send(e,t,n){const{query:r,error:i}=await this.preparePushMessage(e,t);if(i||!r)return{success:null,failure:{error:i,peerId:n}};let s,o;try{s=await this.getStream(n)}catch(e){return hi.error("Failed to get stream",e),{success:null,failure:{error:En.NO_STREAM_AVAILABLE,peerId:n}}}try{o=await Ur([r.encode()],xr,s,Tr,async e=>await dr(e))}catch(e){return hi.error("Failed to send waku light push request",e),{success:null,failure:{error:En.STREAM_ABORTED,peerId:n}}}const a=new br;let l;o.forEach(e=>{a.append(e)});try{l=ci.decode(a).response}catch(e){return hi.error("Failed to decode push reply",e),{success:null,failure:{error:En.DECODE_FAILED,peerId:n}}}return l?(c=l.info)&&(c.includes("could not generate rln proof")||c.includes("could not get new message id to generate an rln proof")||c.includes("RLN validation failed"))?(hi.error("Remote peer fault: RLN generation"),{success:null,failure:{error:En.RLN_PROOF_GENERATION,peerId:n}}):l.isSuccess?{success:n,failure:null}:(hi.error("Remote peer rejected the message: ",l.info),{success:null,failure:{error:En.REMOTE_PEER_REJECTED,peerId:n}}):(hi.error("Remote peer fault: No response in PushRPC"),{success:null,failure:{error:En.NO_RESPONSE,peerId:n}});var c}}const pi={payload:new Uint8Array,contentTopic:"",version:void 0,timestamp:void 0,meta:void 0,rateLimitProof:void 0,ephemeral:void 0};const fi=1e6;class mi{proto;constructor(e){this.proto=e}static create(e){const t=new mi({...e,requestId:ti(),timeStart:e.timeStart?BigInt(e.timeStart.getTime()*fi):void 0,timeEnd:e.timeEnd?BigInt(e.timeEnd.getTime()*fi):void 0,messageHashes:e.messageHashes||[],paginationLimit:e.paginationLimit?BigInt(e.paginationLimit):void 0});if(e.pubsubTopic&&!e.contentTopics||!e.pubsubTopic&&e.contentTopics)throw Error("Both pubsubTopic and contentTopics must be set or unset");if(e.messageHashes&&(e.pubsubTopic||e.contentTopics||e.timeStart||e.timeEnd))throw Error("Message hash lookup queries cannot include content filter criteria");return t}static decode(e){const t=Bt.decode(e);return new mi(t)}encode(){return Bt.encode(this.proto)}}class gi{proto;constructor(e){this.proto=e}static decode(e){const t=zt.decode(e);return new gi(t)}encode(){return zt.encode(this.proto)}get statusCode(){return this.proto.statusCode}get statusDesc(){return this.proto.statusDesc}get messages(){return this.proto.messages}get paginationCursor(){return this.proto.paginationCursor}}const yi=new ir("store"),bi="/vac/waku/store-query/3.0.0";class vi extends Yr{pubsubTopics;constructor(e,t){super(bi,t.components,e),this.pubsubTopics=e}async*queryPerPage(e,t,n){if(e.contentTopics.toString()!==Array.from(t.keys()).toString())throw Error("Internal error, the decoders should match the query's content topics");let r=e.paginationCursor;for(;;){const i=mi.create({...e,paginationCursor:r});let s;try{s=await this.getStream(n)}catch(e){yi.error("Failed to get stream",e);break}const o=await Ur([i.encode()],xr,s,Tr,async e=>await dr(e)),a=new br;o.forEach(e=>{a.append(e)});const l=gi.decode(a);if(!l.statusCode||l.statusCode>=300){const e=`Store query failed with status code: ${l.statusCode}, description: ${l.statusDesc}`;throw yi.error(e),Error(e)}if(!l.messages||!l.messages.length){yi.warn("Stopping pagination due to empty messages in response");break}yi.info(l.messages.length+" messages retrieved from store");const c=l.messages.map(e=>{if(!e.message)return Promise.resolve(void 0);const n=e.message.contentTopic;if(n){const i=t.get(n);if(i)return i.fromProtoObj(e.pubsubTopic||"",(r=e.message,{...pi,...r}))}var r;return Promise.resolve(void 0)});if(yield c,r=e.paginationForward?l.messages[l.messages.length-1].messageHash:l.messages[0].messageHash,l.messages.length>100&&l.messages.length<(e.paginationLimit||20))break}}}const wi=Symbol.for("@libp2p/connection"),xi=Symbol.for("@libp2p/content-routing"),_i=Symbol.for("@libp2p/peer-discovery"),Ei=Symbol.for("@libp2p/peer-id");function Si(e){return!!e?.[Ei]}const Mi=Symbol.for("@libp2p/peer-routing"),Ai="keep-alive";var Ci;(e=>{e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(Ci||(Ci={}));let Ti=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},Ii=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class Li extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class Pi extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}let Ri=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class Di extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let ki=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},Ni=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class Fi extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Oi extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Bi extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class zi extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}let Ui=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}};class Hi extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return null==t?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let r=this.#e.get(e);null==r&&(r=[],this.#e.set(e,r)),r.push({callback:t,once:(!0!==n&&!1!==n&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let r=this.#e.get(e);null!=r&&(r=r.filter(({callback:e})=>e!==t),this.#e.set(e,r))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return null==n||(n=n.filter(({once:e})=>!e),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function qi(e){return null!=e&&"function"==typeof e.start&&"function"==typeof e.stop}const Vi=Symbol.for("@libp2p/service-capabilities"),Gi=Symbol.for("@libp2p/service-dependencies");class Wi extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class ji extends Error{static name="ValidationError";name="ValidationError"}let $i=class extends Error{static name="InvalidParametersError";name="InvalidParametersError"};class Ki extends Error{static name="UnknownProtocolError";name="UnknownProtocolError"}const Xi=new class{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return void 0===n&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&void 0===this.readGivenChar(e)))return n()})}readNumber(e,t,n,r){return this.readAtomically(()=>{let i=0,s=0;const o=this.peekChar();if(void 0===o)return;const a="0"===o,l=2**(8*r)-1;for(;;){const n=this.readAtomically(()=>{const t=this.readChar();if(void 0===t)return;const n=Number.parseInt(t,e);return Number.isNaN(n)?void 0:n});if(void 0===n)break;if(i*=e,i+=n,i>l)return;if(s+=1,void 0!==t&&s>t)return}return 0===s||!n&&a&&s>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(void 0===n)return;e[t]=n}return e})}readIPv6Addr(){const e=e=>{for(let t=0;t<e.length/2;t++){const n=2*t;if(t<e.length-3){const r=this.readSeparator(":",t,()=>this.readIPv4Addr());if(void 0!==r)return e[n]=r[0],e[n+1]=r[1],e[n+2]=r[2],e[n+3]=r[3],[n+4,!0]}const r=this.readSeparator(":",t,()=>this.readNumber(16,4,!0,2));if(void 0===r)return[n,!1];e[n]=r>>8,e[n+1]=255&r}return[e.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,r]=e(t);if(16===n)return t;if(r)return;if(void 0===this.readGivenChar(":"))return;if(void 0===this.readGivenChar(":"))return;const i=new Uint8Array(14),s=16-(n+2),[o]=e(i.subarray(0,s));return t.set(i.subarray(0,o),16-o),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};function Yi(e){if(!(e.length>15))return Xi.new(e).parseWith(()=>Xi.readIPv4Addr())}function Zi(e){if(e.includes("%")&&(e=e.split("%")[0]),!(e.length>45))return Xi.new(e).parseWith(()=>Xi.readIPv6Addr())}function Ji(e,t=!1){if(e.includes("%")&&(e=e.split("%")[0]),e.length>45)return;const n=Xi.new(e).parseWith(()=>Xi.readIPAddr());return n?t&&4===n.length?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,n[0],n[1],n[2],n[3]]):n:void 0}function Qi(e){return!!Yi(e)}function es(e){return!!Zi(e)}const ts=273,ns=41,rs=421,is=448,ss=466,os=480,as=281,ls=290;function cs(e){return t=>Pn(t,e)}function hs(e){return t=>rt(t,e)}function us(e){return new DataView(e.buffer).getUint16(e.byteOffset).toString()}function ds(e){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,"string"==typeof e?parseInt(e):e),new Uint8Array(t)}function ps(e){const t=e.subarray(0,e.length-2),n=e.subarray(e.length-2);return`${Pn(t,"base32")}:${us(n)}`}const fs=e=>{e=e.toString().trim();const t=new Uint8Array(4);return e.split(/\./g).forEach((e,n)=>{const r=parseInt(e,10);if(isNaN(r)||r<0||r>255)throw new Wi("Invalid byte value in IP address");t[n]=r}),t};const ms=Object.values(Je).map(e=>e.decoder),gs=(()=>{let e=ms[0].or(ms[1]);return ms.slice(2).forEach(t=>e=e.or(t)),e})();const ys=function(...e){return t=>{for(const n of e)n(t)}}(function(e){if(parseInt(e).toString()!==e)throw new ji("Value must be an integer")},function(e){if(e<0)throw new ji("Value must be a positive integer, or zero")},(bs=65535,e=>{if(e>bs)throw new ji("Value must be smaller than or equal to "+bs)}));var bs;const vs=-1;const ws=new class{protocolsByCode=new Map;protocolsByName=new Map;getProtocol(e){let t;if(t="string"==typeof e?this.protocolsByName.get(e):this.protocolsByCode.get(e),null==t)throw new Ki(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach(t=>{this.protocolsByName.set(t,e)})}removeProtocol(e){const t=this.protocolsByCode.get(e);null!=t&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(e=>{this.protocolsByName.delete(e)}))}},xs=[{code:4,name:"ip4",size:32,valueToBytes:fs,bytesToValue(e){if(4!==e.byteLength)throw new Wi("IPv4 address was incorrect length");const t=[];for(let n=0;n<e.byteLength;n++)t.push(e[n]);return t.join(".")},validate(e){if(!Qi(e))throw new ji(`Invalid IPv4 address "${e}"`)}},{code:6,name:"tcp",size:16,valueToBytes:ds,bytesToValue:us,validate:ys},{code:ts,name:"udp",size:16,valueToBytes:ds,bytesToValue:us,validate:ys},{code:33,name:"dccp",size:16,valueToBytes:ds,bytesToValue:us,validate:ys},{code:ns,name:"ip6",size:128,valueToBytes(e){let t=0;const n=(e=e.toString().trim()).split(":",8);let r;for(r=0;r<n.length;r++){let e;Qi(n[r])&&(e=fs(n[r]),n[r]=Pn(e.subarray(0,2),"base16")),null!=e&&++r<8&&n.splice(r,0,Pn(e.subarray(2,4),"base16"))}if(""===n[0])for(;n.length<8;)n.unshift("0");else if(""===n[n.length-1])for(;n.length<8;)n.push("0");else if(n.length<8){for(r=0;r<n.length&&""!==n[r];r++);const e=[r,1];for(r=9-n.length;r>0;r--)e.push("0");n.splice.apply(n,e)}const i=new Uint8Array(t+16);for(r=0;r<n.length;r++){""===n[r]&&(n[r]="0");const e=parseInt(n[r],16);if(isNaN(e)||e<0||e>65535)throw new Wi("Invalid byte value in IP address");i[t++]=e>>8&255,i[t++]=255&e}return i},bytesToValue(e){if(16!==e.byteLength)throw new Wi("IPv6 address was incorrect length");const t=[];for(let n=0;n<e.byteLength;n+=2){const r=e[n],i=e[n+1],s=`${r.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;t.push(s)}const n=t.join(":");try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Wi(`Invalid IPv6 address "${n}"`)}},stringToValue(e){try{const t=new URL(`http://[${e}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new Wi(`Invalid IPv6 address "${e}"`)}},validate(e){if(!es(e))throw new ji(`Invalid IPv6 address "${e}"`)}},{code:42,name:"ip6zone",size:vs},{code:43,name:"ipcidr",size:8,bytesToValue:cs("base10"),valueToBytes:hs("base10")},{code:53,name:"dns",size:vs,resolvable:!0},{code:54,name:"dns4",size:vs,resolvable:!0},{code:55,name:"dns6",size:vs,resolvable:!0},{code:56,name:"dnsaddr",size:vs,resolvable:!0},{code:132,name:"sctp",size:16,valueToBytes:ds,bytesToValue:us,validate:ys},{code:301,name:"udt"},{code:302,name:"utp"},{code:400,name:"unix",size:vs,path:!0,stringToValue(e){return decodeURIComponent(e)},valueToString(e){return encodeURIComponent(e)}},{code:rs,name:"p2p",aliases:["ipfs"],size:vs,bytesToValue:cs("base58btc"),valueToBytes(e){return e.startsWith("Q")||e.startsWith("1")?hs("base58btc")(e):$e.parse(e).multihash.bytes}},{code:444,name:"onion",size:96,bytesToValue:ps,valueToBytes(e){const t=e.split(":");if(2!==t.length)throw Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(16!==t[0].length)throw Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const n=rt(t[0],"base32"),r=parseInt(t[1],10);if(r<1||r>65536)throw Error("Port number is not in range(1, 65536)");const i=ds(r);return pr([n,i],n.length+i.length)}},{code:445,name:"onion3",size:296,bytesToValue:ps,valueToBytes(e){const t=e.split(":");if(2!==t.length)throw Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(56!==t[0].length)throw Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const n=J.decode("b"+t[0]),r=parseInt(t[1],10);if(r<1||r>65536)throw Error("Port number is not in range(1, 65536)");const i=ds(r);return pr([n,i],n.length+i.length)}},{code:446,name:"garlic64",size:vs},{code:447,name:"garlic32",size:vs},{code:is,name:"tls"},{code:449,name:"sni",size:vs},{code:454,name:"noise"},{code:460,name:"quic"},{code:461,name:"quic-v1"},{code:465,name:"webtransport"},{code:ss,name:"certhash",size:vs,bytesToValue:function(e){return t=>e.encoder.encode(t)}(ge),valueToBytes(e){return gs.decode(e)}},{code:os,name:"http"},{code:481,name:"http-path",size:vs,stringToValue(e){return"/"+decodeURIComponent(e)},valueToString(e){return encodeURIComponent(e.substring(1))}},{code:443,name:"https"},{code:477,name:"ws"},{code:478,name:"wss"},{code:479,name:"p2p-websocket-star"},{code:277,name:"p2p-stardust"},{code:275,name:"p2p-webrtc-star"},{code:276,name:"p2p-webrtc-direct"},{code:280,name:"webrtc-direct"},{code:as,name:"webrtc"},{code:ls,name:"p2p-circuit"},{code:777,name:"memory",size:vs}];function _s(e,t,n){return null==e.size||0===e.size?0:e.size>0?e.size/8:d(t,n)}xs.forEach(e=>{ws.addProtocol(e)});const Es=Symbol.for("nodejs.util.inspect.custom"),Ss=Symbol.for("@multiformats/multiaddr"),Ms=[53,54,55,56];class As extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function Cs(e){if(null==e&&(e="/"),zs(e))return e.getComponents();if(e instanceof Uint8Array)return function(e){const t=[];let n=0;for(;n<e.length;){const r=d(e,n),i=ws.getProtocol(r),s=l(r),o=_s(i,e,n+s);let a=0;o>0&&i.size===vs&&(a=l(o));const c=s+a+o,h={code:r,name:i.name,bytes:e.subarray(n,n+c)};if(o>0){const t=n+s+a,r=e.subarray(t,t+o);h.value=i.bytesToValue?.(r)??Pn(r)}t.push(h),n+=c}return t}(e);if("string"==typeof e)return""===(e=e.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""))&&(e="/"),function(e){if("/"!==e.charAt(0))throw new Wi('String multiaddr must start with "/"');const t=[];let n="protocol",r="",i="";for(let s=1;s<e.length;s++){const o=e.charAt(s);"/"!==o&&("protocol"===n?i+=e.charAt(s):r+=e.charAt(s));const a=s===e.length-1;if("/"===o||a){const e=ws.getProtocol(i);if("protocol"===n){if(null==e.size||0===e.size){t.push({code:e.code,name:e.name}),r="",i="",n="protocol";continue}if(a)throw new Wi(`Component ${i} was missing value`);n="value"}else if("value"===n){const s={code:e.code,name:e.name};if(null!=e.size&&0!==e.size){if(""===r)throw new Wi(`Component ${i} was missing value`);s.value=e.stringToValue?.(r)??r}t.push(s),r="",i="",n="protocol"}}}if(""!==i&&""!==r)throw new Wi("Incomplete multiaddr");return t}(e);if(Array.isArray(e))return e;throw new Wi("Must be a string, Uint8Array, Component[], or another Multiaddr")}class Ts{[Ss]=!0;#t;#n;#r;constructor(e="/",t={}){this.#t=Cs(e),!1!==t.validate&&function(e){e.getComponents().forEach(e=>{const t=ws.getProtocol(e.code);null!=e.value&&t.validate?.(e.value)})}(this)}get bytes(){return null==this.#r&&(this.#r=function(e){let t=0;const n=[];for(const r of e){if(null==r.bytes){const e=ws.getProtocol(r.code),t=l(r.code);let n,i=0,s=0;null!=r.value&&(n=e.valueToBytes?.(r.value)??rt(r.value),i=n.byteLength,e.size===vs&&(s=l(i)));const o=new Uint8Array(t+s+i);let a=0;c(r.code,o,a),a+=t,null!=n&&(e.size===vs&&(c(i,o,a),a+=s),o.set(n,a)),r.bytes=o}n.push(r.bytes),t+=r.bytes.byteLength}return pr(n,t)}(this.#t)),this.#r}toString(){return null==this.#n&&(this.#n="/"+this.#t.flatMap(e=>{if(null==e.value)return e.name;const t=ws.getProtocol(e.code);if(null==t)throw new Wi("Unknown protocol code "+e.code);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")),this.#n}toJSON(){return this.toString()}toOptions(){let e,t,n,r,i="";for(const{code:s,name:o,value:a}of this.#t)42===s&&(i="%"+(a??"")),Ms.includes(s)&&(t="tcp",r=443,n=`${a??""}${i}`,e=55===s?6:4),6!==s&&s!==ts||(t="tcp"===o?"tcp":"udp",r=parseInt(a??"")),4!==s&&s!==ns||(t="tcp",n=`${a??""}${i}`,e=s===ns?6:4);if(null==e||null==t||null==n||null==r)throw Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:r}}getComponents(){return[...this.#t]}protos(){return this.#t.map(({code:e,value:t})=>{const n=ws.getProtocol(e);return{code:e,size:n.size??0,name:n.name,resolvable:!!n.resolvable,path:!!n.path}})}protoCodes(){return this.#t.map(({code:e})=>e)}protoNames(){return this.#t.map(({name:e})=>e)}tuples(){return this.#t.map(({code:e,value:t})=>{if(null==t)return[e];const n=ws.getProtocol(e),r=[e];return null!=t&&r.push(n.valueToBytes?.(t)??rt(t)),r})}stringTuples(){return this.#t.map(({code:e,value:t})=>null==t?[e]:[e,t])}encapsulate(e){const t=new Ts(e);return new Ts([...this.#t,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),r=n.lastIndexOf(t);if(r<0)throw new $i(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new Ts(n.slice(0,r),{validate:!1})}decapsulateCode(e){let t;for(let n=this.#t.length-1;n>-1;n--)if(this.#t[n].code===e){t=n;break}return new Ts(this.#t.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#t.forEach(({code:t,value:n})=>{t===rs&&e.push([t,n]),t===ls&&(e=[])});const t=e.pop();if(null!=t?.[1]){const e=t[1];return"Q"===e[0]||"1"===e[0]?Pn(ue.decode("z"+e),"base58btc"):Pn($e.parse(e).multihash.bytes,"base58btc")}return null}catch(e){return null}}getPath(){for(const e of this.#t){if(ws.getProtocol(e.code).path)return e.value??null}return null}equals(e){return fr(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(e=>e.resolvable);if(null==t)return[this];const n=Bs.get(t.name);if(null==n)throw new As("no available resolver for "+t.name);return(await n(this,e)).map(e=>Us(e))}nodeAddress(){const e=this.toOptions();if("tcp"!==e.transport&&"udp"!==e.transport)throw Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return 2===this.#t.length&&((4===this.#t[0].code||this.#t[0].code===ns)&&(6===this.#t[1].code||this.#t[1].code===ts))}[Es](){return`Multiaddr(${this.toString()})`}}const Is=4,Ls=16,Ps=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Rs(e,t){t.length===Ls&&e.length===Is&&function(e,t,n){let r=0;for(const i of e)if(!(r<t)){if(r>n)break;if(255!==i)return!1;r++}return!0}(t,0,11)&&(t=t.slice(12)),t.length===Is&&e.length===Ls&&function(e,t,n,r){let i=0;for(const s of e)if(!(i<n)){if(i>r)break;if(s!==t[i])return!1;i++}return!0}(e,Ps,0,11)&&(e=e.slice(12));const n=e.length;if(n!=t.length)throw Error("Failed to mask ip");const r=new Uint8Array(n);for(let i=0;i<n;i++)r[i]=e[i]&t[i];return r}function Ds(e,t){if(t!==8*Is&&t!==8*Ls)throw Error("Invalid CIDR mask");if(e<0||e>t)throw Error("Invalid CIDR mask");const n=t/8,r=new Uint8Array(n);for(let t=0;t<n;t++)e>=8?(r[t]=255,e-=8):(r[t]=255-(255>>e),e=0);return r}class ks{constructor(e,t){if(null==t)({network:this.network,mask:this.mask}=function(e){const[t,n]=e.split("/");if(!t||!n)throw Error("Failed to parse given CIDR: "+e);let r=Is,i=Yi(t);if(null==i&&(r=Ls,i=Zi(t),null==i))throw Error("Failed to parse given CIDR: "+e);const s=parseInt(n,10);if(Number.isNaN(s)||(s+"").length!==n.length||s<0||s>8*r)throw Error("Failed to parse given CIDR: "+e);const o=Ds(s,8*r);return{network:Rs(i,o),mask:o}}(e));else{const n=Ji(e);if(null==n)throw Error("Failed to parse network");const r=parseInt(t+="",10);if(Number.isNaN(r)||(r+"").length!==t.length||r<0||r>8*n.length){const e=Ji(t);if(null==e)throw Error("Failed to parse mask");this.mask=e}else this.mask=Ds(r,8*n.length);this.network=Rs(n,this.mask)}}contains(e){return function(e,t){if("string"==typeof t&&(t=Ji(t)),null==t)throw Error("Invalid ip");if(t.length!==e.network.length)return!1;for(let n=0;n<t.length;n++)if((e.network[n]&e.mask[n])!==(t[n]&e.mask[n]))return!1;return!0}({network:this.network,mask:this.mask},e)}toString(){const e=function(e){let t=0;for(let[n,r]of e.entries()){if(255!==r){for(;128&r;)t++,r<<=1;if(128&r)return-1;for(let t=n+1;t<e.length;t++)if(0!=e[t])return-1;break}t+=8}return t}(this.mask),t=-1!==e?e+"":function(e){let t="0x";for(const n of e)t+=(n>>4).toString(16)+(15&n).toString(16);return t}(this.mask);return function(e){switch(e.length){case Is:return e.join(".");case Ls:{const t=[];for(let n=0;n<e.length;n++)n%2==0&&t.push(e[n].toString(16).padStart(2,"0")+e[n+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw Error("Invalid ip length")}}(this.network)+"/"+t}}function Ns(e,t){return new ks(e).contains(t)}function Fs(e,t){const n=ws.getProtocol(e);return n.bytesToValue?.(t)??Pn(t,"base16")}function Os(e,t){const n=ws.getProtocol(e);return n.valueToBytes?.(t)??rt(t,"base16")}const Bs=new Map;function zs(e){return!!e?.[Ss]}function Us(e){return new Ts(e)}const Hs=new ir("keep-alive");class qs{relay;libp2p;options;pingKeepAliveTimers=new Map;relayKeepAliveTimers=new Map;constructor({options:e,relay:t,libp2p:n}){this.options=e,this.relay=t,this.libp2p=n}start(e){this.stop(e);const{pingKeepAlive:t,relayKeepAlive:n}=this.options,r=e.toString();if(0!==t){const n=setInterval(()=>{(async()=>{let n;try{try{n=await this.libp2p.services.ping.ping(e),Hs.info(`Ping succeeded (${r})`,n)}catch(e){return void Hs.error(`Ping failed for peer (${r}).\n                Next ping will be attempted in ${t} seconds.\n              `)}try{await this.libp2p.peerStore.merge(e,{metadata:{ping:Nn(n.toString())}})}catch(e){Hs.error("Failed to update ping",e)}}catch(e){Hs.error(`Ping failed (${r})`,e)}})()},1e3*t);this.pingKeepAliveTimers.set(r,n)}const i=this.relay;if(i&&0!==n){const t=this.scheduleRelayPings(i,n,e.toString());this.relayKeepAliveTimers.set(e,t)}}stop(e){const t=e.toString();this.pingKeepAliveTimers.has(t)&&(clearInterval(this.pingKeepAliveTimers.get(t)),this.pingKeepAliveTimers.delete(t)),this.relayKeepAliveTimers.has(e)&&(this.relayKeepAliveTimers.get(e)?.map(clearInterval),this.relayKeepAliveTimers.delete(e))}stopAll(){for(const e of[...Object.values(this.pingKeepAliveTimers),...Object.values(this.relayKeepAliveTimers)])clearInterval(e);this.pingKeepAliveTimers.clear(),this.relayKeepAliveTimers.clear()}connectionsExist(){return this.pingKeepAliveTimers.size>0||this.relayKeepAliveTimers.size>0}scheduleRelayPings(e,t,n){const r=[];for(const i of e.pubsubTopics){if(!e.getMeshPeers(i).includes(n))continue;const s=cr({pubsubTopicShardInfo:Bn(i),contentTopic:"/relay-ping/1/ping/null",ephemeral:!0}),o=setInterval(()=>{Hs.info("Sending Waku Relay ping message"),e.send(s,{payload:new Uint8Array([1])}).catch(e=>Hs.error("Failed to send relay ping",e))},1e3*t);r.push(o)}return r}}const Vs=e=>{if(!e)return-1;try{const t=e.metadata.get("ping");return t?Number(kn(t)):-1}catch(e){return-1}},Gs=new ir("connection-manager");class Ws extends Hi{pubsubTopics;keepAliveManager;options;libp2p;dialAttemptsForPeer=new Map;dialErrorsForPeer=new Map;currentActiveParallelDialCount=0;pendingPeerDialQueue=[];isP2PNetworkConnected=!1;isConnected(){return!(globalThis?.navigator&&!globalThis?.navigator?.onLine)&&this.isP2PNetworkConnected}stop(){this.keepAliveManager.stopAll(),this.libp2p.removeEventListener("peer:connect",this.onEventHandlers["peer:connect"]),this.libp2p.removeEventListener("peer:disconnect",this.onEventHandlers["peer:disconnect"]),this.libp2p.removeEventListener("peer:discovery",this.onEventHandlers["peer:discovery"]),this.stopNetworkStatusListener()}async dropConnection(e){try{this.keepAliveManager.stop(e),await this.libp2p.hangUp(e),Gs.info("Dropped connection with peer "+e.toString())}catch(t){Gs.error(`Error dropping connection with peer ${e.toString()} - ${t}`)}}async getPeersByDiscovery(){const e=await this.libp2p.peerStore.all(),t=this.libp2p.getConnections().map(e=>e.remotePeer),n=[],r=[],i=[],s=[],o=[],a=[];for(const t of e){const e=await this.getTagNamesForPeer(t.id);e.includes(Sn.BOOTSTRAP)?n.push(t):e.includes(Sn.PEER_EXCHANGE)?r.push(t):e.includes(Sn.LOCAL)&&i.push(t)}for(const e of t){const t=await this.libp2p.peerStore.get(e),n=await this.getTagNamesForPeer(e);n.includes(Sn.BOOTSTRAP)?s.push(t):n.includes(Sn.PEER_EXCHANGE)?o.push(t):n.includes(Sn.LOCAL)&&a.push(t)}return{DISCOVERED:{[Sn.BOOTSTRAP]:n,[Sn.PEER_EXCHANGE]:r,[Sn.LOCAL]:i},CONNECTED:{[Sn.BOOTSTRAP]:s,[Sn.PEER_EXCHANGE]:o,[Sn.LOCAL]:a}}}constructor(e){super(),this.libp2p=e.libp2p,this.pubsubTopics=e.pubsubTopics,this.options={maxDialAttemptsForPeer:3,maxBootstrapPeersAllowed:1,maxParallelDials:3,pingKeepAlive:300,relayKeepAlive:300,...e.config},this.keepAliveManager=new qs({relay:e.relay,libp2p:e.libp2p,options:{pingKeepAlive:this.options.pingKeepAlive,relayKeepAlive:this.options.relayKeepAlive}}),this.startEventListeners().then(()=>Gs.info("Connection Manager is now running")).catch(e=>Gs.error("Unexpected error while running service",e)),this.dialPeerStorePeers().catch(e=>Gs.error("Unexpected error while dialing peer store peers",e))}async getConnectedPeers(e){const t=this.libp2p.getPeers();if(0===t.length)return[];return(await Promise.all(t.map(async e=>{try{return await this.libp2p.peerStore.get(e)}catch(e){return null}}))).filter(e=>!!e).filter(t=>!e||t.protocols.includes(e)).sort((e,t)=>Vs(e)-Vs(t))}async dialPeerStorePeers(){const e=await this.libp2p.peerStore.all(),t=[];for(const n of e)this.libp2p.getConnections().find(e=>e.remotePeer===n.id)||t.push(this.attemptDial(n.id));try{await Promise.all(t)}catch(e){Gs.error("Unexpected error while dialing peer store peers",e)}}async startEventListeners(){this.startPeerDiscoveryListener(),this.startPeerConnectionListener(),this.startPeerDisconnectionListener(),this.startNetworkStatusListener()}async dialPeer(e){let t,n;const r=this.getDialablePeerInfo(e),i=Si(r)?r.toString():r.getPeerId();this.currentActiveParallelDialCount+=1;let s=0;for(;s<this.options.maxDialAttemptsForPeer;)try{Gs.info(`Dialing peer ${r} on attempt ${s+1}`),t=await this.libp2p.dial(r),n=t.remotePeer;const e=await this.getTagNamesForPeer(n);this.libp2p.getConnections(n).forEach(t=>{t.tags=Array.from(new Set([...t.tags,...e]))}),this.dialAttemptsForPeer.set(n.toString(),-1),this.keepAliveManager.start(n);break}catch(e){e instanceof AggregateError?Gs.error(`Error dialing peer ${i} - ${e.errors}`):Gs.error(`Error dialing peer ${i} - ${e.message}`),this.dialErrorsForPeer.set(i,e),s++,this.dialAttemptsForPeer.set(i,s)}if(this.currentActiveParallelDialCount--,this.processDialQueue(),s===this.options.maxDialAttemptsForPeer)try{const e=this.dialErrorsForPeer.get(i);if(e){let t;e instanceof AggregateError?e.errors?0===e.errors.length?Gs.warn("Errors array is empty for AggregateError"):t=JSON.stringify(e.errors[0]):Gs.warn("No errors array found for AggregateError"):t=e.message,Gs.info(`Deleting undialable peer ${i} from peer store. Reason: ${t}`)}this.dialErrorsForPeer.delete(i),n&&await this.libp2p.peerStore.delete(n),await this.attemptDnsDiscovery()}catch(e){throw Error(`Error deleting undialable peer ${i} from peer store - ${e}`)}if(!t)throw Error("Failed to dial peer "+r);return t}async rawDialPeerWithProtocols(e,t){const n=this.getDialablePeerInfo(e);return await this.libp2p.dialProtocol(n,t)}getDialablePeerInfo(e){if(Si(e))return e;{const t=Us(e);if(!t.getPeerId())throw Error("Failed to dial multiaddr: missing peer ID");return t}}async attemptDnsDiscovery(){if(this.libp2p.getConnections().length>0)return;if((await this.libp2p.peerStore.all()).length>0)return;Gs.info("Attempting to trigger DNS discovery.");const e=Object.values(this.libp2p.components.components).find(e=>!(!e||!e.toString)&&e.toString().includes(Cn));e&&await e.findPeers()}processDialQueue(){if(this.pendingPeerDialQueue.length>0&&this.currentActiveParallelDialCount<this.options.maxParallelDials){const e=this.pendingPeerDialQueue.shift();if(!e)return;this.attemptDial(e).catch(e=>{Gs.error(e)})}}startPeerDiscoveryListener(){this.libp2p.addEventListener("peer:discovery",this.onEventHandlers["peer:discovery"])}startPeerConnectionListener(){this.libp2p.addEventListener("peer:connect",this.onEventHandlers["peer:connect"])}startPeerDisconnectionListener(){this.libp2p.addEventListener("peer:disconnect",this.onEventHandlers["peer:disconnect"])}async attemptDial(e){await this.shouldDialPeer(e)&&(this.currentActiveParallelDialCount>=this.options.maxParallelDials?this.pendingPeerDialQueue.push(e):await this.dialPeer(e))}onEventHandlers={"peer:discovery":e=>{(async()=>{const{id:t}=e.detail;await this.dispatchDiscoveryEvent(t);try{await this.attemptDial(t)}catch(e){Gs.error(`Error dialing peer ${t.toString()} : ${e}`)}})()},"peer:connect":e=>{(async()=>{Gs.info("Connected to peer "+e.detail.toString());const t=e.detail;this.keepAliveManager.start(t);if((await this.getTagNamesForPeer(t)).includes(Sn.BOOTSTRAP)){this.libp2p.getConnections().filter(e=>e.tags.includes(Sn.BOOTSTRAP)).length>this.options.maxBootstrapPeersAllowed?await this.dropConnection(t):this.dispatchEvent(new CustomEvent(Mn.PEER_CONNECT_BOOTSTRAP,{detail:t}))}else this.dispatchEvent(new CustomEvent(Mn.PEER_CONNECT_PEER_EXCHANGE,{detail:t}));this.setP2PNetworkConnected()})()},"peer:disconnect":e=>{(async()=>{this.keepAliveManager.stop(e.detail),this.setP2PNetworkDisconnected()})()},"browser:network":()=>{this.dispatchWakuConnectionEvent()}};async shouldDialPeer(e){if(this.libp2p.getConnections(e).length>0)return Gs.warn(`Already connected to peer ${e.toString()}. Not dialing.`),!1;if(!await this.isPeerTopicConfigured(e)){const t=await this.getPeerShardInfo(e,this.libp2p.peerStore);return Gs.warn(`Discovered peer ${e.toString()} with ShardInfo ${t} is not part of any of the configured pubsub topics (${this.pubsubTopics}).\n            Not dialing.`),!1}if(!await this.isPeerDialableBasedOnBootstrapStatus(e))return Gs.warn(`Peer ${e.toString()} is not dialable based on bootstrap status. Not dialing.`),!1;return!this.dialAttemptsForPeer.has(e.toString())||(Gs.warn(`Peer ${e.toString()} has already been attempted dial before, or already has a dial attempt in progress, skipping dial`),!1)}async isPeerDialableBasedOnBootstrapStatus(e){if(!(await this.getTagNamesForPeer(e)).some(e=>e===Sn.BOOTSTRAP))return!0;const t=this.libp2p.getConnections().filter(e=>e.tags.find(e=>e===Sn.BOOTSTRAP)).length;return t<this.options.maxBootstrapPeersAllowed}async dispatchDiscoveryEvent(e){const t=(await this.getTagNamesForPeer(e)).includes(Sn.BOOTSTRAP);this.dispatchEvent(new CustomEvent(t?Mn.PEER_DISCOVERY_BOOTSTRAP:Mn.PEER_DISCOVERY_PEER_EXCHANGE,{detail:e}))}async getTagNamesForPeer(e){try{const t=await this.libp2p.peerStore.get(e);return Array.from(t.tags.keys())}catch(t){return Gs.error(`Failed to get peer ${e}, error: ${t}`),[]}}async isPeerTopicConfigured(e){const t=await this.getPeerShardInfo(e,this.libp2p.peerStore);if(!t)return!0;return On(t).some(e=>this.pubsubTopics.includes(e))}async getPeerShardInfo(e,t){const n=(await t.get(e)).metadata.get("shardInfo");if(n)return Gn(n)}startNetworkStatusListener(){try{globalThis.addEventListener("online",this.onEventHandlers["browser:network"]),globalThis.addEventListener("offline",this.onEventHandlers["browser:network"])}catch(e){Gs.error("Failed to start network listener: "+e)}}stopNetworkStatusListener(){try{globalThis.removeEventListener("online",this.onEventHandlers["browser:network"]),globalThis.removeEventListener("offline",this.onEventHandlers["browser:network"])}catch(e){Gs.error("Failed to stop network listener: "+e)}}setP2PNetworkConnected(){this.isP2PNetworkConnected||(this.isP2PNetworkConnected=!0,this.dispatchWakuConnectionEvent())}setP2PNetworkDisconnected(){this.isP2PNetworkConnected&&0===this.libp2p.getConnections().length&&(this.isP2PNetworkConnected=!1,this.dispatchWakuConnectionEvent())}dispatchWakuConnectionEvent(){this.dispatchEvent(new CustomEvent(An.CONNECTION_STATUS,{detail:this.isConnected()}))}}const js=new ir("metadata"),$s="/vac/waku/metadata/1.0.0";class Ks extends Yr{pubsubTopics;libp2pComponents;handshakesConfirmed=new Map;constructor(e,t){super($s,t.components,e),this.pubsubTopics=e,this.libp2pComponents=t,t.registrar.handle($s,e=>{this.onRequest(e)})}async query(e){const t=jt.encode(zn(this.pubsubTopics));if(!await this.libp2pComponents.peerStore.get(e))return{shardInfo:null,error:En.NO_PEER_AVAILABLE};let n;try{n=await this.getStream(e)}catch(i){return js.error("Failed to get stream",i),{shardInfo:null,error:En.NO_STREAM_AVAILABLE}}const r=await Ur([t],xr,n,Tr,async e=>await dr(e)),{error:i,shardInfo:s}=this.decodeMetadataResponse(r);return i?{shardInfo:null,error:i}:(await this.savePeerShardInfo(e,s),{shardInfo:s,error:null})}async confirmOrAttemptHandshake(e){const t=this.handshakesConfirmed.get(e.toString());return t?{shardInfo:t,error:null}:await this.query(e)}async onRequest(e){try{const{stream:t,connection:n}=e,r=$t.encode(zn(this.pubsubTopics)),i=await Ur([r],xr,t,Tr,async e=>await dr(e)),{error:s,shardInfo:o}=this.decodeMetadataResponse(i);if(s)return;await this.savePeerShardInfo(n.remotePeer,o)}catch(e){js.error("Error handling metadata request",e)}}decodeMetadataResponse(e){const t=new br;e.forEach(e=>{t.append(e)});const n=$t.decode(t);return n?{shardInfo:n,error:null}:(js.error("Error decoding metadata response"),{shardInfo:null,error:En.DECODE_FAILED})}async savePeerShardInfo(e,t){await this.libp2pComponents.peerStore.merge(e,{metadata:{shardInfo:Wn(t)}}),this.handshakesConfirmed.set(e.toString(),t)}}function Xs(e){return t=>new Ks(e,t)}function Ys(e,...t){if(!function(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function Zs(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function Js(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Qs(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function eo(e,t){return e<<32-t|e>>>t}function to(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),Ys(e),e}let no=class{};function ro(e){const t=t=>e().update(to(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function io(e,t,n){return e&t^~e&n}function so(e,t,n){return e&t^e&n^t&n}let oo=class extends no{constructor(e,t,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(e),this.view=Qs(this.buffer)}update(e){Zs(this),Ys(e=to(e));const{view:t,buffer:n,blockLen:r}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);if(o===r){const t=Qs(e);for(;r<=i-s;s+=r)this.process(t,s);continue}n.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Zs(this),function(e,t){Ys(e);const n=t.outputLen;if(e.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:i}=this;let{pos:s}=this;t[s++]=128,Js(this.buffer.subarray(s)),this.padOffset>r-s&&(this.process(n,0),s=0);for(let e=s;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const i=BigInt(32),s=BigInt(4294967295),o=Number(n>>i&s),a=Number(n&s),l=r?4:0,c=r?0:4;e.setUint32(t+l,o,r),e.setUint32(t+c,a,r)}(n,r-8,BigInt(8*this.length),i),this.process(n,0);const o=Qs(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen should be aligned to 32bit");const l=a/4,c=this.get();if(l>c.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)o.setUint32(4*e,c[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:i,destroyed:s,pos:o}=this;return e.destroyed=s,e.finished=i,e.length=r,e.pos=o,r%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}};const ao=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),lo=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),co=new Uint32Array(64);let ho=class extends oo{constructor(e=32){super(64,e,8,!1),this.A=0|ao[0],this.B=0|ao[1],this.C=0|ao[2],this.D=0|ao[3],this.E=0|ao[4],this.F=0|ao[5],this.G=0|ao[6],this.H=0|ao[7]}get(){const{A:e,B:t,C:n,D:r,E:i,F:s,G:o,H:a}=this;return[e,t,n,r,i,s,o,a]}set(e,t,n,r,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)co[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=co[e-15],n=co[e-2],r=eo(t,7)^eo(t,18)^t>>>3,i=eo(n,17)^eo(n,19)^n>>>10;co[e]=i+co[e-7]+r+co[e-16]|0}let{A:n,B:r,C:i,D:s,E:o,F:a,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(eo(o,6)^eo(o,11)^eo(o,25))+io(o,a,l)+lo[e]+co[e]|0,h=(eo(n,2)^eo(n,13)^eo(n,22))+so(n,r,i)|0;c=l,l=a,a=o,o=s+t|0,s=i,i=r,r=n,n=t+h|0}n=n+this.A|0,r=r+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,r,i,s,o,a,l,c)}roundClean(){Js(co)}destroy(){this.set(0,0,0,0,0,0,0,0),Js(this.buffer)}};const uo=ro(()=>new ho);function po(e,t){const n=Nn(e),r=Nn(t.contentTopic),i=function(e){if(!e)return;let t;t="bigint"==typeof e?e:1000000n*BigInt(e.valueOf());return function(e){const t=new ArrayBuffer(8),n=new DataView(t);return"number"==typeof e?n.setFloat64(0,e,!1):n.setBigInt64(0,e,!1),new Uint8Array(t)}(t)}(t.timestamp),s=Fn([n,t.payload,r,t.meta,i].filter(tn));return uo(s)}class fo{peerIds=[];isStarted=!1;pubsubTopic;config;libp2p;filter;peerManager;connectionManager;activeSubscriptions;keepAliveIntervalId;pingFailedAttempts=new Map;receivedMessagesFormPeer=new Set;receivedMessages=new Set;verifiedPeers=new Set;constructor(e){this.config=e.config,this.connectionManager=e.connectionManager,this.filter=e.filter,this.peerManager=e.peerManager,this.libp2p=e.libp2p,this.activeSubscriptions=e.activeSubscriptions,this.pubsubTopic=e.pubsubTopic,this.onConnectionChange=this.onConnectionChange.bind(this),this.onPeerConnected=this.onPeerConnected.bind(this),this.onPeerDisconnected=this.onPeerDisconnected.bind(this)}get reservedContentTopic(){return`/js-waku-subscription-ping/1/${this.libp2p.peerId.toString()}/utf8`}start(){this.isStarted||(this.isStarted=!0,this.startKeepAlive(),this.startConnectionListener(),this.startPeerConnectionListener())}stop(){this.isStarted&&(this.isStarted=!1,this.stopKeepAlive(),this.stopConnectionListener(),this.stopPeerConnectionListener())}async getPeers(){return this.isStarted||(this.peerIds=this.peerManager.getPeers()),this.peerIds}notifyMessageReceived(e,t){const n=this.buildMessageHash(t);return this.verifiedPeers.add(e),this.receivedMessagesFormPeer.add(`${e}-${n}`),!!this.receivedMessages.has(n)||(this.receivedMessages.add(n),!1)}buildMessageHash(e){return function(e,t){const n=po(e,t);return Dn(n)}(this.pubsubTopic,e)}startConnectionListener(){this.connectionManager.addEventListener(An.CONNECTION_STATUS,this.onConnectionChange)}stopConnectionListener(){this.connectionManager.removeEventListener(An.CONNECTION_STATUS,this.onConnectionChange)}async onConnectionChange({detail:e}){e?(await Promise.all(this.peerIds.map(e=>this.ping(e,!0))),this.startKeepAlive()):this.stopKeepAlive()}startKeepAlive(){this.keepAliveIntervalId||(this.keepAliveIntervalId=setInterval(()=>{this.peerIds.map(e=>this.ping(e))},this.config.keepAliveIntervalMs))}stopKeepAlive(){this.keepAliveIntervalId&&(clearInterval(this.keepAliveIntervalId),this.keepAliveIntervalId=void 0)}startPeerConnectionListener(){this.libp2p.addEventListener("peer:connect",this.onPeerConnected),this.libp2p.addEventListener("peer:disconnect",this.onPeerDisconnected)}stopPeerConnectionListener(){this.libp2p.removeEventListener("peer:connect",this.onPeerConnected),this.libp2p.removeEventListener("peer:disconnect",this.onPeerDisconnected)}async onPeerConnected(e){this.peerIds.length>0||(this.peerIds=this.peerManager.getPeers(),await Promise.all(this.peerIds.map(e=>this.subscribe(e))))}async onPeerDisconnected(e){!this.peerIds.find(t=>t.equals(e.detail))||(this.peerIds=this.peerManager.getPeers(),await Promise.all(this.peerIds.map(e=>this.subscribe(e))))}async subscribe(e){let t=e;for(let e=0;e<3;e++){if(!t)return;if((await this.filter.subscribe(this.pubsubTopic,t,Array.from(this.activeSubscriptions.keys()))).success)return;t=this.peerManager.requestRenew(t)}}async ping(e,t=!1){const n=e.toString(),r=await this.filter.ping(e);if(r.failure&&t){const t=this.peerManager.requestRenew(e);return void await this.subscribe(t)}if(r.failure){const e=this.pingFailedAttempts.get(n)||0;this.pingFailedAttempts.set(n,e+1)}r.success&&this.pingFailedAttempts.set(n,0);if((this.pingFailedAttempts.get(n)||0)>=this.config.pingsBeforePeerRenewed){const t=this.peerManager.requestRenew(e);await this.subscribe(t)}}}const mo=new ir("sdk:filter:subscription");class go{pubsubTopic;protocol;config;monitor;subscriptionCallbacks=new Map;constructor(e,t,n,r,i,s,o){this.pubsubTopic=e,this.protocol=t,this.config=s,this.pubsubTopic=e,this.monitor=new fo({pubsubTopic:e,config:s,libp2p:i,connectionManager:n,filter:t,peerManager:r,lightPush:o,activeSubscriptions:this.subscriptionCallbacks})}async subscribe(e,t){const n=Array.isArray(e)?e:[e];for(const e of n)if(e.pubsubTopic!==this.pubsubTopic)return{failures:[{error:En.TOPIC_DECODER_MISMATCH}],successes:[]};this.config.enableLightPushFilterCheck&&n.push(ur(this.monitor.reservedContentTopic,this.pubsubTopic));const r=nn(n),i=Array.from(r.keys()),s=(await this.monitor.getPeers()).map(async e=>this.protocol.subscribe(this.pubsubTopic,e,i)),o=await Promise.allSettled(s),a=this.handleResult(o,"subscribe");return r.forEach((e,n)=>{const r={decoders:e,callback:t};n!==this.monitor.reservedContentTopic&&this.subscriptionCallbacks.set(n,r)}),this.monitor.start(),a}async unsubscribe(e){const t=(await this.monitor.getPeers()).map(async t=>{const n=await this.protocol.unsubscribe(this.pubsubTopic,t,e);return e.forEach(e=>{this.subscriptionCallbacks.delete(e)}),n}),n=await Promise.allSettled(t),r=this.handleResult(n,"unsubscribe");return 0===this.subscriptionCallbacks.size&&this.monitor.stop(),r}async ping(){const e=(await this.monitor.getPeers()).map(e=>this.protocol.ping(e)),t=await Promise.allSettled(e);return this.handleResult(t,"ping")}async unsubscribeAll(){const e=(await this.monitor.getPeers()).map(async e=>this.protocol.unsubscribeAll(this.pubsubTopic,e)),t=await Promise.allSettled(e);this.subscriptionCallbacks.clear();const n=this.handleResult(t,"unsubscribeAll");return this.monitor.stop(),n}async processIncomingMessage(e,t){if(this.monitor.notifyMessageReceived(t,e))return void mo.info("Message already received, skipping");const{contentTopic:n}=e,r=this.subscriptionCallbacks.get(n);r?(mo.info("Processing message with content topic ",n," on pubsub topic ",this.pubsubTopic),await async function(e,t,n){const{decoders:r,callback:i}=e,{contentTopic:s}=n;if(!s)return void mo.warn("Message has no content topic, skipping");try{const e=r.map(e=>e.fromProtoObj(t,n).then(e=>e||Promise.reject("Decoding failed"))),s=await Promise.any(e);await i(s)}catch(e){mo.error("Error decoding message",e)}}(r,this.pubsubTopic,e)):mo.error("No subscription callback available for ",n)}handleResult(e,t){const n={failures:[],successes:[]};for(const r of e)if("rejected"===r.status)mo.error(`Failed to resolve ${t} promise successfully: `,r.reason),n.failures.push({error:En.GENERIC_FAIL});else{const e=r.value;e.failure?n.failures.push(e.failure):n.successes.push(e.success)}return n}}const yo=new ir("sdk:filter");class bo{protocol;config;connectionManager;libp2p;peerManager;lightPush;activeSubscriptions=new Map;constructor(e){this.config=(e=>({keepAliveIntervalMs:e?.keepAliveIntervalMs||6e4,pingsBeforePeerRenewed:e?.pingsBeforePeerRenewed||3,enableLightPushFilterCheck:e?.enableLightPushFilterCheck||!1}))(e.options),this.lightPush=e.lightPush,this.peerManager=e.peerManager,this.libp2p=e.libp2p,this.connectionManager=e.connectionManager,this.protocol=new li(async(e,t,n)=>{const r=this.getActiveSubscription(e);r?await r.processIncomingMessage(t,n):yo.error("No subscription locally registered for topic "+e)},e.connectionManager.pubsubTopics,e.libp2p),this.activeSubscriptions=new Map}async subscribe(e,t){const n=this.getUniquePubsubTopics(e);if(1!==n.length)return{subscription:null,error:En.INVALID_DECODER_TOPICS,results:null};const r=n[0],{subscription:i,error:s}=await this.createSubscription(r);if(s)return{subscription:null,error:s,results:null};const{failures:o,successes:a}=await i.subscribe(e,t);return{subscription:i,error:null,results:{failures:o,successes:a}}}async createSubscription(e){const t="string"==typeof e?e:On(e)?.[0];Un(t,this.protocol.pubsubTopics);const n=this.peerManager.getPeers();if(0===n.length)return{error:En.NO_PEER_AVAILABLE,subscription:null};yo.info(`Creating filter subscription with ${n.length} peers: `,n.map(e=>e.toString()));return{error:null,subscription:this.getActiveSubscription(t)??this.setActiveSubscription(t,new go(t,this.protocol,this.connectionManager,this.peerManager,this.libp2p,this.config,this.lightPush))}}async subscribeWithUnsubscribe(e,t){const n=this.getUniquePubsubTopics(e);if(0===n.length)throw Error("Failed to subscribe: no pubsubTopic found on decoders provided.");if(n.length>1)throw Error("Failed to subscribe: all decoders should have the same pubsub topic. Use createSubscription to be more agile.");const{subscription:r,error:i}=await this.createSubscription(n[0]);if(i)throw Error("Failed to create subscription: "+i);await r.subscribe(e,t);const s=Array.from(nn(Array.isArray(e)?e:[e]).keys());return async()=>{await r.unsubscribe(s)}}toSubscriptionIterator(e){return async function(e,t,n){const r=[];let i;i=await e.subscribeWithUnsubscribe(t,e=>{r.push(e)});const s=Number.isInteger(n?.timeoutMs),o=Date.now();return{iterator:async function*(){for(;;){if(s&&Date.now()-o>=0)return;await rn(60);const e=r.shift();if(!i&&0===r.length)return e;!e&&i||(yield e)}}(),async stop(){i&&(await i(),i=void 0)}}}(this,e)}getActiveSubscription(e){return this.activeSubscriptions.get(e)}setActiveSubscription(e,t){return this.activeSubscriptions.set(e,t),t}getUniquePubsubTopics(e){if(!Array.isArray(e))return[e.pubsubTopic];if(0===e.length)return[];const t=new Set(e.map(e=>e.pubsubTopic));return[...t]}}const vo=new ir("health-indicator");class wo extends Hi{libp2p;value=Ln.Unhealthy;constructor(e){super(),this.libp2p=e.libp2p,this.onPeerIdentify=this.onPeerIdentify.bind(this),this.onPeerDisconnected=this.onPeerDisconnected.bind(this)}start(){vo.info("start: adding listeners to libp2p"),this.libp2p.addEventListener("peer:identify",this.onPeerIdentify),this.libp2p.addEventListener("peer:disconnect",this.onPeerDisconnected)}stop(){vo.info("stop: removing listeners to libp2p"),this.libp2p.removeEventListener("peer:identify",this.onPeerIdentify),this.libp2p.removeEventListener("peer:disconnect",this.onPeerDisconnected)}toString(){return this.value}toValue(){return this.value}async onPeerDisconnected(e){vo.info("onPeerDisconnected: received libp2p event");this.libp2p.getConnections().length>0&&vo.info("onPeerDisconnected: has connections, ignoring"),this.value=Ln.Unhealthy,vo.info("onPeerDisconnected: node identified as "+this.value),this.dispatchHealthEvent()}async onPeerIdentify(e){vo.info("onPeerIdentify: received libp2p event");const t=this.libp2p.getConnections(),n=await Promise.all(t.map(async e=>{try{return await this.libp2p.peerStore.get(e.remotePeer)}catch(e){return null}})),r=n.filter(e=>e?.protocols.includes(oi)).length,i=n.filter(e=>e?.protocols.includes(ui)).length;0===r||0===i?this.value=Ln.Unhealthy:r>=2&&i>=2?this.value=Ln.SufficientlyHealthy:1===r&&1===i?this.value=Ln.MinimallyHealthy:vo.error(`onPeerChange: unexpected state, cannot identify health status of the node: Filter:${r}; LightPush:${i}`),vo.info("onPeerChange: node identified as "+this.value),this.dispatchHealthEvent()}dispatchHealthEvent(){this.dispatchEvent(new CustomEvent(In.StatusChange,{detail:this.value}))}}const xo=e=>new Promise((t,n)=>setTimeout(()=>n(Error("Task timeout")),e)),_o=new ir("sdk:retry-manager");class Eo{intervalID=null;retryIntervalMs;inProgress=0;queue=[];peerManager;constructor(e){this.peerManager=e.peerManager,this.retryIntervalMs=e.retryIntervalMs}start(){this.intervalID=setInterval(()=>{this.processQueue()},this.retryIntervalMs)}stop(){this.intervalID&&(clearInterval(this.intervalID),this.intervalID=null)}push(e,t){this.queue.push({maxAttempts:t,callback:e})}processQueue(){if(0!==this.queue.length)for(;this.queue.length&&this.inProgress<5;){const e=this.queue.shift();e&&this.scheduleTask(e)}else _o.info("processQueue: queue is empty")}scheduleTask(e){setTimeout(async()=>this.taskExecutor(e),100)}async taskExecutor(e){const t=this.peerManager.getPeers()[0];var n;if(t)try{this.inProgress+=1;const n=await Promise.race([xo(1e4),e.callback(t)]);if(n?.failure)throw Error(n.failure.error);if(_o.info("scheduleTask: executed successfully"),0===e.maxAttempts)return void _o.warn("scheduleTask: discarded a task due to limit of max attempts");this.queue.push({...e,maxAttempts:e.maxAttempts-1})}catch(r){const i=r;if(_o.error("scheduleTask: task execution failed with error:",i),((n=i.message)===En.REMOTE_PEER_REJECTED||n===En.NO_RESPONSE||n===En.RLN_PROOF_GENERATION||n===En.NO_PEER_AVAILABLE)&&this.peerManager.requestRenew(t),0===e.maxAttempts)return void _o.warn("scheduleTask: discarded a task due to limit of max attempts");this.queue.push({...e,maxAttempts:e.maxAttempts-1})}finally{this.inProgress-=1}else _o.warn("scheduleTask: no peers, skipping")}}const So=new ir("sdk:light-push"),Mo={autoRetry:!0,retryIntervalMs:1e3,maxAttempts:3,numPeersToUse:1};class Ao{config;retryManager;peerManager;protocol;constructor(e){this.config={...Mo,...e.options||{}},this.peerManager=e.peerManager,this.protocol=new di(e.connectionManager.pubsubTopics,e.libp2p),this.retryManager=new Eo({peerManager:e.peerManager,retryIntervalMs:this.config.retryIntervalMs})}start(){this.retryManager.start()}stop(){this.retryManager.stop()}async send(e,t,n={}){n={...this.config,...n};const{pubsubTopic:r}=e;if(So.info("send: attempting to send a message to pubsubTopic:",r),!this.protocol.pubsubTopics.includes(r))return{successes:[],failures:[{error:En.TOPIC_NOT_CONFIGURED}]};const i=this.peerManager.getPeers().slice(0,this.config.numPeersToUse);if(0===i.length)return{successes:[],failures:[{error:En.NO_PEER_AVAILABLE}]};const s=await Promise.all(i.map(n=>this.protocol.send(e,t,n).catch(()=>({success:null,failure:{error:En.GENERIC_FAIL}})))),o={successes:s.filter(e=>e.success).map(e=>e.success),failures:s.filter(e=>e.failure).map(e=>e.failure)};if(n.autoRetry&&0===o.successes.length){const r=n=>this.protocol.send(e,t,n);this.retryManager.push(r.bind(this),n.maxAttempts||3)}return o}}const Co=new ir("peer-manager"),To="peer-manager-lock";class Io{numPeersToUse;libp2p;constructor(e){this.onConnected=this.onConnected.bind(this),this.onDisconnected=this.onDisconnected.bind(this),this.numPeersToUse=e?.config?.numPeersToUse||2,this.libp2p=e.libp2p}start(){this.startConnectionListener()}stop(){this.stopConnectionListener()}getPeers(){return this.getLockedConnections().map(e=>e.remotePeer)}requestRenew(e){const t=this.getLockedConnections(),n=this.numPeersToUse-t.length;if(0===n)return;const r=this.getUnlockedConnections().filter(t=>!t.remotePeer.equals(e)).slice(0,n).map(e=>this.lockConnection(e)).map(e=>e.remotePeer),i=r[0];if(i)return Co.info(`requestRenew: Renewed peer ${e.toString()} to ${i.toString()}`),i;Co.warn(`requestRenew: Couldn't renew peer ${e.toString()} - no peers.`)}startConnectionListener(){this.libp2p.addEventListener("peer:connect",this.onConnected),this.libp2p.addEventListener("peer:disconnect",this.onDisconnected)}stopConnectionListener(){this.libp2p.removeEventListener("peer:connect",this.onConnected),this.libp2p.removeEventListener("peer:disconnect",this.onDisconnected)}onConnected(e){const t=e.detail;this.lockPeerIfNeeded(t)}onDisconnected(e){const t=e.detail;this.requestRenew(t)}lockPeerIfNeeded(e){const t=this.getLockedConnections();0!==this.numPeersToUse-t.length&&this.getUnlockedConnections().filter(t=>t.remotePeer.equals(e)).map(e=>this.lockConnection(e))}getLockedConnections(){return this.libp2p.getConnections().filter(e=>"open"===e.status&&this.isConnectionLocked(e))}getUnlockedConnections(){return this.libp2p.getConnections().filter(e=>"open"===e.status&&!this.isConnectionLocked(e))}lockConnection(e){return Co.info("requestRenew: Locking connection for peerId="+e.remotePeer.toString()),e.tags.push(To),e}isConnectionLocked(e){return e.tags.includes(To)}}const Lo=new ir("waku:store:sdk");class Po{options;peerManager;connectionManager;protocol;constructor(e){this.options=e.options||{},this.peerManager=e.peerManager,this.connectionManager=e.connectionManager,this.protocol=new vi(e.connectionManager.pubsubTopics,e.libp2p)}async*queryGenerator(e,t){const{pubsubTopic:n,contentTopics:r,decodersAsMap:i}=this.validateDecodersAndPubsubTopic(e),s={pubsubTopic:n,contentTopics:r,includeData:!0,paginationForward:!0,...t},o=await this.getPeerToUse();if(!o)throw Lo.error("No peers available to query"),Error("No peers available to query");Lo.info("Querying store with options: "+JSON.stringify(t));const a=this.protocol.queryPerPage(s,i,o);for await(const e of a)yield e}async queryWithOrderedCallback(e,t,n){Lo.info("Querying store with ordered callback");for await(const r of this.queryGenerator(e,n))if(await this.processMessages(r,t))break}async queryWithPromiseCallback(e,t,n){Lo.info("Querying store with promise callback");let r=!1;for await(const i of this.queryGenerator(e,n)){const e=i.map(async e=>{r||(r=!!await t(e))});if(await Promise.all(e),r)break}}async processMessages(e,t){let n=!1;const r=(await Promise.all(e)).filter(tn);return await Promise.all(r.map(async e=>{e&&!n&&(n=!!await t(e))})),n}createCursor(e){return po(e.pubsubTopic,e)}validateDecodersAndPubsubTopic(e){if(0===e.length)throw Lo.error("No decoders provided"),Error("No decoders provided");const t=Array.from(new Set(e.map(e=>e.pubsubTopic)));if(t.length>1)throw Lo.error("API does not support querying multiple pubsub topics at once"),Error("API does not support querying multiple pubsub topics at once");const n=t[0];Un(n,this.protocol.pubsubTopics);const r=new Map;e.forEach(e=>{if(r.has(e.contentTopic))throw Lo.error("API does not support different decoder per content topic"),Error("API does not support different decoder per content topic");r.set(e.contentTopic,e)});const i=e.filter(e=>e.pubsubTopic===n).map(e=>e.contentTopic);if(0===i.length)throw Lo.error("No decoders found for topic "+n),Error("No decoders found for topic "+n);return{pubsubTopic:n,contentTopics:i,decodersAsMap:r}}async getPeerToUse(){let e;if(this.options?.peer){const t=(await this.connectionManager.getConnectedPeers()).find(e=>e.id.toString()===this.options?.peer);e=t?.id,e||Lo.warn(`Passed node to use for Store not found: ${this.options.peer}. Attempting to use random peers.`)}const t=this.peerManager.getPeers();if(t.length>0)return t[Math.floor(Math.random()*t.length)];Lo.error("No peers available to use.")}}const Ro=(e,t)=>{const n=e.shardInfo?.clusterId||t.clusterId,r=e.shardInfo&&"shardsUnderCluster"in e.shardInfo?e.shardInfo.shardsUnderCluster:8;return{clusterId:n,shard:e.shardInfo&&"shard"in e.shardInfo?e.shardInfo.shard:Hn(e.contentTopic,r)}},Do=(e,t)=>t.clusterId===e.clusterId&&!("shards"in t&&!t.shards.includes(e.shard)),ko=new ir("wait-for-remote-peer");async function No(e,t,n){t=t?.length?t:function(e){const t=[];e.relay&&t.push(_n.Relay);e.filter&&t.push(_n.Filter);e.store&&t.push(_n.Store);e.lightPush&&t.push(_n.LightPush);return t}(e);const r=e.libp2p.getConnections();if(!e.isStarted())throw Error("Waku node is not started");for(const n of t)switch(n){case _n.Relay:if(!e.relay)throw Error("Cannot wait for Relay peer: protocol not mounted");break;case _n.LightPush:if(!e.lightPush)throw Error("Cannot wait for LightPush peer: protocol not mounted");break;case _n.Store:if(!e.store)throw Error("Cannot wait for Store peer: protocol not mounted");break;case _n.Filter:if(!e.filter)throw Error("Cannot wait for Filter peer: protocol not mounted")}const i=[Fo(e,t)];r.length>0&&!t.includes(_n.Relay)&&i.push(async function(e,t){const n=e.libp2p.getPeers(),r=e.libp2p.services.metadata,i=function(e){const t=new Map,n={[_n.Filter]:oi,[_n.LightPush]:ui,[_n.Store]:bi};for(const r of e)n[r]&&t.set(n[r],!1);return t}(t);if(!n.length||!r)return void ko.info(`Skipping waitForMetadata due to missing connections:${n.length} or metadataService:${!!r}`);for(const t of n)try{const n=await e.libp2p.peerStore.get(t),s=n.protocols.some(e=>i.has(e));if(s){if(!(await r.confirmOrAttemptHandshake(t)).error){n.protocols.forEach(e=>{i.has(e)&&i.set(e,!0)});if(Array.from(i.values()).every(e=>e))return}}}catch(e){"ERR_CONNECTION_BEING_CLOSED"===e.code&&ko.error("Connection closed. Some peers can be on different shard."),ko.error("Error while iterating through peers: "+e);continue}}(e,t)),n?await async function(e,t,n){await Promise.race([e,Bo(t,n)])}(Promise.any(i),n,"Timed out waiting for a remote peer."):await Promise.any(i)}async function Fo(e,t){const n=[];return e.relay&&t.includes(_n.Relay)&&n.push(e.relay.waitForPeers()),e.store&&t.includes(_n.Store)&&n.push(Oo(bi,e.libp2p)),e.lightPush&&t.includes(_n.LightPush)&&n.push(Oo(ui,e.libp2p)),e.filter&&t.includes(_n.Filter)&&n.push(Oo(oi,e.libp2p)),Promise.all(n)}async function Oo(e,t){ko.info(`Waiting for ${e} peer.`),await new Promise(n=>{const r=async i=>{if(i.detail?.protocols?.includes(e)){const e=t.services.metadata;if(!e)return t.removeEventListener("peer:identify",r),void n();try{await e.confirmOrAttemptHandshake(i.detail.peerId),t.removeEventListener("peer:identify",r),n()}catch(e){"ERR_CONNECTION_BEING_CLOSED"===e.code&&ko.error("Connection closed. Some peers can be on different shard."),ko.error("Error waiting for metadata: "+e)}}};t.addEventListener("peer:identify",r)})}const Bo=(e,t)=>new Promise((n,r)=>setTimeout(()=>r(Error(t)),e));const zo=new ir("waku");class Uo{pubsubTopics;libp2p;relay;store;filter;lightPush;connectionManager;health;networkConfig;_nodeStateLock=!1;_nodeStarted=!1;peerManager;constructor(e,t,n,r,i){this.pubsubTopics=e,this.relay=i,this.libp2p=n,this.networkConfig=t.networkConfig||Tn,r={filter:!1,lightpush:!1,store:!1,...r};const s=this.libp2p.peerId.toString();this.connectionManager=new Ws({libp2p:n,relay:this.relay,pubsubTopics:this.pubsubTopics,config:t?.connectionManager}),this.peerManager=new Io({libp2p:n,config:{numPeersToUse:t.numPeersToUse}}),this.health=new wo({libp2p:n}),r.store&&(t.store?.peer&&this.connectionManager.rawDialPeerWithProtocols(t.store.peer,[bi]).catch(e=>{zo.error("Failed to dial store peer",e)}),this.store=new Po({libp2p:n,connectionManager:this.connectionManager,peerManager:this.peerManager,options:{peer:t.store?.peer}})),r.lightpush&&(this.lightPush=new Ao({libp2p:n,peerManager:this.peerManager,connectionManager:this.connectionManager,options:t?.lightPush})),r.filter&&(this.filter=new bo({libp2p:n,connectionManager:this.connectionManager,peerManager:this.peerManager,lightPush:this.lightPush,options:t.filter})),zo.info("Waku node created",s,`relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`)}get peerId(){return this.libp2p.peerId}get protocols(){return this.libp2p.getProtocols()}async dial(e,t){const n=t??[];void 0===t&&(this.relay&&n.push(_n.Relay),this.store&&n.push(_n.Store),this.filter&&n.push(_n.Filter),this.lightPush&&n.push(_n.LightPush));const r=[];n.includes(_n.Relay)&&(this.relay?this.relay.gossipSub.multicodecs.forEach(e=>r.push(e)):zo.error("Relay codec not included in dial codec: protocol not mounted locally")),n.includes(_n.Store)&&(this.store?r.push(this.store.protocol.multicodec):zo.error("Store codec not included in dial codec: protocol not mounted locally")),n.includes(_n.LightPush)&&(this.lightPush?r.push(this.lightPush.protocol.multicodec):zo.error("Light Push codec not included in dial codec: protocol not mounted locally")),n.includes(_n.Filter)&&(this.filter?r.push(this.filter.protocol.multicodec):zo.error("Filter codec not included in dial codec: protocol not mounted locally"));const i=(e=>Si(e)?e:Us(e))(e);return zo.info(`Dialing to ${i.toString()} with protocols ${n}`),await this.connectionManager.rawDialPeerWithProtocols(e,r)}async start(){this._nodeStateLock||this.isStarted()||(this._nodeStateLock=!0,await this.libp2p.start(),this.peerManager.start(),this.health.start(),this.lightPush?.start(),this._nodeStateLock=!1,this._nodeStarted=!0)}async stop(){!this._nodeStateLock&&this.isStarted()&&(this._nodeStateLock=!0,this.lightPush?.stop(),this.health.stop(),this.peerManager.stop(),this.connectionManager.stop(),await this.libp2p.stop(),this._nodeStateLock=!1,this._nodeStarted=!1)}async getConnectedPeers(){return this.connectionManager.getConnectedPeers()}async waitForPeers(e,t){return No(this,e,t)}isStarted(){return this._nodeStarted&&"started"===this.libp2p.status}isConnected(){return this.connectionManager.isConnected()}createDecoder(e){const t=Ro(e,this.networkConfig);if(zo.info(`Creating Decoder with input:${JSON.stringify(e.shardInfo)}, determined:${JSON.stringify(t)}, expected:${JSON.stringify(this.networkConfig)}.`),!Do(t,this.networkConfig))throw Error("Cannot create decoder: incompatible shard configuration.");return ur(e.contentTopic,t)}createEncoder(e){const t=Ro(e,this.networkConfig);if(zo.info(`Creating Encoder with input:${JSON.stringify(e.shardInfo)}, determined:${JSON.stringify(t)}, expected:${JSON.stringify(this.networkConfig)}.`),!Do(t,this.networkConfig))throw Error("Cannot create encoder: incompatible shard configuration.");return cr({contentTopic:e.contentTopic,ephemeral:e.ephemeral,pubsubTopicShardInfo:t})}}let Ho=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class qo extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}let Vo=class extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}};const Go=parseInt("11111",2),Wo=parseInt("10000000",2),jo=parseInt("01111111",2),$o={0:Yo,1:Yo,2(e,t){const n=Xo(e,t),r=t.offset,i=t.offset+n,s=[];for(let t=r;t<i;t++)t===r&&0===e[t]||s.push(e[t]);return t.offset+=n,Uint8Array.from(s)},3(e,t){const n=Xo(e,t),r=e[t.offset];t.offset++;const i=e.subarray(t.offset,t.offset+n-1);if(t.offset+=n,0!==r)throw Error("Unused bits in bit string is unimplemented");return i},4(e,t){const n=Xo(e,t),r=e.subarray(t.offset,t.offset+n);return t.offset+=n,r},5(e,t){return t.offset++,null},6(e,t){const n=Xo(e,t),r=t.offset+n,i=e[t.offset];t.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,l=[];for(;t.offset<r;){const n=e[t.offset];if(t.offset++,l.push(127&n),n<128){l.reverse();let e=0;for(let t=0;t<l.length;t++)e+=l[t]<<7*t;a+="."+e,l=[]}}return a},16:Yo,22:Yo,48:Yo};function Ko(e,t={offset:0}){const n=e[t.offset]&Go;if(t.offset++,null!=$o[n])return $o[n](e,t);throw Error("No decoder for tag "+n)}function Xo(e,t){let n=0;if((e[t.offset]&Wo)===Wo){const r=e[t.offset]&jo;let i="0x";t.offset++;for(let n=0;n<r;n++,t.offset++)i+=e[t.offset].toString(16).padStart(2,"0");n=parseInt(i,16)}else n=e[t.offset],t.offset++;return n}function Yo(e,t){Xo(e,t);const n=[];for(;!(t.offset>=e.byteLength);){const r=Ko(e,t);if(null===r)break;n.push(r)}return n}function Zo(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);const n=new br;for(let e=0;e<t.length;e+=2)n.append(Uint8Array.from([parseInt(`${t[e]}${t[e+1]}`,16)]));return n}(e.byteLength);return new br(Uint8Array.from([t.byteLength|Wo]),t)}function Jo(e){const t=new br;return!(128&~e.subarray()[0])&&t.append(Uint8Array.from([0])),t.append(e),new br(Uint8Array.from([2]),Zo(t),t)}function Qo(e){const t=Uint8Array.from([0]),n=new br(t,e);return new br(Uint8Array.from([3]),Zo(n),n)}function ea(e,t=48){const n=new br;for(const t of e)n.append(t);return new br(Uint8Array.from([t]),Zo(n),n)}const ta=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),na=Uint8Array.from([6,5,43,129,4,0,34]),ra=Uint8Array.from([6,5,43,129,4,0,35]),ia={ext:!0,kty:"EC",crv:"P-256"},sa={ext:!0,kty:"EC",crv:"P-384"},oa={ext:!0,kty:"EC",crv:"P-521"};function aa(e){return la(Ko(e))}function la(e){const t=e[1][1][0];let n,r;if(65===t.byteLength)return n=Pn(t.subarray(1,33),"base64url"),r=Pn(t.subarray(33),"base64url"),new ha({...ia,key_ops:["verify"],x:n,y:r});if(97===t.byteLength)return n=Pn(t.subarray(1,49),"base64url"),r=Pn(t.subarray(49),"base64url"),new ha({...sa,key_ops:["verify"],x:n,y:r});if(133===t.byteLength)return n=Pn(t.subarray(1,67),"base64url"),r=Pn(t.subarray(67),"base64url"),new ha({...oa,key_ops:["verify"],x:n,y:r});throw new Ho(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function ca(e){if("P-256"===e)return ta;if("P-384"===e)return na;if("P-521"===e)return ra;throw new Ho("Invalid curve "+e)}class ha{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){var e;return null==this._raw&&(this._raw=(e=this.jwk,ea([Jo(Uint8Array.from([1])),ea([ca(e.crv)],160),ea([Qo(new br(Uint8Array.from([4]),rt(e.x??"","base64url"),rt(e.y??"","base64url")))],161)]).subarray())),this._raw}toMultihash(){return Ue.digest(Ah(this))}toCID(){return $e.createV1(114,this.toMultihash())}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&fr(this.raw,e.raw)}async verify(e,t,n){return async function(e,t,n,r){const i=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,t,n.subarray());return r?.signal?.throwIfAborted(),s}(this.jwk,t,e,n)}}function ua(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function da(e,t=""){if(!Number.isSafeInteger(e)||e<0){throw Error(`${t&&`"${t}" `}expected integer >= 0, got ${e}`)}}function pa(e,t,n=""){const r=ua(e),i=e?.length,s=void 0!==t;if(!r||s&&i!==t){throw Error((n&&`"${n}" `)+"expected Uint8Array"+(s?" of length "+t:"")+", got "+(r?"length="+i:"type="+typeof e))}return e}function fa(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash must wrapped by utils.createHasher");da(e.outputLen),da(e.blockLen)}function ma(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function ga(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function ya(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function ba(e,t){return e<<32-t|e>>>t}const va=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),wa=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function xa(e){if(pa(e),va)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=wa[e[n]];return t}const _a=48,Ea=57,Sa=65,Ma=70,Aa=97,Ca=102;function Ta(e){return e>=_a&&e<=Ea?e-_a:e>=Sa&&e<=Ma?e-(Sa-10):e>=Aa&&e<=Ca?e-(Aa-10):void 0}function Ia(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);if(va)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,i=0;t<n;t++,i+=2){const n=Ta(e.charCodeAt(i)),s=Ta(e.charCodeAt(i+1));if(void 0===n||void 0===s){const t=e[i]+e[i+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+i)}r[t]=16*n+s}return r}function La(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];pa(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const i=e[t];n.set(i,r),r+=i.length}return n}function Pa(e,t={}){const n=(t,n)=>e(n).update(t).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=t=>e(t),Object.assign(n,t),Object.freeze(n)}function Ra(e=32){const t="object"==typeof globalThis?globalThis.crypto:null;if("function"!=typeof t?.getRandomValues)throw Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const Da=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function ka(e,t,n){return e&t^~e&n}function Na(e,t,n){return e&t^e&n^t&n}let Fa=class{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(e,t,n,r){this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(e),this.view=ya(this.buffer)}update(e){ma(this),pa(e);const{view:t,buffer:n,blockLen:r}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);if(o===r){const t=ya(e);for(;r<=i-s;s+=r)this.process(t,s);continue}n.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ma(this),function(e,t){pa(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw Error('"digestInto() output" expected to be of length >='+n)}(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:i}=this;let{pos:s}=this;t[s++]=128,ga(this.buffer.subarray(s)),this.padOffset>r-s&&(this.process(n,0),s=0);for(let e=s;e<r;e++)t[e]=0;n.setBigUint64(r-8,BigInt(8*this.length),i),this.process(n,0);const o=ya(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen must be aligned to 32bit");const l=a/4,c=this.get();if(l>c.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)o.setUint32(4*e,c[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||=new this.constructor,e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:i,destroyed:s,pos:o}=this;return e.destroyed=s,e.finished=i,e.length=r,e.pos=o,r%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}};const Oa=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ba=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),za=BigInt(2**32-1),Ua=BigInt(32);function Ha(e,t=!1){return t?{h:Number(e&za),l:Number(e>>Ua&za)}:{h:0|Number(e>>Ua&za),l:0|Number(e&za)}}const qa=(e,t,n)=>e>>>n,Va=(e,t,n)=>e<<32-n|t>>>n,Ga=(e,t,n)=>e>>>n|t<<32-n,Wa=(e,t,n)=>e<<32-n|t>>>n,ja=(e,t,n)=>e<<64-n|t>>>n-32,$a=(e,t,n)=>e>>>n-32|t<<64-n;function Ka(e,t,n,r){const i=(t>>>0)+(r>>>0);return{h:e+n+(i/2**32|0)|0,l:0|i}}const Xa=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Ya=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,Za=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),Ja=(e,t,n,r,i)=>t+n+r+i+(e/2**32|0)|0,Qa=(e,t,n,r,i)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(i>>>0),el=(e,t,n,r,i,s)=>t+n+r+i+s+(e/2**32|0)|0,tl=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nl=new Uint32Array(64);class rl extends Fa{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:n,D:r,E:i,F:s,G:o,H:a}=this;return[e,t,n,r,i,s,o,a]}set(e,t,n,r,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)nl[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=nl[e-15],n=nl[e-2],r=ba(t,7)^ba(t,18)^t>>>3,i=ba(n,17)^ba(n,19)^n>>>10;nl[e]=i+nl[e-7]+r+nl[e-16]|0}let{A:n,B:r,C:i,D:s,E:o,F:a,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(ba(o,6)^ba(o,11)^ba(o,25))+ka(o,a,l)+tl[e]+nl[e]|0,h=(ba(n,2)^ba(n,13)^ba(n,22))+Na(n,r,i)|0;c=l,l=a,a=o,o=s+t|0,s=i,i=r,r=n,n=t+h|0}n=n+this.A|0,r=r+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,r,i,s,o,a,l,c)}roundClean(){ga(nl)}destroy(){this.set(0,0,0,0,0,0,0,0),ga(this.buffer)}}class il extends rl{A=0|Oa[0];B=0|Oa[1];C=0|Oa[2];D=0|Oa[3];E=0|Oa[4];F=0|Oa[5];G=0|Oa[6];H=0|Oa[7];constructor(){super(32)}}const sl=(()=>function(e,t=!1){const n=e.length;let r=new Uint32Array(n),i=new Uint32Array(n);for(let s=0;s<n;s++){const{h:n,l:o}=Ha(e[s],t);[r[s],i[s]]=[n,o]}return[r,i]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))))(),ol=(()=>sl[0])(),al=(()=>sl[1])(),ll=new Uint32Array(80),cl=new Uint32Array(80);class hl extends Fa{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:n,Bl:r,Ch:i,Cl:s,Dh:o,Dl:a,Eh:l,El:c,Fh:h,Fl:u,Gh:d,Gl:p,Hh:f,Hl:m}=this;return[e,t,n,r,i,s,o,a,l,c,h,u,d,p,f,m]}set(e,t,n,r,i,s,o,a,l,c,h,u,d,p,f,m){this.Ah=0|e,this.Al=0|t,this.Bh=0|n,this.Bl=0|r,this.Ch=0|i,this.Cl=0|s,this.Dh=0|o,this.Dl=0|a,this.Eh=0|l,this.El=0|c,this.Fh=0|h,this.Fl=0|u,this.Gh=0|d,this.Gl=0|p,this.Hh=0|f,this.Hl=0|m}process(e,t){for(let n=0;n<16;n++,t+=4)ll[n]=e.getUint32(t),cl[n]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|ll[e-15],n=0|cl[e-15],r=Ga(t,n,1)^Ga(t,n,8)^qa(t,0,7),i=Wa(t,n,1)^Wa(t,n,8)^Va(t,n,7),s=0|ll[e-2],o=0|cl[e-2],a=Ga(s,o,19)^ja(s,o,61)^qa(s,0,6),l=Wa(s,o,19)^$a(s,o,61)^Va(s,o,6),c=Za(i,l,cl[e-7],cl[e-16]),h=Ja(c,r,a,ll[e-7],ll[e-16]);ll[e]=0|h,cl[e]=0|c}let{Ah:n,Al:r,Bh:i,Bl:s,Ch:o,Cl:a,Dh:l,Dl:c,Eh:h,El:u,Fh:d,Fl:p,Gh:f,Gl:m,Hh:g,Hl:y}=this;for(let e=0;e<80;e++){const t=Ga(h,u,14)^Ga(h,u,18)^ja(h,u,41),b=Wa(h,u,14)^Wa(h,u,18)^$a(h,u,41),v=h&d^~h&f,w=Qa(y,b,u&p^~u&m,al[e],cl[e]),x=el(w,g,t,v,ol[e],ll[e]),_=0|w,E=Ga(n,r,28)^ja(n,r,34)^ja(n,r,39),S=Wa(n,r,28)^$a(n,r,34)^$a(n,r,39),M=n&i^n&o^i&o,A=r&s^r&a^s&a;g=0|f,y=0|m,f=0|d,m=0|p,d=0|h,p=0|u,({h,l:u}=Ka(0|l,0|c,0|x,0|_)),l=0|o,c=0|a,o=0|i,a=0|s,i=0|n,s=0|r;const C=Xa(_,S,A);n=Ya(C,x,E,M),r=0|C}({h:n,l:r}=Ka(0|this.Ah,0|this.Al,0|n,0|r)),({h:i,l:s}=Ka(0|this.Bh,0|this.Bl,0|i,0|s)),({h:o,l:a}=Ka(0|this.Ch,0|this.Cl,0|o,0|a)),({h:l,l:c}=Ka(0|this.Dh,0|this.Dl,0|l,0|c)),({h,l:u}=Ka(0|this.Eh,0|this.El,0|h,0|u)),({h:d,l:p}=Ka(0|this.Fh,0|this.Fl,0|d,0|p)),({h:f,l:m}=Ka(0|this.Gh,0|this.Gl,0|f,0|m)),({h:g,l:y}=Ka(0|this.Hh,0|this.Hl,0|g,0|y)),this.set(n,r,i,s,o,a,l,c,h,u,d,p,f,m,g,y)}roundClean(){ga(ll,cl)}destroy(){ga(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class ul extends hl{Ah=0|Ba[0];Al=0|Ba[1];Bh=0|Ba[2];Bl=0|Ba[3];Ch=0|Ba[4];Cl=0|Ba[5];Dh=0|Ba[6];Dl=0|Ba[7];Eh=0|Ba[8];El=0|Ba[9];Fh=0|Ba[10];Fl=0|Ba[11];Gh=0|Ba[12];Gl=0|Ba[13];Hh=0|Ba[14];Hl=0|Ba[15];constructor(){super(64)}}const dl=Pa(()=>new il,Da(1)),pl=Pa(()=>new ul,Da(3)),fl=BigInt(0),ml=BigInt(1);function gl(e,t=""){if("boolean"!=typeof e){throw Error((t&&`"${t}" `)+"expected boolean, got type="+typeof e)}return e}function yl(e){if("bigint"==typeof e){if(!Ml(e))throw Error("positive bigint expected, got "+e)}else da(e);return e}function bl(e){const t=yl(e).toString(16);return 1&t.length?"0"+t:t}function vl(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?fl:BigInt("0x"+e)}function wl(e){return vl(xa(e))}function xl(e){return vl(xa(Sl(pa(e)).reverse()))}function _l(e,t){da(t);const n=Ia((e=yl(e)).toString(16).padStart(2*t,"0"));if(n.length!==t)throw Error("number too large");return n}function El(e,t){return _l(e,t).reverse()}function Sl(e){return Uint8Array.from(e)}const Ml=e=>"bigint"==typeof e&&fl<=e;function Al(e,t,n,r){if(!function(e,t,n){return Ml(e)&&Ml(t)&&Ml(n)&&t<=e&&e<n}(t,n,r))throw Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}const Cl=e=>(ml<<BigInt(e))-ml;function Tl(e,t={},n={}){if(!e||"object"!=typeof e)throw Error("expected valid options object");const r=(t,n)=>Object.entries(t).forEach(([t,r])=>function(t,n,r){const i=e[t];if(r&&void 0===i)return;const s=typeof i;if(s!==n||null===i)throw Error(`param "${t}" is invalid: expected ${n}, got ${s}`)}(t,r,n));r(t,!1),r(n,!0)}function Il(e){const t=new WeakMap;return(n,...r)=>{const i=t.get(n);if(void 0!==i)return i;const s=e(n,...r);return t.set(n,s),s}}const Ll=BigInt(0),Pl=BigInt(1),Rl=BigInt(2),Dl=BigInt(3),kl=BigInt(4),Nl=BigInt(5),Fl=BigInt(7),Ol=BigInt(8),Bl=BigInt(9),zl=BigInt(16);function Ul(e,t){const n=e%t;return n>=Ll?n:t+n}function Hl(e,t,n){let r=e;for(;t-- >Ll;)r*=r,r%=n;return r}function ql(e,t){if(e===Ll)throw Error("invert: expected non-zero number");if(t<=Ll)throw Error("invert: expected positive modulus, got "+t);let n=Ul(e,t),r=t,i=Ll,s=Pl;for(;n!==Ll;){const e=r%n,t=i-s*(r/n);r=n,n=e,i=s,s=t}if(r!==Pl)throw Error("invert: does not exist");return Ul(i,t)}function Vl(e,t,n){if(!e.eql(e.sqr(t),n))throw Error("Cannot find square root")}function Gl(e,t){const n=(e.ORDER+Pl)/kl,r=e.pow(t,n);return Vl(e,r,t),r}function Wl(e,t){const n=(e.ORDER-Nl)/Ol,r=e.mul(t,Rl),i=e.pow(r,n),s=e.mul(t,i),o=e.mul(e.mul(s,Rl),i),a=e.mul(s,e.sub(o,e.ONE));return Vl(e,a,t),a}function jl(e){if(e<Dl)throw Error("sqrt is not defined for small field");let t=e-Pl,n=0;for(;t%Rl===Ll;)t/=Rl,n++;let r=Rl;const i=Jl(e);for(;1===Yl(i,r);)if(r++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===n)return Gl;let s=i.pow(r,t);const o=(t+Pl)/Rl;return function(e,r){if(e.is0(r))return r;if(1!==Yl(e,r))throw Error("Cannot find square root");let i=n,a=e.mul(e.ONE,s),l=e.pow(r,t),c=e.pow(r,o);for(;!e.eql(l,e.ONE);){if(e.is0(l))return e.ZERO;let t=1,n=e.sqr(l);for(;!e.eql(n,e.ONE);)if(t++,n=e.sqr(n),t===i)throw Error("Cannot find square root");const r=Pl<<BigInt(i-t-1),s=e.pow(a,r);i=t,a=e.sqr(s),l=e.mul(l,a),c=e.mul(c,s)}return c}}function $l(e){return e%kl===Dl?Gl:e%Ol===Nl?Wl:e%zl===Bl?function(e){const t=Jl(e),n=jl(e),r=n(t,t.neg(t.ONE)),i=n(t,r),s=n(t,t.neg(r)),o=(e+Fl)/zl;return(e,t)=>{let n=e.pow(t,o),a=e.mul(n,r);const l=e.mul(n,i),c=e.mul(n,s),h=e.eql(e.sqr(a),t),u=e.eql(e.sqr(l),t);n=e.cmov(n,a,h),a=e.cmov(c,l,u);const d=e.eql(e.sqr(a),t),p=e.cmov(n,a,d);return Vl(e,p,t),p}}(e):jl(e)}const Kl=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Xl(e,t,n=!1){const r=Array(t.length).fill(n?e.ZERO:void 0),i=t.reduce((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n)),e.ONE),s=e.inv(i);return t.reduceRight((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n)),s),r}function Yl(e,t){const n=(e.ORDER-Pl)/Rl,r=e.pow(t,n),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!o)throw Error("invalid Legendre symbol result");return i?1:s?0:-1}class Zl{ORDER;BITS;BYTES;isLE;ZERO=Ll;ONE=Pl;_lengths;_sqrt;_mod;constructor(e,t={}){if(e<=Ll)throw Error("invalid field: expected ORDER > 0, got "+e);let n;this.isLE=!1,null!=t&&"object"==typeof t&&("number"==typeof t.BITS&&(n=t.BITS),"function"==typeof t.sqrt&&(this.sqrt=t.sqrt),"boolean"==typeof t.isLE&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=t.allowedLengths?.slice()),"boolean"==typeof t.modFromBytes&&(this._mod=t.modFromBytes));const{nBitLength:r,nByteLength:i}=function(e,t){void 0!==t&&da(t);const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}(e,n);if(i>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=r,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return Ul(e,this.ORDER)}isValid(e){if("bigint"!=typeof e)throw Error("invalid field element: expected bigint, got "+typeof e);return Ll<=e&&e<this.ORDER}is0(e){return e===Ll}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&Pl)===Pl}neg(e){return Ul(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return Ul(e*e,this.ORDER)}add(e,t){return Ul(e+t,this.ORDER)}sub(e,t){return Ul(e-t,this.ORDER)}mul(e,t){return Ul(e*t,this.ORDER)}pow(e,t){return function(e,t,n){if(n<Ll)throw Error("invalid exponent, negatives unsupported");if(n===Ll)return e.ONE;if(n===Pl)return t;let r=e.ONE,i=t;for(;n>Ll;)n&Pl&&(r=e.mul(r,i)),i=e.sqr(i),n>>=Pl;return r}(this,e,t)}div(e,t){return Ul(e*ql(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return ql(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=$l(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?El(e,this.BYTES):_l(e,this.BYTES)}fromBytes(e,t=!1){pa(e);const{_lengths:n,BYTES:r,isLE:i,ORDER:s,_mod:o}=this;if(n){if(!n.includes(e.length)||e.length>r)throw Error("Field.fromBytes: expected "+n+" bytes, got "+e.length);const t=new Uint8Array(r);t.set(e,i?0:t.length-e.length),e=t}if(e.length!==r)throw Error("Field.fromBytes: expected "+r+" bytes, got "+e.length);let a=i?xl(e):wl(e);if(o&&(a=Ul(a,s)),!t&&!this.isValid(a))throw Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(e){return Xl(this,e)}cmov(e,t,n){return n?t:e}}function Jl(e,t={}){return new Zl(e,t)}function Ql(e){if("bigint"!=typeof e)throw Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function ec(e){const t=Ql(e);return t+Math.ceil(t/2)}const tc=BigInt(0),nc=BigInt(1);function rc(e,t){const n=t.negate();return e?n:t}function ic(e,t){const n=Xl(e.Fp,t.map(e=>e.Z));return t.map((t,r)=>e.fromAffine(t.toAffine(n[r])))}function sc(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw Error("invalid window size, expected [1.."+t+"], got W="+e)}function oc(e,t){sc(e,t);const n=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:Cl(e),maxNumber:n,shiftBy:BigInt(e)}}function ac(e,t,n){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=n;let a=Number(e&i),l=e>>o;a>r&&(a-=s,l+=nc);const c=t*r;return{nextN:l,offset:c+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:c}}const lc=new WeakMap,cc=new WeakMap;function hc(e){return cc.get(e)||1}function uc(e){if(e!==tc)throw Error("invalid wNAF")}class dc{BASE;ZERO;Fn;bits;constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,n=this.ZERO){let r=e;for(;t>tc;)t&nc&&(n=n.add(r)),r=r.double(),t>>=nc;return n}precomputeWindow(e,t){const{windows:n,windowSize:r}=oc(t,this.bits),i=[];let s=e,o=s;for(let e=0;e<n;e++){o=s,i.push(o);for(let e=1;e<r;e++)o=o.add(s),i.push(o);s=o.double()}return i}wNAF(e,t,n){if(!this.Fn.isValid(n))throw Error("invalid scalar");let r=this.ZERO,i=this.BASE;const s=oc(e,this.bits);for(let e=0;e<s.windows;e++){const{nextN:o,offset:a,isZero:l,isNeg:c,isNegF:h,offsetF:u}=ac(n,e,s);n=o,l?i=i.add(rc(h,t[u])):r=r.add(rc(c,t[a]))}return uc(n),{p:r,f:i}}wNAFUnsafe(e,t,n,r=this.ZERO){const i=oc(e,this.bits);for(let e=0;e<i.windows&&n!==tc;e++){const{nextN:s,offset:o,isZero:a,isNeg:l}=ac(n,e,i);if(n=s,!a){const e=t[o];r=r.add(l?e.negate():e)}}return uc(n),r}getPrecomputes(e,t,n){let r=lc.get(t);return r||(r=this.precomputeWindow(t,e),1!==e&&("function"==typeof n&&(r=n(r)),lc.set(t,r))),r}cached(e,t,n){const r=hc(e);return this.wNAF(r,this.getPrecomputes(r,e,n),t)}unsafe(e,t,n,r){const i=hc(e);return 1===i?this._unsafeLadder(e,t,r):this.wNAFUnsafe(i,this.getPrecomputes(i,e,n),t,r)}createCache(e,t){sc(t,this.bits),cc.set(e,t),lc.delete(e)}hasCache(e){return 1!==hc(e)}}function pc(e,t,n){if(t){if(t.ORDER!==e)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(e){const t=Kl.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",BYTES:"number",BITS:"number"});Tl(e,t)}(t),t}return Jl(e,{isLE:n})}function fc(e,t,n={},r){if(void 0===r&&(r="edwards"===e),!t||"object"!=typeof t)throw Error(`expected valid ${e} CURVE object`);for(const e of["p","n","h"]){const n=t[e];if(!("bigint"==typeof n&&n>tc))throw Error(`CURVE.${e} must be positive bigint`)}const i=pc(t.p,n.Fp,r),s=pc(t.n,n.Fn,r),o=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const e of o)if(!i.isValid(t[e]))throw Error(`CURVE.${e} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:i,Fn:s}}function mc(e,t){return function(n){const r=e(n);return{secretKey:r,publicKey:t(r)}}}const gc=BigInt(0),yc=BigInt(1),bc=BigInt(2),vc=BigInt(8);function wc(e,t={}){const n=fc("edwards",e,t,t.FpFnLE),{Fp:r,Fn:i}=n;let s=n.CURVE;const{h:o}=s;Tl(t,{},{uvRatio:"function"});const a=bc<<BigInt(8*i.BYTES)-yc,l=e=>r.create(e),c=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:r.sqrt(r.div(e,t))}}catch(e){return{isValid:!1,value:gc}}});if(!function(e,t,n,r){const i=e.sqr(n),s=e.sqr(r),o=e.add(e.mul(t.a,i),s),a=e.add(e.ONE,e.mul(t.d,e.mul(i,s)));return e.eql(o,a)}(r,s,s.Gx,s.Gy))throw Error("bad curve params: generator point");function h(e,t,n=!1){return Al("coordinate "+e,t,n?yc:gc,a),t}function u(e){if(!(e instanceof f))throw Error("EdwardsPoint expected")}const d=Il((e,t)=>{const{X:n,Y:i,Z:s}=e,o=e.is0();null==t&&(t=o?vc:r.inv(s));const a=l(n*t),c=l(i*t),h=r.mul(s,t);if(o)return{x:gc,y:yc};if(h!==yc)throw Error("invZ was invalid");return{x:a,y:c}}),p=Il(e=>{const{a:t,d:n}=s;if(e.is0())throw Error("bad point: ZERO");const{X:r,Y:i,Z:o,T:a}=e,c=l(r*r),h=l(i*i),u=l(o*o),d=l(u*u),p=l(c*t);if(l(u*l(p+h))!==l(d+l(n*l(c*h))))throw Error("bad point: equation left != right (1)");if(l(r*i)!==l(o*a))throw Error("bad point: equation left != right (2)");return!0});class f{static BASE=new f(s.Gx,s.Gy,yc,l(s.Gx*s.Gy));static ZERO=new f(gc,yc,yc,gc);static Fp=r;static Fn=i;X;Y;Z;T;constructor(e,t,n,r){this.X=h("x",e),this.Y=h("y",t),this.Z=h("z",n,!0),this.T=h("t",r),Object.freeze(this)}static CURVE(){return s}static fromAffine(e){if(e instanceof f)throw Error("extended point not allowed");const{x:t,y:n}=e||{};return h("x",t),h("y",n),new f(t,n,yc,l(t*n))}static fromBytes(e,t=!1){const n=r.BYTES,{a:i,d:o}=s;e=Sl(pa(e,n,"point")),gl(t,"zip215");const h=Sl(e),u=e[n-1];h[n-1]=-129&u;const d=xl(h),p=t?a:r.ORDER;Al("point.y",d,gc,p);const m=l(d*d),g=l(m-yc),y=l(o*m-i);let{isValid:b,value:v}=c(g,y);if(!b)throw Error("bad point: invalid y coordinate");const w=(v&yc)===yc,x=!!(128&u);if(!t&&v===gc&&x)throw Error("bad point: x=0 and x_0=1");return x!==w&&(v=l(-v)),f.fromAffine({x:v,y:d})}static fromHex(e,t=!1){return f.fromBytes(Ia(e),t)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return m.createCache(this,e),t||this.multiply(bc),this}assertValidity(){p(this)}equals(e){u(e);const{X:t,Y:n,Z:r}=this,{X:i,Y:s,Z:o}=e,a=l(t*o),c=l(i*r),h=l(n*o),d=l(s*r);return a===c&&h===d}is0(){return this.equals(f.ZERO)}negate(){return new f(l(-this.X),this.Y,this.Z,l(-this.T))}double(){const{a:e}=s,{X:t,Y:n,Z:r}=this,i=l(t*t),o=l(n*n),a=l(bc*l(r*r)),c=l(e*i),h=t+n,u=l(l(h*h)-i-o),d=c+o,p=d-a,m=c-o,g=l(u*p),y=l(d*m),b=l(u*m),v=l(p*d);return new f(g,y,v,b)}add(e){u(e);const{a:t,d:n}=s,{X:r,Y:i,Z:o,T:a}=this,{X:c,Y:h,Z:d,T:p}=e,m=l(r*c),g=l(i*h),y=l(a*n*p),b=l(o*d),v=l((r+i)*(c+h)-m-g),w=b-y,x=b+y,_=l(g-t*m),E=l(v*w),S=l(x*_),M=l(v*_),A=l(w*x);return new f(E,S,A,M)}subtract(e){return this.add(e.negate())}multiply(e){if(!i.isValidNot0(e))throw Error("invalid scalar: expected 1 <= sc < curve.n");const{p:t,f:n}=m.cached(this,e,e=>ic(f,e));return ic(f,[t,n])[0]}multiplyUnsafe(e,t=f.ZERO){if(!i.isValid(e))throw Error("invalid scalar: expected 0 <= sc < curve.n");return e===gc?f.ZERO:this.is0()||e===yc?this:m.unsafe(this,e,e=>ic(f,e),t)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return m.unsafe(this,s.n).is0()}toAffine(e){return d(this,e)}clearCofactor(){return o===yc?this:this.multiplyUnsafe(o)}toBytes(){const{x:e,y:t}=this.toAffine(),n=r.toBytes(t);return n[n.length-1]|=e&yc?128:0,n}toHex(){return xa(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const m=new dc(f,i.BITS);return f.BASE.precompute(8),f}function xc(e,t,n={}){if("function"!=typeof t)throw Error('"hash" function param is required');Tl(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:i,Fp:s,Fn:o}=e,a=n.randomBytes||Ra,l=n.adjustScalarBytes||(e=>e),c=n.domain||((e,t,n)=>{if(gl(n,"phflag"),t.length||n)throw Error("Contexts/pre-hash are not supported");return e});function h(e){return o.create(xl(e))}function u(e){const{head:n,prefix:r,scalar:s}=function(e){const n=g.secretKey;pa(e,g.secretKey,"secretKey");const r=pa(t(e),2*n,"hashedSecretKey"),i=l(r.slice(0,n));return{head:i,prefix:r.slice(n,2*n),scalar:h(i)}}(e),o=i.multiply(s),a=o.toBytes();return{head:n,prefix:r,scalar:s,point:o,pointBytes:a}}function d(e){return u(e).pointBytes}function p(e=Uint8Array.of(),...n){const i=La(...n);return h(t(c(i,pa(e,void 0,"context"),!!r)))}const f={zip215:!0};const m=s.BYTES,g={secretKey:m,publicKey:m,signature:2*m,seed:m};function y(e=a(g.seed)){return pa(e,g.seed,"seed")}const b={getExtendedPublicKey:u,randomSecretKey:y,isValidSecretKey(e){return ua(e)&&e.length===o.BYTES},isValidPublicKey(t,n){try{return!!e.fromBytes(t,n)}catch(e){return!1}},toMontgomery(t){const{y:n}=e.fromBytes(t),r=g.publicKey,i=32===r;if(!i&&57!==r)throw Error("only defined for 25519 and 448");const o=i?s.div(yc+n,yc-n):s.div(n-yc,n+yc);return s.toBytes(o)},toMontgomerySecret(e){const n=g.secretKey;pa(e,n);const r=t(e.subarray(0,n));return l(r).subarray(0,n)}};return Object.freeze({keygen:mc(y,d),getPublicKey:d,sign(e,t,n={}){e=pa(e,void 0,"message"),r&&(e=r(e));const{prefix:s,scalar:a,pointBytes:l}=u(t),c=p(n.context,s,e),h=i.multiply(c).toBytes(),d=p(n.context,h,l,e),f=o.create(c+d*a);if(!o.isValid(f))throw Error("sign failed: invalid s");return pa(La(h,o.toBytes(f)),g.signature,"result")},verify(t,n,s,o=f){const{context:a,zip215:l}=o,c=g.signature;t=pa(t,c,"signature"),n=pa(n,void 0,"message"),s=pa(s,g.publicKey,"publicKey"),void 0!==l&&gl(l,"zip215"),r&&(n=r(n));const h=c/2,u=t.subarray(0,h),d=xl(t.subarray(h,c));let m,y,b;try{m=e.fromBytes(s,l),y=e.fromBytes(u,l),b=i.multiplyUnsafe(d)}catch(e){return!1}if(!l&&m.isSmallOrder())return!1;const v=p(a,y.toBytes(),m.toBytes(),n);return y.add(m.multiplyUnsafe(v)).subtract(b).clearCofactor().is0()},utils:b,Point:e,lengths:g})}const _c=BigInt(1),Ec=BigInt(2),Sc=BigInt(5),Mc=BigInt(8),Ac=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Cc=(()=>({p:Ac,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Mc,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function Tc(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Ic=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");const Lc=wc(Cc,{uvRatio(e,t){const n=Ac,r=Ul(t*t*t,n),i=function(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),i=BigInt(80),s=Ac,o=e*e%s*e%s,a=Hl(o,Ec,s)*o%s,l=Hl(a,_c,s)*e%s,c=Hl(l,Sc,s)*l%s,h=Hl(c,t,s)*c%s,u=Hl(h,n,s)*h%s,d=Hl(u,r,s)*u%s,p=Hl(d,i,s)*d%s,f=Hl(p,i,s)*d%s,m=Hl(f,t,s)*c%s;return{pow_p_5_8:Hl(m,Ec,s)*e%s,b2:o}}(e*Ul(r*r*t,n)).pow_p_5_8;let s=Ul(e*r*i,n);const o=Ul(t*s*s,n),a=s,l=Ul(s*Ic,n),c=o===e,h=o===Ul(-e,n),u=o===Ul(-e*Ic,n);return c&&(s=a),(h||u)&&(s=l),(Ul(s,n)&Pl)===Pl&&(s=Ul(-s,n)),{isValid:c||h,value:s}}});function Pc(e){return xc(Lc,pl,Object.assign({adjustScalarBytes:Tc},e))}const Rc=Pc({});class Dc extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class kc extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}var Nc={get(e=globalThis){const t=e.crypto;if(null==t?.subtle)throw new kc("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};let Fc;const Oc=(async()=>{try{return await Nc.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Bc(){const e=Rc.utils.randomSecretKey(),t=Rc.getPublicKey(e),n=function(e,t){const n=new Uint8Array(64);for(let r=0;r<32;r++)n[r]=e[r],n[32+r]=t[r];return n}(e,t);return{privateKey:n,publicKey:t}}async function zc(e,t){return null==Fc&&(Fc=await Oc),Fc?async function(e,t){let n;n=64===e.length?e.subarray(0,32):e;const r={crv:"Ed25519",kty:"OKP",x:Pn(e.subarray(32),"base64url"),d:Pn(n,"base64url"),ext:!0,key_ops:["sign"]},i=await Nc.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),s=await Nc.get().subtle.sign({name:"Ed25519"},i,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(s,0,s.byteLength)}(e,t):function(e,t){const n=e.subarray(0,32);return Rc.sign(t instanceof Uint8Array?t:t.subarray(),n)}(e,t)}async function Uc(e,t,n){return null==Fc&&(Fc=await Oc),Fc?async function(e,t,n){if(e.buffer instanceof ArrayBuffer){const r=await Nc.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await Nc.get().subtle.verify({name:"Ed25519"},r,t,n instanceof Uint8Array?n:n.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}(e,t,n):function(e,t,n){return Rc.verify(t,n instanceof Uint8Array?n:n.subarray(),e)}(e,t,n)}function Hc(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}class qc{type="Ed25519";raw;constructor(e){this.raw=Wc(e,32)}toMultihash(){return Ue.digest(Ah(this))}toCID(){return $e.createV1(114,this.toMultihash())}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&fr(this.raw,e.raw)}verify(e,t,n){n?.signal?.throwIfAborted();const r=Uc(this.raw,t,e);return Hc(r)?r.then(e=>(n?.signal?.throwIfAborted(),e)):r}}class Vc{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Wc(e,64),this.publicKey=new qc(t)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&fr(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const n=zc(this.raw,e);return Hc(n)?n.then(e=>(t?.signal?.throwIfAborted(),e)):(t?.signal?.throwIfAborted(),n)}}function Gc(e){return e=Wc(e,32),new qc(e)}function Wc(e,t){if((e=Uint8Array.from(e??[])).length!==t)throw new Ho(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}var jc,$c,Kc,Xc;function Yc(e){if(isNaN(e)||e<=0)throw new Ho("random bytes length must be a Number bigger than 0");return Ra(e)}(e=>{e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(jc||(jc={})),(e=>{e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})($c||($c={})),(e=>{e.codec=()=>Zt($c)})(jc||(jc={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),jc.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=jc.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Kc||(Kc={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),jc.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=jc.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Xc||(Xc={}));class Zc{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return null==this._raw&&(this._raw=function(e){if(null==e.n||null==e.e)throw new Ho("JWK was missing components");return ea([Jc,Qo(ea([Jo(rt(e.n,"base64url")),Jo(rt(e.e,"base64url"))]))]).subarray()}(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return $e.createV1(114,this._multihash)}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&fr(this.raw,e.raw)}verify(e,t,n){return async function(e,t,n,r){const i=await Nc.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const s=await Nc.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,t,n instanceof Uint8Array?n:n.subarray());return r?.signal?.throwIfAborted(),s}(this.jwk,t,e,n)}}const Jc=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Qc(e,t,n){const r=function(e){const t=Ko(e[1],{offset:0});return{kty:"RSA",n:Pn(t[0],"base64url"),e:Pn(t[1],"base64url")}}(e);if(null==n){n=Fe(18,dl(Kc.encode({Type:jc.RSA,Data:t})))}return new Zc(r,n)}class eh{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,t){if(fa(e),pa(t,void 0,"key"),this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,r=new Uint8Array(n);r.set(t.length>n?e.create().update(t).digest():t);for(let e=0;e<r.length;e++)r[e]^=54;this.iHash.update(r),this.oHash=e.create();for(let e=0;e<r.length;e++)r[e]^=106;this.oHash.update(r),ga(r)}update(e){return ma(this),this.iHash.update(e),this}digestInto(e){ma(this),pa(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});const{oHash:t,iHash:n,finished:r,destroyed:i,blockLen:s,outputLen:o}=this;return e.finished=r,e.destroyed=i,e.blockLen=s,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const th=(e,t,n)=>new eh(e,t).update(n).digest();th.create=(e,t)=>new eh(e,t);const nh=(e,t)=>(e+(e>=0?t:-t)/ch)/t;function rh(e,t,n){const[[r,i],[s,o]]=t,a=nh(o*e,n),l=nh(-i*e,n);let c=e-a*r-l*s,h=-a*i-l*o;const u=c<ah,d=h<ah;u&&(c=-c),d&&(h=-h);const p=Cl(Math.ceil(function(e){let t;for(t=0;e>fl;e>>=ml,t+=1);return t}(n)/2))+lh;if(c<ah||c>=p||h<ah||h>=p)throw Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:u,k1:c,k2neg:d,k2:h}}function ih(e){if(!["compact","recovered","der"].includes(e))throw Error('Signature format must be "compact", "recovered", or "der"');return e}function sh(e,t){const n={};for(let r of Object.keys(t))n[r]=void 0===e[r]?t[r]:e[r];return gl(n.lowS,"lowS"),gl(n.prehash,"prehash"),void 0!==n.format&&ih(n.format),n}const oh={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode(e,t){const{Err:n}=oh;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const r=t.length/2,i=bl(r);if(i.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?bl(i.length/2|128):"";return bl(e)+s+i+t},decode(e,t){const{Err:n}=oh;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const i=t[r++];let s=0;if(!!(128&i)){const e=127&i;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const o=t.subarray(r,r+e);if(o.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===o[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of o)s=s<<8|e;if(r+=e,s<128)throw new n("tlv.decode(long): not minimal encoding")}else s=i;const o=t.subarray(r,r+s);if(o.length!==s)throw new n("tlv.decode: wrong value length");return{v:o,l:t.subarray(r+s)}}},_int:{encode(e){const{Err:t}=oh;if(e<ah)throw new t("integer: negative integers are not allowed");let n=bl(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=oh;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return wl(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=oh,i=pa(e,void 0,"signature"),{v:s,l:o}=r.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l}=r.decode(2,s),{v:c,l:h}=r.decode(2,l);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(c)}},hexFromSig(e){const{_tlv:t,_int:n}=oh,r=t.encode(2,n.encode(e.r))+t.encode(2,n.encode(e.s));return t.encode(48,r)}},ah=BigInt(0),lh=BigInt(1),ch=BigInt(2),hh=BigInt(3),uh=BigInt(4);function dh(e,t={}){const n=fc("weierstrass",e,t),{Fp:r,Fn:i}=n;let s=n.CURVE;const{h:o,n:a}=s;Tl(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:l}=t;if(l&&(!r.is0(s.a)||"bigint"!=typeof l.beta||!Array.isArray(l.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const c=fh(r,i);function h(){if(!r.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const u=t.toBytes||function(e,t,n){const{x:i,y:s}=t.toAffine(),o=r.toBytes(i);if(gl(n,"isCompressed"),n){h();return La(ph(!r.isOdd(s)),o)}return La(Uint8Array.of(4),o,r.toBytes(s))},d=t.fromBytes||function(e){pa(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:n}=c,i=e.length,s=e[0],o=e.subarray(1);if(i!==t||2!==s&&3!==s){if(i===n&&4===s){const e=r.BYTES,t=r.fromBytes(o.subarray(0,e)),n=r.fromBytes(o.subarray(e,2*e));if(!f(t,n))throw Error("bad point: is not on curve");return{x:t,y:n}}throw Error(`bad point: got length ${i}, expected compressed=${t} or uncompressed=${n}`)}{const e=r.fromBytes(o);if(!r.isValid(e))throw Error("bad point: is not on curve, wrong x");const t=p(e);let n;try{n=r.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw Error("bad point: is not on curve, sqrt error"+t)}h();return!(1&~s)!==r.isOdd(n)&&(n=r.neg(n)),{x:e,y:n}}};function p(e){const t=r.sqr(e),n=r.mul(t,e);return r.add(r.add(n,r.mul(e,s.a)),s.b)}function f(e,t){const n=r.sqr(t),i=p(e);return r.eql(n,i)}if(!f(s.Gx,s.Gy))throw Error("bad curve params: generator point");const m=r.mul(r.pow(s.a,hh),uh),g=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(m,g)))throw Error("bad curve params: a or b");function y(e,t,n=!1){if(!r.isValid(t)||n&&r.is0(t))throw Error("bad point coordinate "+e);return t}function b(e){if(!(e instanceof E))throw Error("Weierstrass Point expected")}function v(e){if(!l||!l.basises)throw Error("no endo");return rh(e,l.basises,i.ORDER)}const w=Il((e,t)=>{const{X:n,Y:i,Z:s}=e;if(r.eql(s,r.ONE))return{x:n,y:i};const o=e.is0();null==t&&(t=o?r.ONE:r.inv(s));const a=r.mul(n,t),l=r.mul(i,t),c=r.mul(s,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw Error("invZ was invalid");return{x:a,y:l}}),x=Il(e=>{if(e.is0()){if(t.allowInfinityPoint&&!r.is0(e.Y))return;throw Error("bad point: ZERO")}const{x:n,y:i}=e.toAffine();if(!r.isValid(n)||!r.isValid(i))throw Error("bad point: x or y not field elements");if(!f(n,i))throw Error("bad point: equation left != right");if(!e.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function _(e,t,n,i,s){return n=new E(r.mul(n.X,e),n.Y,n.Z),t=rc(i,t),n=rc(s,n),t.add(n)}class E{static BASE=new E(s.Gx,s.Gy,r.ONE);static ZERO=new E(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=i;X;Y;Z;constructor(e,t,n){this.X=y("x",e),this.Y=y("y",t,!0),this.Z=y("z",n),Object.freeze(this)}static CURVE(){return s}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw Error("invalid affine point");if(e instanceof E)throw Error("projective point not allowed");return r.is0(t)&&r.is0(n)?E.ZERO:new E(t,n,r.ONE)}static fromBytes(e){const t=E.fromAffine(d(pa(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return E.fromBytes(Ia(e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return M.createCache(this,e),t||this.multiply(hh),this}assertValidity(){x(this)}hasEvenY(){const{y:e}=this.toAffine();if(!r.isOdd)throw Error("Field doesn't support isOdd");return!r.isOdd(e)}equals(e){b(e);const{X:t,Y:n,Z:i}=this,{X:s,Y:o,Z:a}=e,l=r.eql(r.mul(t,a),r.mul(s,i)),c=r.eql(r.mul(n,a),r.mul(o,i));return l&&c}negate(){return new E(this.X,r.neg(this.Y),this.Z)}double(){const{a:e,b:t}=s,n=r.mul(t,hh),{X:i,Y:o,Z:a}=this;let l=r.ZERO,c=r.ZERO,h=r.ZERO,u=r.mul(i,i),d=r.mul(o,o),p=r.mul(a,a),f=r.mul(i,o);return f=r.add(f,f),h=r.mul(i,a),h=r.add(h,h),l=r.mul(e,h),c=r.mul(n,p),c=r.add(l,c),l=r.sub(d,c),c=r.add(d,c),c=r.mul(l,c),l=r.mul(f,l),h=r.mul(n,h),p=r.mul(e,p),f=r.sub(u,p),f=r.mul(e,f),f=r.add(f,h),h=r.add(u,u),u=r.add(h,u),u=r.add(u,p),u=r.mul(u,f),c=r.add(c,u),p=r.mul(o,a),p=r.add(p,p),u=r.mul(p,f),l=r.sub(l,u),h=r.mul(p,d),h=r.add(h,h),h=r.add(h,h),new E(l,c,h)}add(e){b(e);const{X:t,Y:n,Z:i}=this,{X:o,Y:a,Z:l}=e;let c=r.ZERO,h=r.ZERO,u=r.ZERO;const d=s.a,p=r.mul(s.b,hh);let f=r.mul(t,o),m=r.mul(n,a),g=r.mul(i,l),y=r.add(t,n),v=r.add(o,a);y=r.mul(y,v),v=r.add(f,m),y=r.sub(y,v),v=r.add(t,i);let w=r.add(o,l);return v=r.mul(v,w),w=r.add(f,g),v=r.sub(v,w),w=r.add(n,i),c=r.add(a,l),w=r.mul(w,c),c=r.add(m,g),w=r.sub(w,c),u=r.mul(d,v),c=r.mul(p,g),u=r.add(c,u),c=r.sub(m,u),u=r.add(m,u),h=r.mul(c,u),m=r.add(f,f),m=r.add(m,f),g=r.mul(d,g),v=r.mul(p,v),m=r.add(m,g),g=r.sub(f,g),g=r.mul(d,g),v=r.add(v,g),f=r.mul(m,v),h=r.add(h,f),f=r.mul(w,v),c=r.mul(y,c),c=r.sub(c,f),f=r.mul(y,m),u=r.mul(w,u),u=r.add(u,f),new E(c,h,u)}subtract(e){return this.add(e.negate())}is0(){return this.equals(E.ZERO)}multiply(e){const{endo:n}=t;if(!i.isValidNot0(e))throw Error("invalid scalar: out of range");let r,s;const o=e=>M.cached(this,e,e=>ic(E,e));if(n){const{k1neg:t,k1:i,k2neg:a,k2:l}=v(e),{p:c,f:h}=o(i),{p:u,f:d}=o(l);s=h.add(d),r=_(n.beta,c,u,t,a)}else{const{p:t,f:n}=o(e);r=t,s=n}return ic(E,[r,s])[0]}multiplyUnsafe(e){const{endo:n}=t,r=this;if(!i.isValid(e))throw Error("invalid scalar: out of range");if(e===ah||r.is0())return E.ZERO;if(e===lh)return r;if(M.hasCache(this))return this.multiply(e);if(n){const{k1neg:t,k1:i,k2neg:s,k2:o}=v(e),{p1:a,p2:l}=function(e,t,n,r){let i=t,s=e.ZERO,o=e.ZERO;for(;n>tc||r>tc;)n&nc&&(s=s.add(i)),r&nc&&(o=o.add(i)),i=i.double(),n>>=nc,r>>=nc;return{p1:s,p2:o}}(E,r,i,o);return _(n.beta,a,l,t,s)}return M.unsafe(r,e)}toAffine(e){return w(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return o===lh||(e?e(E,this):M.unsafe(this,a).is0())}clearCofactor(){const{clearCofactor:e}=t;return o===lh?this:e?e(E,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(e=!0){return gl(e,"isCompressed"),this.assertValidity(),u(E,this,e)}toHex(e=!0){return xa(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const S=i.BITS,M=new dc(E,t.endo?Math.ceil(S/2):S);return E.BASE.precompute(8),E}function ph(e){return Uint8Array.of(e?2:3)}function fh(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function mh(e,t={}){const{Fn:n}=e,r=t.randomBytes||Ra,i=Object.assign(fh(e.Fp,n),{seed:ec(n.ORDER)});function s(e=r(i.seed)){return function(e,t,n=!1){pa(e);const r=e.length,i=Ql(t),s=ec(t);if(r<16||r<s||r>1024)throw Error("expected "+s+"-1024 bytes of input, got "+r);const o=Ul(n?xl(e):wl(e),t-Pl)+Pl;return n?El(o,i):_l(o,i)}(pa(e,i.seed,"seed"),n.ORDER)}function o(t,r=!0){return e.BASE.multiply(n.fromBytes(t)).toBytes(r)}function a(e){const{secretKey:t,publicKey:r,publicKeyUncompressed:s}=i;if(!ua(e))return;if("_lengths"in n&&n._lengths||t===r)return;const o=pa(e,void 0,"key").length;return o===r||o===s}const l={isValidSecretKey(e){try{const t=n.fromBytes(e);return n.isValidNot0(t)}catch(e){return!1}},isValidPublicKey(t,n){const{publicKey:r,publicKeyUncompressed:s}=i;try{const i=t.length;return(!0!==n||i===r)&&((!1!==n||i===s)&&!!e.fromBytes(t))}catch(e){return!1}},randomSecretKey:s},c=mc(s,o);return Object.freeze({getPublicKey:o,getSharedSecret(t,r,i=!0){if(!0===a(t))throw Error("first arg must be private key");if(!1===a(r))throw Error("second arg must be public key");const s=n.fromBytes(t);return e.fromBytes(r).multiply(s).toBytes(i)},keygen:c,Point:e,utils:l,lengths:i})}function gh(e,t,n={}){fa(t),Tl(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=(n=Object.assign({},n)).randomBytes||Ra,i=n.hmac||((e,n)=>th(t,e,n)),{Fp:s,Fn:o}=e,{ORDER:a,BITS:l}=o,{keygen:c,getPublicKey:h,getSharedSecret:u,utils:d,lengths:p}=mh(e,n),f={prehash:!0,lowS:"boolean"!=typeof n.lowS||n.lowS,format:"compact",extraEntropy:!1},m=a*ch<s.ORDER;function g(e){return e>a>>lh}function y(e,t){if(!o.isValidNot0(t))throw Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}function b(){if(m)throw Error('"recovered" sig type is not supported for cofactor >2 curves')}function v(e,t){ih(t);const n=p.signature;return pa(e,"compact"===t?n:"recovered"===t?n+1:void 0)}class w{r;s;recovery;constructor(e,t,n){if(this.r=y("r",e),this.s=y("s",t),null!=n){if(b(),![0,1,2,3].includes(n))throw Error("invalid recovery id");this.recovery=n}Object.freeze(this)}static fromBytes(e,t=f.format){let n;if(v(e,t),"der"===t){const{r:t,s:n}=oh.toSig(pa(e));return new w(t,n)}"recovered"===t&&(n=e[0],t="compact",e=e.subarray(1));const r=p.signature/2,i=e.subarray(0,r),s=e.subarray(r,2*r);return new w(o.fromBytes(i),o.fromBytes(s),n)}static fromHex(e,t){return this.fromBytes(Ia(e),t)}assertRecovery(){const{recovery:e}=this;if(null==e)throw Error("invalid recovery id: must be present");return e}addRecoveryBit(e){return new w(this.r,this.s,e)}recoverPublicKey(t){const{r:n,s:r}=this,i=this.assertRecovery(),l=2===i||3===i?n+a:n;if(!s.isValid(l))throw Error("invalid recovery id: sig.r+curve.n != R.x");const c=s.toBytes(l),h=e.fromBytes(La(ph(!(1&i)),c)),u=o.inv(l),d=_(pa(t,void 0,"msgHash")),p=o.create(-d*u),f=o.create(r*u),m=e.BASE.multiplyUnsafe(p).add(h.multiplyUnsafe(f));if(m.is0())throw Error("invalid recovery: point at infinify");return m.assertValidity(),m}hasHighS(){return g(this.s)}toBytes(e=f.format){if(ih(e),"der"===e)return Ia(oh.hexFromSig(this));const{r:t,s:n}=this,r=o.toBytes(t),i=o.toBytes(n);return"recovered"===e?(b(),La(Uint8Array.of(this.assertRecovery()),r,i)):La(r,i)}toHex(e){return xa(this.toBytes(e))}}const x=n.bits2int||function(e){if(e.length>8192)throw Error("input is too large");const t=wl(e),n=8*e.length-l;return n>0?t>>BigInt(n):t},_=n.bits2int_modN||function(e){return o.create(x(e))},E=Cl(l);function S(e){return Al("num < 2^"+l,e,ah,E),o.toBytes(e)}function M(e,n){return pa(e,void 0,"message"),n?pa(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:c,getPublicKey:h,getSharedSecret:u,utils:d,lengths:p,Point:e,sign(n,s,a={}){const{seed:l,k2sig:c}=function(t,n,i){const{lowS:s,prehash:a,extraEntropy:l}=sh(i,f);t=M(t,a);const c=_(t),h=o.fromBytes(n);if(!o.isValidNot0(h))throw Error("invalid private key");const u=[S(h),S(c)];if(null!=l&&!1!==l){const e=!0===l?r(p.secretKey):l;u.push(pa(e,void 0,"extraEntropy"))}const d=La(...u),y=c;return{seed:d,k2sig(t){const n=x(t);if(!o.isValidNot0(n))return;const r=o.inv(n),i=e.BASE.multiply(n).toAffine(),a=o.create(i.x);if(a===ah)return;const l=o.create(r*o.create(y+a*h));if(l===ah)return;let c=(i.x===a?0:2)|Number(i.y&lh),u=l;return s&&g(l)&&(u=o.neg(l),c^=1),new w(a,u,m?void 0:c)}}}(n,s,a),h=function(e,t,n){if(da(e,"hashLen"),da(t,"qByteLen"),"function"!=typeof n)throw Error("hmacFn must be a function");const r=e=>new Uint8Array(e),i=Uint8Array.of(),s=Uint8Array.of(0),o=Uint8Array.of(1);let a=r(e),l=r(e),c=0;const h=()=>{a.fill(1),l.fill(0),c=0},u=(...e)=>n(l,La(a,...e)),d=(e=i)=>{l=u(s,e),a=u(),0!==e.length&&(l=u(o,e),a=u())},p=()=>{if(c++>=1e3)throw Error("drbg: tried max amount of iterations");let e=0;const n=[];for(;e<t;){a=u();const t=a.slice();n.push(t),e+=a.length}return La(...n)};return(e,t)=>{let n;for(h(),d(e);!(n=t(p()));)d();return h(),n}}(t.outputLen,o.BYTES,i);return h(l,c).toBytes(a.format)},verify(t,n,r,i={}){const{lowS:s,prehash:a,format:l}=sh(i,f);if(r=pa(r,void 0,"publicKey"),n=M(n,a),!ua(t)){throw Error("verify expects Uint8Array signature"+(t instanceof w?", use sig.toBytes()":""))}v(t,l);try{const i=w.fromBytes(t,l),a=e.fromBytes(r);if(s&&i.hasHighS())return!1;const{r:c,s:h}=i,u=_(n),d=o.inv(h),p=o.create(u*d),f=o.create(c*d),m=e.BASE.multiplyUnsafe(p).add(a.multiplyUnsafe(f));if(m.is0())return!1;return o.create(m.x)===c}catch(e){return!1}},recoverPublicKey(e,t,n={}){const{prehash:r}=sh(n,f);return t=M(t,r),w.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:w,hash:t})}const yh={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},bh={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},vh=BigInt(2);const wh=Jl(yh.p,{sqrt(e){const t=yh.p,n=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),l=BigInt(88),c=e*e*e%t,h=c*c*e%t,u=Hl(h,n,t)*h%t,d=Hl(u,n,t)*h%t,p=Hl(d,vh,t)*c%t,f=Hl(p,i,t)*p%t,m=Hl(f,s,t)*f%t,g=Hl(m,a,t)*m%t,y=Hl(g,l,t)*g%t,b=Hl(y,a,t)*m%t,v=Hl(b,n,t)*h%t,w=Hl(v,o,t)*f%t,x=Hl(w,r,t)*c%t,_=Hl(x,vh,t);if(!wh.eql(wh.sqr(_),e))throw Error("Cannot find square root");return _}}),xh=gh(dh(yh,{Fp:wh,endo:bh}),dl);class _h{type="secp256k1";raw;_key;constructor(e){this._key=function(e){try{return xh.Point.fromBytes(e),e}catch(e){throw new qo(e+"")}}(e),this.raw=function(e){return xh.Point.fromBytes(e).toBytes()}(this._key)}toMultihash(){return Ue.digest(Ah(this))}toCID(){return $e.createV1(114,this.toMultihash())}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&fr(this.raw,e.raw)}verify(e,t,n){return function(e,t,n,r){const i=Ve.digest(n instanceof Uint8Array?n:n.subarray());if(Hc(i))return i.then(({digest:n})=>(r?.signal?.throwIfAborted(),xh.verify(t,n,e,{prehash:!1,format:"der"}))).catch(e=>{if("AbortError"===e.name)throw e;throw new Dc(e+"")});try{return r?.signal?.throwIfAborted(),xh.verify(t,i.digest,e,{prehash:!1,format:"der"})}catch(e){throw new Dc(e+"")}}(this._key,t,e,n)}}function Eh(e){return new _h(e)}async function Sh(){return async function(){const{privateKey:e,publicKey:t}=Bc();return new Vc(e,t)}()}function Mh(e,t){const{Type:n,Data:r}=Kc.decode(e),i=r??new Uint8Array;switch(n){case jc.RSA:return function(e,t){if(e.byteLength>=1062)throw new qo("Key size is too large");return Qc(Ko(e,{offset:0}),e,t)}(i,t);case jc.Ed25519:return Gc(i);case jc.secp256k1:return Eh(i);case jc.ECDSA:return aa(i);default:throw new Vo}}function Ah(e){return Kc.encode({Type:jc[e.type],Data:e.raw})}class Ch extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}const Th=Symbol.for("@libp2p/service-capabilities"),Ih=Symbol.for("@libp2p/peer-id");let Lh=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class Ph extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class Rh extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class Dh extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}const kh=Symbol.for("nodejs.util.inspect.custom");class Nh{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Ih]=!0;toString(){return null==this.string&&(this.string=ue.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return $e.createV1(114,this.multihash)}toJSON(){return this.toString()}equals(e){if(null==e)return!1;if(e instanceof Uint8Array)return fr(this.multihash.bytes,e);if("string"==typeof e)return this.toString()===e;if(null!=e?.toMultihash()?.bytes)return fr(this.multihash.bytes,e.toMultihash().bytes);throw Error("not valid Id")}[kh](){return`PeerId(${this.toString()})`}}class Fh extends Nh{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class Oh extends Nh{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class Bh extends Nh{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}class zh{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=Ue.digest(rt(this.url))}[kh](){return`PeerId(${this.url})`}[Ih]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return $e.createV1(2336,this.toMultihash())}toJSON(){return this.toString()}equals(e){return null!=e&&(e instanceof Uint8Array&&(e=Pn(e)),e.toString()===this.toString())}}function Uh(e){let t;if("1"!==e.charAt(0)&&"Q"!==e.charAt(0)){if(e.startsWith("k51qzi5uqu5")||e.startsWith("kzwfwjn5ji4")||e.startsWith("k2k4r8")||e.startsWith("bafz"))return Vh($e.parse(e));throw new Lh('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return t=Oe(ue.decode("z"+e)),qh(t)}function Hh(e){if("Ed25519"===e.type)return new Oh({multihash:e.toCID().multihash,publicKey:e});if("secp256k1"===e.type)return new Bh({multihash:e.toCID().multihash,publicKey:e});if("RSA"===e.type)return new Fh({multihash:e.toCID().multihash,publicKey:e});throw new Dh}function qh(e){if(function(e){return e.code===Ve.code}(e))return new Fh({multihash:e});if(function(e){return e.code===Ue.code}(e))try{const t=function(e){const{Type:t,Data:n}=Kc.decode(e.digest),r=n??new Uint8Array;switch(t){case jc.Ed25519:return Gc(r);case jc.secp256k1:return Eh(r);case jc.ECDSA:return aa(r);default:throw new Vo}}(e);if("Ed25519"===t.type)return new Oh({multihash:e,publicKey:t});if("secp256k1"===t.type)return new Bh({multihash:e,publicKey:t})}catch(t){const n=Pn(e.digest);return new zh(new URL(n))}throw new Rh("Supplied PeerID Multihash is invalid")}function Vh(e){if(null==e?.multihash||null==e.version||1===e.version&&114!==e.code&&2336!==e.code)throw new Ph("Supplied PeerID CID is invalid");if(2336===e.code){const t=Pn(e.multihash.digest);return new zh(new URL(t))}return qh(e.multihash)}let Gh=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=Ir(),this.haveNext=Ir()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Ir(),e}async throw(e){this.ended=!0,null!=e&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Ir(),await Nr(this.readNext.promise,t?.signal,t)}};let Wh=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};class jh extends Error{code;constructor(e,t){super(e),this.code=t}}let $h=class extends jh{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function Kh(e,t){const n=new Gh;e.sink(n).catch(async e=>{await n.end(e)}),e.sink=async e=>{for await(const t of e)await n.push(t);await n.end()};let r=e.source;null!=e.source[Symbol.iterator]?r=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(r=e.source[Symbol.asyncIterator]());const i=new br,s={async read(e,t){let n;t?.signal?.throwIfAborted();const s=new Promise((e,r)=>{n=()=>{r(new $h("Read aborted"))},t?.signal?.addEventListener("abort",n)});try{if(null==e){const{done:e,value:t}=await Promise.race([r.next(),s]);return!0===e?new br:t}for(;i.byteLength<e;){const{value:e,done:t}=await Promise.race([r.next(),s]);if(!0===t)throw new Wh("unexpected end of input");i.append(e)}const t=i.sublist(0,e);return i.consume(e),t}finally{null!=n&&t?.signal?.removeEventListener("abort",n)}},async write(e,t){t?.signal?.throwIfAborted(),e instanceof Uint8Array?await n.push(e,t):await n.push(e.subarray(),t)},unwrap(){if(i.byteLength>0){const n=e.source;e.source=async function*(){!1===t?.yieldBytes?yield i:yield*i,yield*n}()}return e}};return s}let Xh=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Yh=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Zh=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"};function Jh(e,t={}){const n=Kh(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=l(t.maxDataLength));const r=t?.lengthDecoder??d,i=t?.lengthEncoder??u;return{async read(e){let i=-1;const s=new br;for(;;){s.append(await n.read(1,e));try{i=r(s)}catch(e){if(e instanceof RangeError)continue;throw e}if(i<0)throw new Xh("Invalid message length");if(null!=t?.maxLengthLength&&s.byteLength>t.maxLengthLength)throw new Zh("message length length too long");if(i>-1)break}if(null!=t?.maxDataLength&&i>t.maxDataLength)throw new Yh("message length too long");return n.read(i,e)},async write(e,t){await n.write(new br(i(e.byteLength),e),t)},async writeV(e,t){const r=new br(...e.flatMap(e=>[i(e.byteLength),e]));await n.write(r,t)},unwrap(){return n.unwrap()}}}function Qh(){const e=Ir();let t=!1;return{async sink(n){if(t)throw Error("already piped");t=!0,e.resolve(n)},source:async function*(){const t=await e.promise;yield*t}()}}const eu=65535,tu=!!globalThis.process?.env?.DUMP_SESSION_KEYS;function nu(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, not "+e)}function ru(e){if("boolean"!=typeof e)throw Error("boolean expected, not "+e)}function iu(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function su(e,...t){if(!iu(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function ou(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}const au=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4));if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw Error("Non little-endian hardware is not supported");function lu(e){if("string"==typeof e)e=function(e){if("string"!=typeof e)throw Error("string expected, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e);else{if(!iu(e))throw Error("Uint8Array expected, got "+typeof e);e=uu(e)}return e}const cu=(e,t)=>(Object.assign(t,e),t);function hu(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const i=BigInt(32),s=BigInt(4294967295),o=Number(n>>i&s),a=Number(n&s);e.setUint32(t+4,o,r),e.setUint32(t+0,a,r)}function uu(e){return Uint8Array.from(e)}function du(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const pu=e=>Uint8Array.from(e.split("").map(e=>e.charCodeAt(0))),fu=pu("expand 16-byte k"),mu=pu("expand 32-byte k"),gu=au(fu),yu=au(mu);function bu(e,t){return e<<t|e>>>32-t}function vu(e){return e.byteOffset%4==0}yu.slice();const wu=2**32-1,xu=new Uint32Array;function _u(e,t){const{allowShortKeys:n,extendNonceFn:r,counterLength:i,counterRight:s,rounds:o}=function(e,t){if(null==t||"object"!=typeof t)throw Error("options must be defined");return Object.assign(e,t)}({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if("function"!=typeof e)throw Error("core must be a function");return nu(i),nu(o),ru(s),ru(n),(t,a,l,c,h=0)=>{su(t),su(a),su(l);const u=l.length;if(void 0===c&&(c=new Uint8Array(u)),su(c),nu(h),h<0||h>=wu)throw Error("arx: counter overflow");if(c.length<u)throw Error(`arx: output (${c.length}) is shorter than data (${u})`);const d=[];let p,f,m=t.length;if(32===m)d.push(p=uu(t)),f=yu;else{if(16!==m||!n)throw Error("arx: invalid 32-byte key, got length="+m);p=new Uint8Array(32),p.set(t),p.set(t,16),f=gu,d.push(p)}vu(a)||d.push(a=uu(a));const g=au(p);if(r){if(24!==a.length)throw Error("arx: extended nonce must be 24 bytes");r(f,g,au(a.subarray(0,16)),g),a=a.subarray(16)}const y=16-i;if(y!==a.length)throw Error(`arx: nonce must be ${y} or 16 bytes`);if(12!==y){const e=new Uint8Array(12);e.set(a,s?0:12-a.length),a=e,d.push(a)}const b=au(a);return function(e,t,n,r,i,s,o,a){const l=i.length,c=new Uint8Array(64),h=au(c),u=vu(i)&&vu(s),d=u?au(i):xu,p=u?au(s):xu;for(let f=0;f<l;o++){if(e(t,n,r,h,o,a),o>=wu)throw Error("arx: counter overflow");const m=Math.min(64,l-f);if(u&&64===m){const e=f/4;if(f%4!=0)throw Error("arx: invalid block position");for(let t,n=0;n<16;n++)t=e+n,p[t]=d[t]^h[n];f+=64;continue}for(let e,t=0;t<m;t++)e=f+t,s[e]=i[e]^c[t];f+=m}}(e,f,g,b,l,c,h,o),du(...d),c}}const Eu=(e,t)=>255&e[t++]|(255&e[t++])<<8;class Su{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,su(e=lu(e),32);const t=Eu(e,0),n=Eu(e,2),r=Eu(e,4),i=Eu(e,6),s=Eu(e,8),o=Eu(e,10),a=Eu(e,12),l=Eu(e,14);this.r[0]=8191&t,this.r[1]=8191&(t>>>13|n<<3),this.r[2]=7939&(n>>>10|r<<6),this.r[3]=8191&(r>>>7|i<<9),this.r[4]=255&(i>>>4|s<<12),this.r[5]=s>>>1&8190,this.r[6]=8191&(s>>>14|o<<2),this.r[7]=8065&(o>>>11|a<<5),this.r[8]=8191&(a>>>8|l<<8),this.r[9]=l>>>5&127;for(let t=0;t<8;t++)this.pad[t]=Eu(e,16+2*t)}process(e,t,n=!1){const r=n?0:2048,{h:i,r:s}=this,o=s[0],a=s[1],l=s[2],c=s[3],h=s[4],u=s[5],d=s[6],p=s[7],f=s[8],m=s[9],g=Eu(e,t+0),y=Eu(e,t+2),b=Eu(e,t+4),v=Eu(e,t+6),w=Eu(e,t+8),x=Eu(e,t+10),_=Eu(e,t+12),E=Eu(e,t+14);let S=i[0]+(8191&g),M=i[1]+(8191&(g>>>13|y<<3)),A=i[2]+(8191&(y>>>10|b<<6)),C=i[3]+(8191&(b>>>7|v<<9)),T=i[4]+(8191&(v>>>4|w<<12)),I=i[5]+(w>>>1&8191),L=i[6]+(8191&(w>>>14|x<<2)),P=i[7]+(8191&(x>>>11|_<<5)),R=i[8]+(8191&(_>>>8|E<<8)),D=i[9]+(E>>>5|r),k=0,N=k+S*o+M*(5*m)+A*(5*f)+C*(5*p)+T*(5*d);k=N>>>13,N&=8191,N+=I*(5*u)+L*(5*h)+P*(5*c)+R*(5*l)+D*(5*a),k+=N>>>13,N&=8191;let F=k+S*a+M*o+A*(5*m)+C*(5*f)+T*(5*p);k=F>>>13,F&=8191,F+=I*(5*d)+L*(5*u)+P*(5*h)+R*(5*c)+D*(5*l),k+=F>>>13,F&=8191;let O=k+S*l+M*a+A*o+C*(5*m)+T*(5*f);k=O>>>13,O&=8191,O+=I*(5*p)+L*(5*d)+P*(5*u)+R*(5*h)+D*(5*c),k+=O>>>13,O&=8191;let B=k+S*c+M*l+A*a+C*o+T*(5*m);k=B>>>13,B&=8191,B+=I*(5*f)+L*(5*p)+P*(5*d)+R*(5*u)+D*(5*h),k+=B>>>13,B&=8191;let z=k+S*h+M*c+A*l+C*a+T*o;k=z>>>13,z&=8191,z+=I*(5*m)+L*(5*f)+P*(5*p)+R*(5*d)+D*(5*u),k+=z>>>13,z&=8191;let U=k+S*u+M*h+A*c+C*l+T*a;k=U>>>13,U&=8191,U+=I*o+L*(5*m)+P*(5*f)+R*(5*p)+D*(5*d),k+=U>>>13,U&=8191;let H=k+S*d+M*u+A*h+C*c+T*l;k=H>>>13,H&=8191,H+=I*a+L*o+P*(5*m)+R*(5*f)+D*(5*p),k+=H>>>13,H&=8191;let q=k+S*p+M*d+A*u+C*h+T*c;k=q>>>13,q&=8191,q+=I*l+L*a+P*o+R*(5*m)+D*(5*f),k+=q>>>13,q&=8191;let V=k+S*f+M*p+A*d+C*u+T*h;k=V>>>13,V&=8191,V+=I*c+L*l+P*a+R*o+D*(5*m),k+=V>>>13,V&=8191;let G=k+S*m+M*f+A*p+C*d+T*u;k=G>>>13,G&=8191,G+=I*h+L*c+P*l+R*a+D*o,k+=G>>>13,G&=8191,k=(k<<2)+k|0,k=k+N|0,N=8191&k,k>>>=13,F+=k,i[0]=N,i[1]=F,i[2]=O,i[3]=B,i[4]=z,i[5]=U,i[6]=H,i[7]=q,i[8]=V,i[9]=G}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let r=e[1]>>>13;e[1]&=8191;for(let t=2;t<10;t++)e[t]+=r,r=e[t]>>>13,e[t]&=8191;e[0]+=5*r,r=e[0]>>>13,e[0]&=8191,e[1]+=r,r=e[1]>>>13,e[1]&=8191,e[2]+=r,n[0]=e[0]+5,r=n[0]>>>13,n[0]&=8191;for(let t=1;t<10;t++)n[t]=e[t]+r,r=n[t]>>>13,n[t]&=8191;n[9]-=8192;let i=(1^r)-1;for(let e=0;e<10;e++)n[e]&=i;i=~i;for(let t=0;t<10;t++)e[t]=e[t]&i|n[t];e[0]=65535&(e[0]|e[1]<<13),e[1]=65535&(e[1]>>>3|e[2]<<10),e[2]=65535&(e[2]>>>6|e[3]<<7),e[3]=65535&(e[3]>>>9|e[4]<<4),e[4]=65535&(e[4]>>>12|e[5]<<1|e[6]<<14),e[5]=65535&(e[6]>>>2|e[7]<<11),e[6]=65535&(e[7]>>>5|e[8]<<8),e[7]=65535&(e[8]>>>8|e[9]<<5);let s=e[0]+t[0];e[0]=65535&s;for(let n=1;n<8;n++)s=(e[n]+t[n]|0)+(s>>>16)|0,e[n]=65535&s;du(n)}update(e){ou(this);const{buffer:t,blockLen:n}=this,r=(e=lu(e)).length;for(let i=0;i<r;){const s=Math.min(n-this.pos,r-i);if(s!==n)t.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(t,0,!1),this.pos=0);else for(;n<=r-i;i+=n)this.process(e,i)}return this}destroy(){du(this.h,this.r,this.buffer,this.pad)}digestInto(e){ou(this),function(e,t){su(e);const n=t.outputLen;if(e.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:r}=this;if(r){for(t[r++]=1;r<16;r++)t[r]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let t=0;t<8;t++)e[i++]=n[t]>>>0,e[i++]=n[t]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}const Mu=function(e){const t=(t,n)=>e(n).update(lu(t)).digest(),n=e(new Uint8Array(32));return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=t=>e(t),t}(e=>new Su(e));function Au(e,t,n,r,i,s=20){let o=e[0],a=e[1],l=e[2],c=e[3],h=t[0],u=t[1],d=t[2],p=t[3],f=t[4],m=t[5],g=t[6],y=t[7],b=i,v=n[0],w=n[1],x=n[2],_=o,E=a,S=l,M=c,A=h,C=u,T=d,I=p,L=f,P=m,R=g,D=y,k=b,N=v,F=w,O=x;for(let e=0;e<s;e+=2)_=_+A|0,k=bu(k^_,16),L=L+k|0,A=bu(A^L,12),_=_+A|0,k=bu(k^_,8),L=L+k|0,A=bu(A^L,7),E=E+C|0,N=bu(N^E,16),P=P+N|0,C=bu(C^P,12),E=E+C|0,N=bu(N^E,8),P=P+N|0,C=bu(C^P,7),S=S+T|0,F=bu(F^S,16),R=R+F|0,T=bu(T^R,12),S=S+T|0,F=bu(F^S,8),R=R+F|0,T=bu(T^R,7),M=M+I|0,O=bu(O^M,16),D=D+O|0,I=bu(I^D,12),M=M+I|0,O=bu(O^M,8),D=D+O|0,I=bu(I^D,7),_=_+C|0,O=bu(O^_,16),R=R+O|0,C=bu(C^R,12),_=_+C|0,O=bu(O^_,8),R=R+O|0,C=bu(C^R,7),E=E+T|0,k=bu(k^E,16),D=D+k|0,T=bu(T^D,12),E=E+T|0,k=bu(k^E,8),D=D+k|0,T=bu(T^D,7),S=S+I|0,N=bu(N^S,16),L=L+N|0,I=bu(I^L,12),S=S+I|0,N=bu(N^S,8),L=L+N|0,I=bu(I^L,7),M=M+A|0,F=bu(F^M,16),P=P+F|0,A=bu(A^P,12),M=M+A|0,F=bu(F^M,8),P=P+F|0,A=bu(A^P,7);let B=0;r[B++]=o+_|0,r[B++]=a+E|0,r[B++]=l+S|0,r[B++]=c+M|0,r[B++]=h+A|0,r[B++]=u+C|0,r[B++]=d+T|0,r[B++]=p+I|0,r[B++]=f+L|0,r[B++]=m+P|0,r[B++]=g+R|0,r[B++]=y+D|0,r[B++]=b+k|0,r[B++]=v+N|0,r[B++]=w+F|0,r[B++]=x+O|0}const Cu=_u(Au,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Tu=new Uint8Array(16),Iu=(e,t)=>{e.update(t);const n=t.length%16;n&&e.update(Tu.subarray(n))},Lu=new Uint8Array(32);function Pu(e,t,n,r,i){const s=e(t,n,Lu),o=Mu.create(s);i&&Iu(o,i),Iu(o,r);const a=new Uint8Array(16),l=(c=a,new DataView(c.buffer,c.byteOffset,c.byteLength));var c;hu(l,0,BigInt(i?i.length:0),!0),hu(l,8,BigInt(r.length),!0),o.update(a);const h=o.digest();return du(s,a),h}const Ru=cu({blockSize:64,nonceLength:12,tagLength:16},(Du=Cu,(e,t,n)=>{const r=16;return su(e,32),su(t),{encrypt(i,s){const o=i.length,a=o+r;s?su(s,a):s=new Uint8Array(a),Du(e,t,i,s,1);const l=Pu(Du,e,t,s.subarray(0,-16),n);return s.set(l,o),du(l),s},decrypt(i,s){const o=i.length,a=o-r;if(o<r)throw Error("encrypted data must be at least 16 bytes");s?su(s,a):s=new Uint8Array(a);const l=i.subarray(0,-16),c=i.subarray(-16),h=Pu(Du,e,t,l,n);if(!((e,t)=>{if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return 0===n})(c,h))throw Error("invalid tag");return Du(e,t,l,s,1),du(h),s}}}));var Du;const ku="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function Nu(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function Fu(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, got "+e)}function Ou(e,...t){if(!Nu(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function Bu(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash should be wrapped by utils.createHasher");Fu(e.outputLen),Fu(e.blockLen)}function zu(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function Uu(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Hu(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function qu(e,t){return e<<32-t|e>>>t}const Vu=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),Gu=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Wu(e){if(Ou(e),Vu)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=Gu[e[n]];return t}const ju=48,$u=57,Ku=65,Xu=70,Yu=97,Zu=102;function Ju(e){return e>=ju&&e<=$u?e-ju:e>=Ku&&e<=Xu?e-(Ku-10):e>=Yu&&e<=Zu?e-(Yu-10):void 0}function Qu(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);if(Vu)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,i=0;t<n;t++,i+=2){const n=Ju(e.charCodeAt(i)),s=Ju(e.charCodeAt(i+1));if(void 0===n||void 0===s){const t=e[i]+e[i+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+i)}r[t]=16*n+s}return r}function ed(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),Ou(e),e}class td{}function nd(e){const t=t=>e().update(ed(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function rd(e=32){if(ku&&"function"==typeof ku.getRandomValues)return ku.getRandomValues(new Uint8Array(e));if(ku&&"function"==typeof ku.randomBytes)return Uint8Array.from(ku.randomBytes(e));throw Error("crypto.getRandomValues must be defined")}function id(e,t,n){return e&t^~e&n}function sd(e,t,n){return e&t^e&n^t&n}class od extends td{constructor(e,t,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(e),this.view=Hu(this.buffer)}update(e){zu(this),Ou(e=ed(e));const{view:t,buffer:n,blockLen:r}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);if(o===r){const t=Hu(e);for(;r<=i-s;s+=r)this.process(t,s);continue}n.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){zu(this),function(e,t){Ou(e);const n=t.outputLen;if(e.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:i}=this;let{pos:s}=this;t[s++]=128,Uu(this.buffer.subarray(s)),this.padOffset>r-s&&(this.process(n,0),s=0);for(let e=s;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const i=BigInt(32),s=BigInt(4294967295),o=Number(n>>i&s),a=Number(n&s),l=r?4:0,c=r?0:4;e.setUint32(t+l,o,r),e.setUint32(t+c,a,r)}(n,r-8,BigInt(8*this.length),i),this.process(n,0);const o=Hu(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen should be aligned to 32bit");const l=a/4,c=this.get();if(l>c.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)o.setUint32(4*e,c[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:i,destroyed:s,pos:o}=this;return e.destroyed=s,e.finished=i,e.length=r,e.pos=o,r%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const ad=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ld=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),cd=new Uint32Array(64);class hd extends od{constructor(e=32){super(64,e,8,!1),this.A=0|ad[0],this.B=0|ad[1],this.C=0|ad[2],this.D=0|ad[3],this.E=0|ad[4],this.F=0|ad[5],this.G=0|ad[6],this.H=0|ad[7]}get(){const{A:e,B:t,C:n,D:r,E:i,F:s,G:o,H:a}=this;return[e,t,n,r,i,s,o,a]}set(e,t,n,r,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)cd[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=cd[e-15],n=cd[e-2],r=qu(t,7)^qu(t,18)^t>>>3,i=qu(n,17)^qu(n,19)^n>>>10;cd[e]=i+cd[e-7]+r+cd[e-16]|0}let{A:n,B:r,C:i,D:s,E:o,F:a,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(qu(o,6)^qu(o,11)^qu(o,25))+id(o,a,l)+ld[e]+cd[e]|0,h=(qu(n,2)^qu(n,13)^qu(n,22))+sd(n,r,i)|0;c=l,l=a,a=o,o=s+t|0,s=i,i=r,r=n,n=t+h|0}n=n+this.A|0,r=r+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,r,i,s,o,a,l,c)}roundClean(){Uu(cd)}destroy(){this.set(0,0,0,0,0,0,0,0),Uu(this.buffer)}}const ud=nd(()=>new hd),dd=BigInt(0),pd=BigInt(1);function fd(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?dd:BigInt("0x"+e)}function md(e){return Ou(e),fd(Wu(Uint8Array.from(e).reverse()))}function gd(e,t){return Qu(e.toString(16).padStart(2*t,"0"))}function yd(e,t){return gd(e,t).reverse()}function bd(e,t,n){let r;if("string"==typeof t)try{r=Qu(t)}catch(t){throw Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!Nu(t))throw Error(e+" must be hex string or Uint8Array");r=Uint8Array.from(t)}const i=r.length;if("number"==typeof n&&i!==n)throw Error(e+" of length "+n+" expected, got "+i);return r}const vd=e=>"bigint"==typeof e&&dd<=e;function wd(e,t,n,r){if(!function(e,t,n){return vd(e)&&vd(t)&&vd(n)&&t<=e&&e<n}(t,n,r))throw Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}const xd=e=>(pd<<BigInt(e))-pd;const _d=BigInt(0),Ed=BigInt(1),Sd=BigInt(2),Md=BigInt(3),Ad=BigInt(4),Cd=BigInt(5),Td=BigInt(7),Id=BigInt(8),Ld=BigInt(9),Pd=BigInt(16);function Rd(e,t){const n=e%t;return n>=_d?n:t+n}function Dd(e,t,n){let r=e;for(;t-- >_d;)r*=r,r%=n;return r}function kd(e,t){if(e===_d)throw Error("invert: expected non-zero number");if(t<=_d)throw Error("invert: expected positive modulus, got "+t);let n=Rd(e,t),r=t,i=_d,s=Ed;for(;n!==_d;){const e=r%n,t=i-s*(r/n);r=n,n=e,i=s,s=t}if(r!==Ed)throw Error("invert: does not exist");return Rd(i,t)}function Nd(e,t,n){if(!e.eql(e.sqr(t),n))throw Error("Cannot find square root")}function Fd(e,t){const n=(e.ORDER+Ed)/Ad,r=e.pow(t,n);return Nd(e,r,t),r}function Od(e,t){const n=(e.ORDER-Cd)/Id,r=e.mul(t,Sd),i=e.pow(r,n),s=e.mul(t,i),o=e.mul(e.mul(s,Sd),i),a=e.mul(s,e.sub(o,e.ONE));return Nd(e,a,t),a}function Bd(e){if(e<Md)throw Error("sqrt is not defined for small field");let t=e-Ed,n=0;for(;t%Sd===_d;)t/=Sd,n++;let r=Sd;const i=Hd(e);for(;1===Ud(i,r);)if(r++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===n)return Fd;let s=i.pow(r,t);const o=(t+Ed)/Sd;return function(e,r){if(e.is0(r))return r;if(1!==Ud(e,r))throw Error("Cannot find square root");let i=n,a=e.mul(e.ONE,s),l=e.pow(r,t),c=e.pow(r,o);for(;!e.eql(l,e.ONE);){if(e.is0(l))return e.ZERO;let t=1,n=e.sqr(l);for(;!e.eql(n,e.ONE);)if(t++,n=e.sqr(n),t===i)throw Error("Cannot find square root");const r=Ed<<BigInt(i-t-1),s=e.pow(a,r);i=t,a=e.sqr(s),l=e.mul(l,a),c=e.mul(c,s)}return c}}function zd(e){return e%Ad===Md?Fd:e%Id===Cd?Od:e%Pd===Ld?function(e){const t=Hd(e),n=Bd(e),r=n(t,t.neg(t.ONE)),i=n(t,r),s=n(t,t.neg(r)),o=(e+Td)/Pd;return(e,t)=>{let n=e.pow(t,o),a=e.mul(n,r);const l=e.mul(n,i),c=e.mul(n,s),h=e.eql(e.sqr(a),t),u=e.eql(e.sqr(l),t);n=e.cmov(n,a,h),a=e.cmov(c,l,u);const d=e.eql(e.sqr(a),t),p=e.cmov(n,a,d);return Nd(e,p,t),p}}(e):Bd(e)}function Ud(e,t){const n=(e.ORDER-Ed)/Sd,r=e.pow(t,n),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!o)throw Error("invalid Legendre symbol result");return i?1:s?0:-1}function Hd(e,t,n=!1,r={}){if(e<=_d)throw Error("invalid field: expected ORDER > 0, got "+e);let i,s,o,a=!1;if("object"==typeof t&&null!=t){if(r.sqrt||n)throw Error("cannot specify opts in two arguments");const e=t;e.BITS&&(i=e.BITS),e.sqrt&&(s=e.sqrt),"boolean"==typeof e.isLE&&(n=e.isLE),"boolean"==typeof e.modFromBytes&&(a=e.modFromBytes),o=e.allowedLengths}else"number"==typeof t&&(i=t),r.sqrt&&(s=r.sqrt);const{nBitLength:l,nByteLength:c}=function(e,t){void 0!==t&&Fu(t);const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}(e,i);if(c>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let h;const u=Object.freeze({ORDER:e,isLE:n,BITS:l,BYTES:c,MASK:xd(l),ZERO:_d,ONE:Ed,allowedLengths:o,create(t){return Rd(t,e)},isValid(t){if("bigint"!=typeof t)throw Error("invalid field element: expected bigint, got "+typeof t);return _d<=t&&t<e},is0(e){return e===_d},isValidNot0(e){return!u.is0(e)&&u.isValid(e)},isOdd(e){return(e&Ed)===Ed},neg(t){return Rd(-t,e)},eql(e,t){return e===t},sqr(t){return Rd(t*t,e)},add(t,n){return Rd(t+n,e)},sub(t,n){return Rd(t-n,e)},mul(t,n){return Rd(t*n,e)},pow(e,t){return function(e,t,n){if(n<_d)throw Error("invalid exponent, negatives unsupported");if(n===_d)return e.ONE;if(n===Ed)return t;let r=e.ONE,i=t;for(;n>_d;)n&Ed&&(r=e.mul(r,i)),i=e.sqr(i),n>>=Ed;return r}(u,e,t)},div(t,n){return Rd(t*kd(n,e),e)},sqrN(e){return e*e},addN(e,t){return e+t},subN(e,t){return e-t},mulN(e,t){return e*t},inv(t){return kd(t,e)},sqrt:s||(t=>(h||(h=zd(e)),h(u,t))),toBytes(e){return n?yd(e,c):gd(e,c)},fromBytes(t,r=!0){if(o){if(!o.includes(t.length)||t.length>c)throw Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);const e=new Uint8Array(c);e.set(t,n?0:e.length-t.length),t=e}if(t.length!==c)throw Error("Field.fromBytes: expected "+c+" bytes, got "+t.length);let i=n?md(t):function(e){return fd(Wu(e))}(t);if(a&&(i=Rd(i,e)),!r&&!u.isValid(i))throw Error("invalid field element: outside of range 0..ORDER");return i},invertBatch(e){return function(e,t,n=!1){const r=Array(t.length).fill(n?e.ZERO:void 0),i=t.reduce((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n)),e.ONE),s=e.inv(i);return t.reduceRight((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n)),s),r}(u,e)},cmov(e,t,n){return n?t:e}});return Object.freeze(u)}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const qd=BigInt(0),Vd=BigInt(1),Gd=BigInt(2);function Wd(e){return function(e,t,n={}){if(!e||"object"!=typeof e)throw Error("expected valid options object");function r(t,n,r){const i=e[t];if(r&&void 0===i)return;const s=typeof i;if(s!==n||null===i)throw Error(`param "${t}" is invalid: expected ${n}, got ${s}`)}Object.entries(t).forEach(([e,t])=>r(e,t,!1)),Object.entries(n).forEach(([e,t])=>r(e,t,!0))}(e,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...e})}function jd(e){const t=Wd(e),{P:n,type:r,adjustScalarBytes:i,powPminus2:s,randomBytes:o}=t,a="x25519"===r;if(!a&&"x448"!==r)throw Error("invalid type");const l=o||rd,c=a?255:448,h=a?32:56,u=a?BigInt(9):BigInt(5),d=a?BigInt(121665):BigInt(39081),p=a?Gd**BigInt(254):Gd**BigInt(447),f=a?BigInt(8)*Gd**BigInt(251)-Vd:BigInt(4)*Gd**BigInt(445)-Vd,m=p+f+Vd,g=e=>Rd(e,n),y=b(u);function b(e){return yd(g(e),h)}function v(e,t){const r=function(e,t){wd("u",e,qd,n),wd("scalar",t,p,m);const r=t,i=e;let o=Vd,a=qd,l=e,h=Vd,u=qd;for(let e=BigInt(c-1);e>=qd;e--){const t=r>>e&Vd;u^=t,({x_2:o,x_3:l}=x(u,o,l)),({x_2:a,x_3:h}=x(u,a,h)),u=t;const n=o+a,s=g(n*n),c=o-a,p=g(c*c),f=s-p,m=l+h,y=g((l-h)*n),b=g(m*c),v=y+b,w=y-b;l=g(v*v),h=g(i*g(w*w)),o=g(s*p),a=g(f*(s+g(d*f)))}({x_2:o,x_3:l}=x(u,o,l)),({x_2:a,x_3:h}=x(u,a,h));const f=s(a);return g(o*f)}(function(e){const t=bd("u coordinate",e,h);return a&&(t[31]&=127),g(md(t))}(t),function(e){return md(i(bd("scalar",e,h)))}(e));if(r===qd)throw Error("invalid private or public key received");return b(r)}function w(e){return v(e,y)}function x(e,t,n){const r=g(e*(t-n));return{x_2:t=g(t-r),x_3:n=g(n+r)}}const _={secretKey:h,publicKey:h,seed:h},E=(e=l(h))=>(Ou(e,_.seed),e);const S={randomSecretKey:E,randomPrivateKey:E};return{keygen(e){const t=E(e);return{secretKey:t,publicKey:w(t)}},getSharedSecret(e,t){return v(e,t)},getPublicKey(e){return w(e)},scalarMult:v,scalarMultBase:w,utils:S,GuBytes:y.slice(),lengths:_}}const $d=BigInt(1),Kd=BigInt(2),Xd=BigInt(3),Yd=BigInt(5),Zd=BigInt(8),Jd=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Qd=(()=>({p:Jd,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Zd,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function ep(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const tp=(()=>Hd(Qd.p,{isLE:!0}))(),np=(()=>{const e=tp.ORDER;return jd({P:e,type:"x25519",powPminus2(t){const{pow_p_5_8:n,b2:r}=function(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),i=BigInt(80),s=Jd,o=e*e%s*e%s,a=Dd(o,Kd,s)*o%s,l=Dd(a,$d,s)*e%s,c=Dd(l,Yd,s)*l%s,h=Dd(c,t,s)*c%s,u=Dd(h,n,s)*h%s,d=Dd(u,r,s)*u%s,p=Dd(d,i,s)*d%s,f=Dd(p,i,s)*d%s,m=Dd(f,t,s)*c%s;return{pow_p_5_8:Dd(m,Kd,s)*e%s,b2:o}}(t);return Rd(Dd(n,Xd,e)*r,e)},adjustScalarBytes:ep})})();class rp extends td{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Bu(e);const n=ed(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(n.length>r?e.create().update(n).digest():n);for(let e=0;e<i.length;e++)i[e]^=54;this.iHash.update(i),this.oHash=e.create();for(let e=0;e<i.length;e++)i[e]^=106;this.oHash.update(i),Uu(i)}update(e){return zu(this),this.iHash.update(e),this}digestInto(e){zu(this),Ou(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:r,destroyed:i,blockLen:s,outputLen:o}=this;return e.finished=r,e.destroyed=i,e.blockLen=s,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ip=(e,t,n)=>new rp(e,t).update(n).digest();ip.create=(e,t)=>new rp(e,t);const sp=Uint8Array.from([0]),op=Uint8Array.of();const ap=ud,lp={hashSHA256:e=>ap(e.subarray()),getHKDF(e,t){const n=function(e,t,n){return Bu(e),void 0===n&&(n=new Uint8Array(e.outputLen)),ip(e,ed(n),ed(t))}(ap,t,e),r=function(e,t,n,r=32){Bu(e),Fu(r);const i=e.outputLen;if(r>255*i)throw Error("Length should be <= 255*HashLen");const s=Math.ceil(r/i);void 0===n&&(n=op);const o=new Uint8Array(s*i),a=ip.create(e,t),l=a._cloneInto(),c=new Uint8Array(a.outputLen);for(let e=0;e<s;e++)sp[0]=e+1,l.update(0===e?op:c).update(n).update(sp).digestInto(c),o.set(c,i*e),a._cloneInto(l);return a.destroy(),l.destroy(),Uu(c,sp),o.slice(0,r)}(ap,n,void 0,96),i=r;return[i.subarray(0,32),i.subarray(32,64),i.subarray(64,96)]},generateX25519KeyPair(){const e=np.utils.randomPrivateKey();return{publicKey:np.getPublicKey(e),privateKey:e}},generateX25519KeyPairFromSeed:e=>({publicKey:np.getPublicKey(e),privateKey:e}),generateX25519SharedKey:(e,t)=>np.getSharedSecret(e.subarray(),t.subarray()),chaCha20Poly1305Encrypt:(e,t,n,r)=>Ru(r,t,n).encrypt(e.subarray()),chaCha20Poly1305Decrypt:(e,t,n,r,i)=>Ru(r,t,n).decrypt(e.subarray(),i)},cp=lp;const hp=e=>{const n=t(2);return n[0]=e>>8,n[1]=e,n};hp.bytes=2;const up=e=>{if(e.length<2)throw RangeError("Could not decode int16BE");if(e instanceof Uint8Array){let t=0;return t+=e[0]<<8,t+=e[1],t}return e.getUint16(0)};function dp(e,t){t.enabled&&tu&&(e?(t("LOCAL_STATIC_PUBLIC_KEY "+Pn(e.publicKey,"hex")),t("LOCAL_STATIC_PRIVATE_KEY "+Pn(e.privateKey,"hex"))):t("Missing local static keys."))}function pp(e,t){t.enabled&&tu&&(e?(t("LOCAL_PUBLIC_EPHEMERAL_KEY "+Pn(e.publicKey,"hex")),t("LOCAL_PRIVATE_EPHEMERAL_KEY "+Pn(e.privateKey,"hex"))):t("Missing local ephemeral keys."))}function fp(e,t){t.enabled&&tu&&t(e?"REMOTE_EPHEMERAL_PUBLIC_KEY "+Pn(e.subarray(),"hex"):"Missing remote ephemeral keys.")}function mp(e,t,n){n.enabled&&tu&&(n(`CIPHER_STATE_1 ${e.n.getUint64()} ${e.k&&Pn(e.k,"hex")}`),n(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&Pn(t.k,"hex")}`))}up.bytes=2;class gp extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=gp.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}class yp{n;bytes;view;constructor(t=0){this.n=t,this.bytes=e(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>4294967295)throw Error("Cipherstate has reached maximum n, a new handshake must be performed")}}const bp=e(0);class vp{k;n;crypto;constructor(e,t,n=0){this.crypto=e,this.k=t,this.n=new yp(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),r}}class wp{cs;ck;h;crypto;constructor(t,n){this.crypto=t;const r=rt(n,"utf-8");this.h=function(t,n){if(n.length<=32){const t=e(32);return t.set(n),t}return t.hash(n)}(t,r),this.ck=this.h,this.cs=new vp(t)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new vp(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new br(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,bp);return[new vp(this.crypto,e),new vp(this.crypto,t)]}}class xp{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:r,initiator:i,s,e:o,rs:a,re:l}=e;this.crypto=t,this.ss=new wp(t,n),this.ss.mixHash(r),this.initiator=i,this.s=s,this.e=o,this.rs=a,this.re=l}writeE(){if(this.e)throw Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw Error("ephemeral keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw Error("ephemeral keypair is not set");if(!this.rs)throw Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw Error("static keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw Error("static keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw Error("ephemeral keypair is not set");if(!this.rs)throw Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw Error("message is not long enough");const r=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(r),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class _p extends xp{writeMessageA(e){return new br(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new br(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new br(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(e){throw new gp("handshake stage 0 validation fail: "+e.message)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(e){throw new gp("handshake stage 1 validation fail: "+e.message)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(e){throw new gp("handshake stage 2 validation fail: "+e.message)}}}var Ep,Sp;async function Mp(e,t,n){const r=await e.sign(Cp(t));return Sp.encode({identityKey:Ah(e.publicKey),identitySig:r,extensions:n})}async function Ap(e,t,n){try{const r=Sp.decode(e),i=Mh(r.identityKey);if(!1===n?.equals(i))throw Error(`Payload identity key ${i} does not match expected remote identity key ${n}`);if(!t)throw Error("Remote static does not exist");const s=Cp(t);if(!await i.verify(s,r.identitySig))throw Error("Invalid payload signature");return r}catch(e){throw new Ch(e.message)}}function Cp(e){const t=rt("noise-libp2p-static-key:");return e instanceof Uint8Array?pr([t,e],t.length+e.length):(e.prepend(t),e)}async function Tp(e,t){const{log:n,connection:r,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:l,extensions:c}=e,h=await Mp(s,a.publicKey,c),u=new _p({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});dp(u.s,n),n.trace("Stage 0 - Initiator starting to send first message."),await r.write(u.writeMessageA(bp),t),n.trace("Stage 0 - Initiator finished sending first message."),pp(u.e,n),n.trace("Stage 1 - Initiator waiting to receive first message from responder...");const d=u.readMessageB(await r.read(t));n.trace("Stage 1 - Initiator received the message."),fp(u.re,n),function(e,t){t.enabled&&tu&&t(e?"REMOTE_STATIC_PUBLIC_KEY "+Pn(e.subarray(),"hex"):"Missing remote static public key.")}(u.rs,n),n.trace("Initiator going to check remote's signature...");const p=await Ap(d,u.rs,l);n.trace("All good with the signature!"),n.trace("Stage 2 - Initiator sending third handshake message."),await r.write(u.writeMessageC(h),t),n.trace("Stage 2 - Initiator sent message with signed payload.");const[f,m]=u.ss.split();return mp(f,m,n),{payload:p,encrypt(e){return f.encryptWithAd(bp,e)},decrypt(e,t){return m.decryptWithAd(bp,e,t)}}}(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.webtransportCerthashes)for(const n of e.webtransportCerthashes)t.uint32(10),t.bytes(n);!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={webtransportCerthashes:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3==1)n.webtransportCerthashes.push(e.bytes());else e.skipType(7&t)}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=t=>T(t,e.codec())})(Ep||(Ep={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.identityKey&&e.identityKey.byteLength>0&&(t.uint32(10),t.bytes(e.identityKey)),null!=e.identitySig&&e.identitySig.byteLength>0&&(t.uint32(18),t.bytes(e.identitySig)),null!=e.extensions&&(t.uint32(34),Ep.codec().encode(e.extensions,t)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={identityKey:e(0),identitySig:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.identityKey=t.bytes();break;case 2:r.identitySig=t.bytes();break;case 4:r.extensions=Ep.codec().decode(t,t.uint32());break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=e=>T(e,t.codec())})(Sp||(Sp={}));class Ip{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(t,n={}){const{staticNoiseKey:r,extensions:i,crypto:s,prologueBytes:o}=n,{metrics:a}=t;this.components=t;const l=s??cp;this.crypto=function(e){return{generateKeypair:e.generateX25519KeyPair,dh:(t,n)=>e.generateX25519SharedKey(t.privateKey,n).subarray(0,32),encrypt:e.chaCha20Poly1305Encrypt,decrypt:e.chaCha20Poly1305Decrypt,hash:e.hashSHA256,hkdf:e.getHKDF}}(l),this.extensions=i,this.metrics=a?function(e){return{xxHandshakeSuccesses:e.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:e.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:e.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:e.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:e.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}(a):void 0,this.staticKey=r?l.generateX25519KeyPairFromSeed(r):l.generateX25519KeyPair(),this.prologue=o??e(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[Th]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=Jh(e,{lengthEncoder:hp,lengthDecoder:up,maxDataLength:eu}),r=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,r);e.source=i.source,e.sink=i.sink;const s=Mh(r.payload.identityKey);return{conn:e,remoteExtensions:r.payload.extensions,remotePeer:Hh(s)}}async secureInbound(e,t){const n=Jh(e,{lengthEncoder:hp,lengthDecoder:up,maxDataLength:eu}),r=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,r);e.source=i.source,e.sink=i.sink;const s=Mh(r.payload.identityKey);return{conn:e,remoteExtensions:r.payload.extensions,remotePeer:Hh(s)}}async performHandshakeInitiator(e,t,n,r){let i;try{i=await Tp({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},r),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return i}async performHandshakeResponder(e,t,n,r){let i;try{i=await async function(e,t){const{log:n,connection:r,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:l,extensions:c}=e,h=await Mp(s,a.publicKey,c),u=new _p({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});dp(u.s,n),n.trace("Stage 0 - Responder waiting to receive first message."),u.readMessageA(await r.read(t)),n.trace("Stage 0 - Responder received first message."),fp(u.re,n),n.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await r.write(u.writeMessageB(h),t),n.trace("Stage 1 - Responder sent the second handshake message with signed payload."),pp(u.e,n),n.trace("Stage 2 - Responder waiting for third handshake message...");const d=u.readMessageC(await r.read(t));n.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Ap(d,u.rs,l),[f,m]=u.ss.split();return mp(f,m,n),{payload:p,encrypt:e=>m.encryptWithAd(bp,e),decrypt:(e,t)=>f.decryptWithAd(bp,e,t)}}({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},r),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return i}async createSecureConnection(e,t){const[n,r]=function(){const e=Qh(),t=Qh();return[{source:e.source,sink:t.sink},{source:t.source,sink:e.sink}]}(),i=e.unwrap();return await Ur(n,function(e,t){return async function*(n){for await(const r of n)for(let n=0;n<r.length;n+=65519){let i,s=n+65519;s>r.length&&(s=r.length),i=r instanceof Uint8Array?e.encrypt(r.subarray(n,s)):e.encrypt(r.sublist(n,s)),t?.encryptedPackets.increment(),yield new br(hp(i.byteLength),i)}}}(t,this.metrics),i,e=>Tr(e,{lengthDecoder:up}),function(e,t){return async function*(n){for await(const r of n)for(let n=0;n<r.length;n+=eu){let i=n+eu;if(i>r.length&&(i=r.length),i-16<n)throw Error("Invalid chunk");const s=r.sublist(n,i),o=r.subarray(n,i-16);try{const n=e.decrypt(s,o);t?.decryptedPackets.increment(),yield n}catch(e){throw t?.decryptErrors.increment(),e}}}}(t,this.metrics),n),r}}function Lp(e={}){return t=>new Ip(t,e)}const Pp=Symbol.for("@libp2p/peer-discovery"),Rp=Symbol.for("@libp2p/service-capabilities"),Dp=uf("dns4"),kp=uf("dns6"),Np=uf("dnsaddr"),Fp=hf(uf("dns"),Np,Dp,kp),Op=hf(uf("ip4"),uf("ip6")),Bp=hf(cf(Op,uf("tcp")),cf(Fp,uf("tcp"))),zp=cf(Op,uf("udp")),Up=cf(zp,uf("utp")),Hp=cf(zp,uf("quic")),qp=cf(zp,uf("quic-v1")),Vp=hf(cf(Bp,uf("ws")),cf(Fp,uf("ws"))),Gp=hf(cf(Vp,uf("p2p")),Vp),Wp=hf(cf(Bp,uf("wss")),cf(Fp,uf("wss")),cf(Bp,uf("tls"),uf("ws")),cf(Fp,uf("tls"),uf("ws"))),jp=hf(cf(Wp,uf("p2p")),Wp),$p=hf(cf(Bp,uf("http")),cf(Op,uf("http")),cf(Fp,uf("http"))),Kp=hf(cf(Bp,uf("https")),cf(Op,uf("https")),cf(Fp,uf("https"))),Xp=cf(zp,uf("webrtc-direct"),uf("certhash")),Yp=hf(cf(Xp,uf("p2p")),Xp),Zp=cf(qp,uf("webtransport"),uf("certhash"),uf("certhash")),Jp=hf(cf(Zp,uf("p2p")),Zp),Qp=hf(cf(Gp,uf("p2p-webrtc-star"),uf("p2p")),cf(jp,uf("p2p-webrtc-star"),uf("p2p")),cf(Gp,uf("p2p-webrtc-star")),cf(jp,uf("p2p-webrtc-star")));hf(cf(Gp,uf("p2p-websocket-star"),uf("p2p")),cf(jp,uf("p2p-websocket-star"),uf("p2p")),cf(Gp,uf("p2p-websocket-star")),cf(jp,uf("p2p-websocket-star")));const ef=hf(cf($p,uf("p2p-webrtc-direct"),uf("p2p")),cf(Kp,uf("p2p-webrtc-direct"),uf("p2p")),cf($p,uf("p2p-webrtc-direct")),cf(Kp,uf("p2p-webrtc-direct"))),tf=hf(Vp,Wp,$p,Kp,Qp,ef,Bp,Up,Hp,Fp,Yp,Jp);hf(cf(tf,uf("p2p-stardust"),uf("p2p")),cf(tf,uf("p2p-stardust")));const nf=hf(cf(tf,uf("p2p")),Qp,ef,Yp,Jp,uf("p2p")),rf=hf(cf(nf,uf("p2p-circuit"),nf),cf(nf,uf("p2p-circuit")),cf(uf("p2p-circuit"),nf),cf(tf,uf("p2p-circuit")),cf(uf("p2p-circuit"),tf),uf("p2p-circuit")),sf=()=>hf(cf(rf,sf),rf),of=sf(),af=hf(cf(of,nf,of),cf(nf,of),cf(of,nf),of,nf);function lf(e){return function(t){let n;try{n=Us(t)}catch(e){return!1}const r=e(n.protoNames());return null!==r&&(!0===r||!1===r?r:0===r.length)}}function cf(...e){function t(t){if(t.length<e.length)return null;let n=t;return e.some(e=>(n="function"==typeof e?e().partialMatch(t):e.partialMatch(t),Array.isArray(n)&&(t=n),null===n)),n}return{toString(){return"{ "+e.join(" ")+" }"},input:e,matches:lf(t),partialMatch:t}}function hf(...e){function t(t){let n=null;return e.some(e=>{const r="function"==typeof e?e().partialMatch(t):e.partialMatch(t);return null!=r&&(n=r,!0)}),n}return{toString(){return"{ "+e.join(" ")+" }"},input:e,matches:lf(t),partialMatch:t}}function uf(e){const t=e;return{toString(){return t},matches(e){let n;try{n=Us(e)}catch(e){return!1}const r=n.protoNames();return 1===r.length&&r[0]===t},partialMatch(e){return 0===e.length?null:e[0]===t?e.slice(1):null}}}hf(cf(of,uf("webrtc"),uf("p2p")),cf(of,uf("webrtc")),cf(tf,uf("webrtc"),uf("p2p")),cf(tf,uf("webrtc")),uf("webrtc"));class df extends Hi{static tag="bootstrap";log;timer;list;timeout;components;_init;constructor(e,t={list:[]}){if(null==t.list||0===t.list.length)throw Error("Bootstrap requires a list of peer addresses");super(),this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=t.timeout??1e3,this.list=[];for(const e of t.list){if(!af.matches(e)){this.log.error("Invalid multiaddr");continue}const t=Us(e),n=t.getPeerId();if(null==n){this.log.error("Invalid bootstrap multiaddr without peer id");continue}const r={id:Uh(n),multiaddrs:[t]};this.list.push(r)}this._init=t}[Pp]=this;[Symbol.toStringTag]="@libp2p/bootstrap";[Rp]=["@libp2p/peer-discovery"];isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error(e)})},this.timeout))}async _discoverBootstrapPeers(){if(null!=this.timer)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??"bootstrap"]:{value:this._init.tagValue??50,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),null==this.timer)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(t=>{this.log.error("could not dial bootstrap peer %p",e.id,t)})}}stop(){null!=this.timer&&clearTimeout(this.timer),this.timer=void 0}}let pf=class extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}},ff=class extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}};const mf=Symbol.for("@libp2p/service-capabilities");var gf;(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.payloadType&&e.payloadType.byteLength>0&&(t.uint32(18),t.bytes(e.payloadType)),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(26),t.bytes(e.payload)),null!=e.signature&&e.signature.byteLength>0&&(t.uint32(42),t.bytes(e.signature)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={publicKey:e(0),payloadType:e(0),payload:e(0),signature:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.publicKey=t.bytes();break;case 2:r.payloadType=t.bytes();break;case 3:r.payload=t.bytes();break;case 5:r.signature=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(gf||(gf={}));class yf extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class bf{static createFromProtobuf=e=>{const t=gf.decode(e),n=Mh(t.publicKey);return new bf({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t,n)=>{if(null==t)throw Error("Missing private key");const r=e.domain,i=e.codec,s=e.marshal(),o=vf(r,i,s),a=await t.sign(o.subarray(),n);return new bf({publicKey:t.publicKey,payloadType:i,payload:s,signature:a})};static openAndCertify=async(e,t,n)=>{const r=bf.createFromProtobuf(e);if(!await r.validate(t,n))throw new yf("Envelope signature is not valid for the given domain");return r};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:r,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=r,this.signature=i}marshal(){return null==this.marshaled&&(this.marshaled=gf.encode({publicKey:Ah(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return null!=e&&fr(this.marshal(),e.marshal())}async validate(e,t){const n=vf(e,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,t)}}const vf=(e,t,n)=>{const r=rt(e),i=u(r.byteLength),s=u(t.length),o=u(n.length);return new br(i,r,s,t,o,n)};const wf=Uint8Array.from([3,1]);var xf;(t=>{let n;(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={multiaddr:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();if(e>>>3==1)r.multiaddr=t.bytes();else t.skipType(7&e)}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(t.AddressInfo||(t.AddressInfo={})),t.codec=()=>(null==n&&(n=Jt((e,n,r={})=>{if(!1!==r.lengthDelimited&&n.fork(),null!=e.peerId&&e.peerId.byteLength>0&&(n.uint32(10),n.bytes(e.peerId)),null!=e.seq&&0n!==e.seq&&(n.uint32(16),n.uint64(e.seq)),null!=e.addresses)for(const r of e.addresses)n.uint32(26),t.AddressInfo.codec().encode(r,n);!1!==r.lengthDelimited&&n.ldelim()},(n,r,i={})=>{const s={peerId:e(0),seq:0n,addresses:[]},o=null==r?n.len:n.pos+r;for(;n.pos<o;){const e=n.uint32();switch(e>>>3){case 1:s.peerId=n.bytes();break;case 2:s.seq=n.uint64();break;case 3:if(null!=i.limits?.addresses&&s.addresses.length===i.limits.addresses)throw new Qt('Decode error - map field "addresses" had too many elements');s.addresses.push(t.AddressInfo.codec().decode(n,n.uint32(),{limits:i.limits?.addresses$}));break;default:n.skipType(7&e)}}return s})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(xf||(xf={}));class _f{static createFromProtobuf=e=>{const t=xf.decode(e),n=qh(Oe(t.peerId)),r=(t.addresses??[]).map(e=>Us(e.multiaddr)),i=t.seq;return new _f({peerId:n,multiaddrs:r,seqNumber:i})};static DOMAIN="libp2p-peer-record";static CODEC=wf;peerId;multiaddrs;seqNumber;domain=_f.DOMAIN;codec=_f.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:r}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=r??BigInt(Date.now())}marshal(){return null==this.marshaled&&(this.marshaled=xf.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return e instanceof _f&&(!!this.peerId.equals(e.peerId)&&(this.seqNumber===e.seqNumber&&!!function(e,t){const n=(e,t)=>e.toString().localeCompare(t.toString());return e.length===t.length&&(t.sort(n),e.sort(n).every((e,n)=>t[n].equals(e)))}(this.multiaddrs,e.multiaddrs)))}}function Ef(e,t){let n;const r=()=>{clearTimeout(n),n=setTimeout(()=>{n=void 0,e()},t)};return r.start=()=>{},r.stop=()=>{clearTimeout(n)},r}function Sf(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);}const Mf=globalThis.CustomEvent??Event;let Af=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=Ir(),this.haveNext=Ir()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Ir(),e}async throw(e){this.ended=!0,this.error=e,null!=e&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw this.error??Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Ir(),await Nr(this.readNext.promise,t?.signal,t)}};let Cf=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Tf(e,t){const n=new Af;e.sink(n).catch(async e=>{await n.end(e)}),e.sink=async e=>{for await(const t of e)await n.push(t);await n.end()};let r=e.source;null!=e.source[Symbol.iterator]?r=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(r=e.source[Symbol.asyncIterator]());const i=new br,s={async read(e){if(e?.signal?.throwIfAborted(),null==e?.bytes){const{done:t,value:n}=await Nr(r.next(),e?.signal);return!0===t?null:n}for(;i.byteLength<e.bytes;){const{value:t,done:n}=await Nr(r.next(),e?.signal);if(!0===n)throw new Cf("unexpected end of input");i.append(t)}const t=i.sublist(0,e.bytes);return i.consume(e.bytes),t},async write(e,t){t?.signal?.throwIfAborted(),e instanceof Uint8Array?await n.push(e,t):await n.push(e.subarray(),t)},unwrap(){if(i.byteLength>0){const n=e.source;e.source=async function*(){!1===t?.yieldBytes?yield i:yield*i,yield*n}()}return e}};return s}let If=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Lf=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Pf=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"};function Rf(e,t){const n=function(e,t={}){const n=Tf(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=l(t.maxDataLength));const r=t?.lengthDecoder??d,i=t?.lengthEncoder??u;return{async read(e){let i=-1;const s=new br;for(;;){s.append(await n.read({...e,bytes:1}));try{i=r(s)}catch(e){if(e instanceof RangeError)continue;throw e}if(i<0)throw new If("Invalid message length");if(null!=t?.maxLengthLength&&s.byteLength>t.maxLengthLength)throw new Pf("message length length too long");if(i>-1)break}if(null!=t?.maxDataLength&&i>t.maxDataLength)throw new Lf("message length too long");return n.read({...e,bytes:i})},async write(e,t){await n.write(new br(i(e.byteLength),e),t)},async writeV(e,t){const r=new br(...e.flatMap(e=>[i(e.byteLength),e]));await n.write(r,t)},unwrap:()=>n.unwrap()}}(e,t),r={async read(e,t){const r=await n.read(t);return e.decode(r)},async write(e,t,r){await n.write(t.encode(e),r)},async writeV(e,t,r){await n.writeV(e.map(e=>t.encode(e)),r)},pb(e){return{async read(t){return r.read(e,t)},async write(t,n){return r.write(t,e,n)},async writeV(t,n){return r.writeV(t,e,n)},unwrap(){return r}}},unwrap(){return n.unwrap()}};return r}var Df;(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{if(!1!==n.lengthDelimited&&t.fork(),null!=e.protocolVersion&&(t.uint32(42),t.string(e.protocolVersion)),null!=e.agentVersion&&(t.uint32(50),t.string(e.agentVersion)),null!=e.publicKey&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.listenAddrs)for(const n of e.listenAddrs)t.uint32(18),t.bytes(n);if(null!=e.observedAddr&&(t.uint32(34),t.bytes(e.observedAddr)),null!=e.protocols)for(const n of e.protocols)t.uint32(26),t.string(n);null!=e.signedPeerRecord&&(t.uint32(66),t.bytes(e.signedPeerRecord)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={listenAddrs:[],protocols:[]},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 5:r.protocolVersion=e.string();break;case 6:r.agentVersion=e.string();break;case 1:r.publicKey=e.bytes();break;case 2:if(null!=n.limits?.listenAddrs&&r.listenAddrs.length===n.limits.listenAddrs)throw new Qt('Decode error - map field "listenAddrs" had too many elements');r.listenAddrs.push(e.bytes());break;case 4:r.observedAddr=e.bytes();break;case 3:if(null!=n.limits?.protocols&&r.protocols.length===n.limits.protocols)throw new Qt('Decode error - map field "protocols" had too many elements');r.protocols.push(e.string());break;case 8:r.signedPeerRecord=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Df||(Df={}));const kf={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:8192,runOnConnectionOpen:!0,runOnLimitedConnection:!0};class Nf{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){var n,r;this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??kf.timeout,this.maxInboundStreams=t.maxInboundStreams??kf.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??kf.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??kf.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??kf.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??kf.runOnLimitedConnection,this.host={protocolVersion:(t.protocolPrefix??kf.protocolPrefix)+"/0.1.0",agentVersion:(n=e.nodeInfo,r=t.agentVersion,null!=r?r:n.userAgent)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:rt(this.host.agentVersion),ProtocolVersion:rt(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(e=>{this.log.error(e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}var Ff,Of={};var Bf=(Ff||(Ff=1,function(){var e,t,n,r,i,s,o,a;a=e=>[(e&255<<24)>>>24,(e&255<<16)>>>16,(65280&e)>>>8,255&e].join("."),o=e=>{var n,r,i,s,o,a;for(n=[],i=s=0;s<=3&&0!==e.length;i=++s){if(i>0){if("."!==e[0])throw Error("Invalid IP");e=e.substring(1)}o=(a=t(e))[0],r=a[1],e=e.substring(r),n.push(o)}if(0!==e.length)throw Error("Invalid IP");switch(n.length){case 1:if(n[0]>4294967295)throw Error("Invalid IP");return n[0]>>>0;case 2:if(n[0]>255||n[1]>16777215)throw Error("Invalid IP");return(n[0]<<24|n[1])>>>0;case 3:if(n[0]>255||n[1]>255||n[2]>65535)throw Error("Invalid IP");return(n[0]<<24|n[1]<<16|n[2])>>>0;case 4:if(n[0]>255||n[1]>255||n[2]>255||n[3]>255)throw Error("Invalid IP");return(n[0]<<24|n[1]<<16|n[2]<<8|n[3])>>>0;default:throw Error("Invalid IP")}},n=e=>e.charCodeAt(0),r=n("0"),s=n("a"),i=n("A"),t=e=>{var t,o,a,l,c;for(l=0,t=10,o="9",a=0,e.length>1&&"0"===e[a]&&("x"===e[a+1]||"X"===e[a+1]?(a+=2,t=16):"0"<=e[a+1]&&e[a+1]<="9"&&(a++,t=8,o="7")),c=a;a<e.length;){if("0"<=e[a]&&e[a]<=o)l=l*t+(n(e[a])-r)>>>0;else{if(16!==t)break;if("a"<=e[a]&&e[a]<="f")l=l*t+(10+n(e[a])-s)>>>0;else{if(!("A"<=e[a]&&e[a]<="F"))break;l=l*t+(10+n(e[a])-i)>>>0}}if(l>4294967295)throw Error("too large");a++}if(a===c)throw Error("empty octet");return[l,a]},e=function(){function e(e,t){var n,r,i;if("string"!=typeof e)throw Error("Missing `net' parameter");if(t||(i=e.split("/",2),e=i[0],t=i[1]),t||(t=32),"string"==typeof t&&t.indexOf(".")>-1){try{this.maskLong=o(t)}catch(e){throw Error("Invalid mask: "+t)}for(n=r=32;r>=0;n=--r)if(this.maskLong===4294967295<<32-n>>>0){this.bitmask=n;break}}else{if(!t&&0!==t)throw Error("Invalid mask: empty");this.bitmask=parseInt(t,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0)}try{this.netLong=(o(e)&this.maskLong)>>>0}catch(t){throw Error("Invalid net address: "+e)}if(!(this.bitmask<=32))throw Error("Invalid mask for ip4: "+t);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return e.prototype.contains=function(t){return"string"==typeof t&&(t.indexOf("/")>0||4!==t.split(".").length)&&(t=new e(t)),t instanceof e?this.contains(t.base)&&this.contains(t.broadcast||t.last):(o(t)&this.maskLong)>>>0==(this.netLong&this.maskLong)>>>0},e.prototype.next=function(t){return null==t&&(t=1),new e(a(this.netLong+this.size*t),this.mask)},e.prototype.forEach=function(e){var t,n,r;for(r=o(this.first),n=o(this.last),t=0;r<=n;)e(a(r),r,t),t++,r++},e.prototype.toString=function(){return this.base+"/"+this.bitmask},e}(),Of.ip2long=o,Of.long2ip=a,Of.Netmask=e}()),Of);const zf=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(e=>new Bf.Netmask(e));function Uf(e){for(const t of zf)if(t.contains(e))return!0;return!1}function Hf(e){return Qi(e)?Uf(e):/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(e)?function(e){const t=e.split(":");if(t.length<2)return!1;const n=t[t.length-1].padStart(4,"0"),r=t[t.length-2].padStart(4,"0");return Uf(`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}`)}(e):function(e){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)}(e)?function(e){const t=e.split(":");return Uf(t[t.length-1])}(e):es(e)?function(e){return/^::$/.test(e)||/^::1$/.test(e)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(e)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(e)||/^ff([0-9a-fA-F]{2,2}):/i.test(e)}(e):void 0}function qf(e){try{if(!function(e){try{for(const{code:t}of e.getComponents())if(42!==t)return 4===t||t===ns}catch{}return!1}(e))return!1;const[[,t]]=e.stringTuples();return null!=t&&(Hf(t)??!1)}catch{}return!0}const Vf=e=>({match(t){const n=t[0];return null!=n&&(n.code===e&&(null==n.value&&t.slice(1)))}}),Gf=(e,t)=>({match(n){const r=n[0];return r?.code===e&&(null!=r.value&&((null==t||r.value===t)&&n.slice(1)))}}),Wf=e=>({match(t){const n=e.match(t);return!1===n?t:n}}),jf=(...e)=>({match(t){let n;for(const r of e){const e=r.match(t);!1!==e&&((null==n||e.length<n.length)&&(n=e))}return null!=n&&n}}),$f=(...e)=>({match(t){for(const n of e){const e=n.match(t);if(!1===e)return!1;t=e}return t}});function Kf(...e){function t(t){if(null==t)return!1;let n=t.getComponents();for(const t of e){const e=t.match(n);if(!1===e)return!1;n=e}return n}return{matchers:e,matches(e){return!1!==t(e)},exactMatch(e){const n=t(e);return!1!==n&&0===n.length}}}Kf(Gf(rs));const Xf=Gf(54),Yf=Gf(55),Zf=Gf(56),Jf=Gf(53);Kf(Xf,Wf(Gf(rs))),Kf(Yf,Wf(Gf(rs))),Kf(Zf,Wf(Gf(rs))),Kf(jf(Jf,Zf,Xf,Yf),Wf(Gf(rs)));const Qf=$f(Gf(4),Wf(Gf(43))),em=$f(Wf(Gf(42)),Gf(ns),Wf(Gf(43))),tm=jf(Qf,em),nm=jf(tm,Jf,Xf,Yf,Zf),rm=Kf(jf(tm,$f(jf(Jf,Zf,Xf,Yf),Wf(Gf(rs)))));Kf(Qf),Kf(em),Kf(tm);const im=$f(nm,Gf(6)),sm=$f(nm,Gf(ts)),om=Kf($f(im,Wf(Gf(rs))));Kf(sm);const am=$f(sm,Vf(460),Wf(Gf(rs))),lm=$f(sm,Vf(461),Wf(Gf(rs))),cm=jf(am,lm);Kf(am),Kf(lm);const hm=jf(nm,im,sm,am,lm),um=jf($f(hm,Vf(477),Wf(Gf(rs)))),dm=Kf(um),pm=jf($f(hm,Vf(478),Wf(Gf(rs))),$f(hm,Vf(is),Wf(Gf(449)),Vf(477),Wf(Gf(rs)))),fm=Kf(pm),mm=$f(sm,Vf(280),Wf(Gf(ss)),Wf(Gf(ss)),Wf(Gf(rs)));Kf(mm);const gm=$f(lm,Vf(465),Wf(Gf(ss)),Wf(Gf(ss)),Wf(Gf(rs)));Kf(gm);const ym=jf(um,pm,$f(im,Wf(Gf(rs))),$f(cm,Wf(Gf(rs))),$f(nm,Wf(Gf(rs))),mm,gm,Gf(rs));Kf(ym);Kf($f(ym,Vf(ls),Gf(rs)));Kf(jf($f(ym,Vf(ls),Vf(as),Wf(Gf(rs))),$f(ym,Vf(as),Wf(Gf(rs))),$f(Vf(as),Wf(Gf(rs)))));Kf(jf($f(nm,Gf(6),Vf(os),Wf(Gf(rs))),$f(nm,Vf(os),Wf(Gf(rs)))));Kf($f(nm,jf($f(Gf(6,"443"),Vf(os)),$f(Gf(6),Vf(443)),$f(Gf(6),Vf(is),Vf(os)),$f(Vf(is),Vf(os)),Vf(is),Vf(443)),Wf(Gf(rs))));Kf(jf($f(Gf(777),Wf(Gf(rs)))));Kf(jf($f(Gf(400),Wf(Gf(rs)))));class bm extends Nf{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??kf.protocolPrefix}/id/1.0.0`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??kf.runOnConnectionOpen)&&e.events.addEventListener("connection:open",e=>{const t=e.detail;this.identify(t).catch(e=>{e.name!==pf.name&&this.log.error("error during identify trigged by connection:open",e)})})}[mf]=["@libp2p/identify"];async _identify(e,t={}){let n;if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const r=Rf(n,{maxDataLength:this.maxMessageSize}).pb(Df),i=await r.read(t);return await n.close(t),i}catch(e){throw n?.abort(e),e}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:r,protocols:i,observedAddr:s}=n;if(null==r)throw new ff("Public key was missing from identify message");const o=Vh(Mh(r).toCID()),a=e.log.newScope("identify");if(!e.remotePeer.equals(o))throw new ff("Identified peer does not match the expected peer");if(this.peerId.equals(o))throw new ff("Identified peer is our own peer id?");return this.maybeAddObservedAddress(s,a),a("completed for peer %p and protocols %o",o,i),async function(e,t,n,r,i){if(n("received identify from %p",r.remotePeer),null==i)throw new ff("message was null or undefined");const s={};if(i.listenAddrs.length>0&&(s.addresses=i.listenAddrs.map(e=>({isCertified:!1,multiaddr:Us(e)}))),i.protocols.length>0&&(s.protocols=i.protocols),null!=i.publicKey){const e=Mh(i.publicKey);if(!Hh(e).equals(r.remotePeer))throw new ff("public key did not match remote PeerId");s.publicKey=e}let o;if(null!=i.signedPeerRecord){n.trace("received signedPeerRecord from %p",r.remotePeer);let t=i.signedPeerRecord;const a=await bf.openAndCertify(t,_f.DOMAIN);let l=_f.createFromProtobuf(a.payload);const c=Vh(a.publicKey.toCID());if(!l.peerId.equals(c))throw new ff("signing key does not match PeerId in the PeerRecord");if(!r.remotePeer.equals(l.peerId))throw new ff("signing key does not match remote PeerId");let h;try{h=await e.get(l.peerId)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=h&&(s.metadata=h.metadata,null!=h.peerRecordEnvelope)){const e=bf.createFromProtobuf(h.peerRecordEnvelope),r=_f.createFromProtobuf(e.payload);r.seqNumber>=l.seqNumber&&(n("sequence number was lower or equal to existing sequence number - stored: %d received: %d",r.seqNumber,l.seqNumber),l=r,t=h.peerRecordEnvelope)}s.peerRecordEnvelope=t,s.addresses=l.multiaddrs.map(e=>({isCertified:!0,multiaddr:e})),o={seq:l.seqNumber,addresses:l.multiaddrs}}else n("%p did not send a signed peer record",r.remotePeer);if(n.trace("patching %p with",r.remotePeer,s),await e.patch(r.remotePeer,s),null!=i.agentVersion||null!=i.protocolVersion){const t={};null!=i.agentVersion&&(t.AgentVersion=rt(i.agentVersion)),null!=i.protocolVersion&&(t.ProtocolVersion=rt(i.protocolVersion)),n.trace("merging %p metadata",r.remotePeer,t),await e.merge(r.remotePeer,{metadata:t})}const a={peerId:r.remotePeer,protocolVersion:i.protocolVersion,agentVersion:i.agentVersion,publicKey:i.publicKey,listenAddrs:i.listenAddrs.map(e=>Us(e)),observedAddr:null==i.observedAddr?void 0:Us(i.observedAddr),protocols:i.protocols,signedPeerRecord:o,connection:r};return t.safeDispatchEvent("peer:identify",{detail:a}),a}(this.peerStore,this.events,a,e,n)}maybeAddObservedAddress(e,t){const n=function(e){if(null!=e&&e.length>0)try{return Us(e)}catch{}}(e);if(null==n)return;if(t.trace("our observed address was %a",n),qf(n))return void this.log.trace("our observed address was private");const r=n.getComponents();r[0].code!==ns&&(42!==r[0].code||r[1].code!==ns)||function(e){try{for(const{code:t,value:n}of e.getComponents())if(null!=n&&t===ns)return Ns("2000::/3",n)}catch{}return!1}(n)?om.exactMatch(n)||(t.trace("storing the observed address"),this.addressManager.addObservedAddr(n)):t.trace("our observed address was IPv6 but not a global unicast address")}async handleProtocol(e){const{connection:t,stream:n}=e,r=t.log.newScope("identify"),i=AbortSignal.timeout(this.timeout);try{const e=await this.peerStore.get(this.peerId),r=this.addressManager.getAddresses().map(e=>e.decapsulateCode(function(e){const t=ws.getProtocol(e);return{code:t.code,size:t.size??0,name:t.name,resolvable:!!t.resolvable,path:!!t.path}}("p2p").code));let s=e.peerRecordEnvelope;if(r.length>0&&null==s){const e=new _f({peerId:this.peerId,multiaddrs:r});s=(await bf.seal(e,this.privateKey)).marshal().subarray()}let o=t.remoteAddr.bytes;rm.matches(t.remoteAddr)||(o=void 0);const a=Rf(n).pb(Df);await a.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:Ah(this.privateKey.publicKey),listenAddrs:r.map(e=>e.bytes),signedPeerRecord:s,observedAddr:o,protocols:e.protocols},{signal:i}),await n.close({signal:i})}catch(e){r.error("could not respond to identify request",e),n.abort(e)}}}function vm(e={}){return t=>new bm(t,e)}class wm extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}let xm=class extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}};class _m extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}const Em=Symbol.for("@libp2p/service-capabilities");function Sm(e,t){const n=function(e){if(null!=e){if("function"==typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"==typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"==typeof e.next)return e}throw Error("argument is not an iterator or iterable")}(e).return?.();var r;null!=(r=n)&&"function"==typeof r.then&&"function"==typeof r.catch&&"function"==typeof r.finally&&n.catch(e=>{t.error("could not cause iterator to return",e)})}const Mm=()=>{const e=Error("Delay aborted");return e.name="AbortError",e},Am=new WeakMap;const Cm=function({clearTimeout:e,setTimeout:t}={}){return(n,{value:r,signal:i}={})=>{if(i?.aborted)return Promise.reject(Mm());let s,o,a;const l=e??clearTimeout,c=()=>{l(s),a(Mm())},h=new Promise((e,l)=>{o=()=>{i&&i.removeEventListener("abort",c),e(r)},a=l,s=(t??setTimeout)(o,n)});return i&&i.addEventListener("abort",c,{once:!0}),Am.set(h,()=>{l(s),s=null,o()}),h}}();class Tm extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}let Im=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}};class Lm{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??1e3*this.duration/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new Pm}async consume(e,t=1,n={}){const r=this.getKey(e),i=this._getKeySecDuration(n);let s=this.memoryStorage.incrby(r,t,i);if(s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s.consumedPoints>this.points)throw this.blockDuration>0&&s.consumedPoints<=this.points+t&&(s=this.memoryStorage.set(r,s.consumedPoints,this.blockDuration)),new Tm("Rate limit exceeded",s);if(this.execEvenly&&s.msBeforeNext>0&&!s.isFirstInDuration){let e=Math.ceil(s.msBeforeNext/(s.remainingPoints+2));e<this.execEvenlyMinDelayMs&&(e=s.consumedPoints*this.execEvenlyMinDelayMs),await Cm(e)}return s}penalty(e,t=1,n={}){const r=this.getKey(e),i=this._getKeySecDuration(n),s=this.memoryStorage.incrby(r,t,i);return s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s}reward(e,t=1,n={}){const r=this.getKey(e),i=this._getKeySecDuration(n),s=this.memoryStorage.incrby(r,-t,i);return s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s}block(e,t){const n=1e3*t,r=this.points+1;return this.memoryStorage.set(this.getKey(e),r,t),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:r,isFirstInDuration:!1}}set(e,t,n=0){const r=1e3*(n>=0?n:this.duration);return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return null!=t&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return null!=e?.customDuration&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class Pm{storage;constructor(){this.storage=new Map}incrby(e,t,n){const r=this.storage.get(e);if(null!=r){const i=null!=r.expiresAt?r.expiresAt.getTime()-(new Date).getTime():-1;return null==r.expiresAt||i>0?(r.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:r.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const r=1e3*n,i=this.storage.get(e);null!=i&&clearTimeout(i.timeoutId);const s={value:t,expiresAt:r>0?new Date(Date.now()+r):void 0};return this.storage.set(e,s),r>0&&(s.timeoutId=setTimeout(()=>{this.storage.delete(e)},r),null!=s.timeoutId.unref&&s.timeoutId.unref()),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:s.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(null!=t){return{remainingPoints:0,msBeforeNext:null!=t.expiresAt?t.expiresAt.getTime()-(new Date).getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}}delete(e){const t=this.storage.get(e);return null!=t&&(null!=t.timeoutId&&clearTimeout(t.timeoutId),this.storage.delete(e),!0)}}var Rm;(e=>{e[e.NEW_STREAM=0]="NEW_STREAM",e[e.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",e[e.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",e[e.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",e[e.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",e[e.RESET_RECEIVER=5]="RESET_RECEIVER",e[e.RESET_INITIATOR=6]="RESET_INITIATOR"})(Rm||(Rm={}));const Dm=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),km=Object.freeze({NEW_STREAM:Rm.NEW_STREAM,MESSAGE:Rm.MESSAGE_INITIATOR,CLOSE:Rm.CLOSE_INITIATOR,RESET:Rm.RESET_INITIATOR}),Nm=Object.freeze({MESSAGE:Rm.MESSAGE_RECEIVER,CLOSE:Rm.CLOSE_RECEIVER,RESET:Rm.RESET_RECEIVER}),Fm=1<<20;class Om{_buffer;_headerInfo;_maxMessageSize;_maxUnprocessedMessageQueueSize;constructor(e=Fm,t=4194304){this._buffer=new br,this._headerInfo=null,this._maxMessageSize=e,this._maxUnprocessedMessageQueueSize=t}write(e){if(null==e||0===e.length)return[];if(this._buffer.append(e),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw new xm("Unprocessed message queue size too large!");const t=[];for(;0!==this._buffer.length;){if(null==this._headerInfo)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(e){if("InvalidMessageError"===e.name)throw e;break}const{id:e,type:n,length:r,offset:i}=this._headerInfo;if(this._buffer.length-i<r)break;const s={id:e,type:n};n!==Rm.NEW_STREAM&&n!==Rm.MESSAGE_INITIATOR&&n!==Rm.MESSAGE_RECEIVER||(s.data=this._buffer.sublist(i,i+r)),t.push(s),this._buffer.consume(i+r),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:n}=Um(e),{value:r,offset:i}=Um(e,n),s=7&t;if(null==Dm[s])throw Error("Invalid type received: "+s);if(r>this._maxMessageSize)throw new xm("Message size too large");return{id:t>>3,type:s,offset:n+i,length:r}}}const Bm=128,zm=127;function Um(e,t=0){let n,r=0,i=0,s=t;const o=e.length;do{if(s>=o||i>49)throw t=0,new RangeError("Could not decode varint");n=e.get(s++),r+=i<28?(n&zm)<<i:(n&zm)*Math.pow(2,i),i+=7}while(n>=Bm);return{value:r,offset:t=s-t}}const Hm=10240;const qm=new class{_pool;_poolOffset;constructor(){this._pool=t(Hm),this._poolOffset=0}write(e,n){const r=this._pool;let i=this._poolOffset;u(e.id<<3|e.type,r,i),i+=l(e.id<<3|e.type),e.type!==Rm.NEW_STREAM&&e.type!==Rm.MESSAGE_INITIATOR&&e.type!==Rm.MESSAGE_RECEIVER||null==e.data?(u(0,r,i),i+=l(0)):(u(e.data.length,r,i),i+=l(e.data.length));const s=r.subarray(this._poolOffset,i);Hm-i<100?(this._pool=t(Hm),this._poolOffset=0):this._poolOffset=i,n.append(s),e.type!==Rm.NEW_STREAM&&e.type!==Rm.MESSAGE_INITIATOR&&e.type!==Rm.MESSAGE_RECEIVER||null==e.data||n.append(e.data)}};class Vm extends Error{constructor(e="Stream input buffer error"){super(e),this.name="StreamInputBufferError"}}let Gm=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class Wm extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class jm extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}function $m(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}class Km{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=Ir(),this.closed=Ir(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??5e3,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=Dr({onEnd:e=>{null!=e?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(e){if("ready"!==this.writeStatus)throw new jm(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if("outbound"===this.direction){const e=this.sendNewStream(t);$m(e)&&await e}const n=()=>{Sm(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let n of e){n=n instanceof Uint8Array?new br(n):n;const e=this.sendData(n,t);$m(e)&&(this.sendingData=Ir(),await e,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),"writing"===this.writeStatus&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){null==this.timeline.closeRead&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseRead?.(),null!=this.timeline.closeWrite?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){null==this.timeline.closeWrite&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseWrite?.(),null!=this.timeline.closeRead?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){"open"===this.status&&(this.log.trace("closing gracefully"),this.status="closing",await Nr(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if("closing"===this.readStatus||"closed"===this.readStatus)return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing","reset"!==this.status&&"aborted"!==this.status&&null==this.timeline.closeRead&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),"ready"===t&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){"closing"!==this.writeStatus&&"closed"!==this.writeStatus&&(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),"ready"===this.writeStatus&&(this.log.trace("sink was never sunk, sink an empty array"),await Nr(this.sink([]),e.signal)),"writing"===this.writeStatus&&(null!=this.sendingData&&await Nr(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await Nr(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();$m(t)&&t.catch(e=>{this.log.error("error sending reset message",e)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;const e=new Wm("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){"writing"===this.writeStatus&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){"closing"!==this.readStatus&&"closed"!==this.readStatus&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){"closing"!==this.readStatus&&"closed"!==this.readStatus?(this.log.trace("remote close write"),this._closeSource()):this.log("received remote close write but local source is already closed")}remoteCloseRead(){"closing"!==this.writeStatus&&"closed"!==this.writeStatus?(this.log.trace("remote close read"),this._closeSink()):this.log("received remote close read but local sink is already closed")}destroy(){"closed"!==this.status&&"aborted"!==this.status&&"reset"!==this.status?(this.log.trace("stream destroyed"),this._closeSinkAndSource()):this.log("received destroy but we are already closed")}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}class Xm extends Km{name;streamId;send;types;maxDataSize;constructor(e){super(e),this.types="outbound"===e.direction?km:Nm,this.send=e.send,this.name=e.name,this.streamId=e.streamId,this.maxDataSize=e.maxDataSize}async sendNewStream(){await this.send({id:this.streamId,type:km.NEW_STREAM,data:new br(rt(this.name))})}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxDataSize);await this.send({id:this.streamId,type:this.types.MESSAGE,data:e.sublist(0,t)}),e.consume(t)}}async sendReset(){await this.send({id:this.streamId,type:this.types.RESET})}async sendCloseWrite(){await this.send({id:this.streamId,type:this.types.CLOSE})}async sendCloseRead(){}}function Ym(e){const t={...e,type:`${Dm[e.type]} (${e.type})`};return e.type===Rm.NEW_STREAM&&(t.data=Pn(e.data instanceof Uint8Array?e.data:e.data.subarray())),e.type!==Rm.MESSAGE_INITIATOR&&e.type!==Rm.MESSAGE_RECEIVER||(t.data=Pn(e.data instanceof Uint8Array?e.data:e.data.subarray(),"base16")),t}class Zm{protocol="/mplex/6.7.0";sink;source;log;_streamId;_streams;_init;_source;closeController;rateLimiter;closeTimeout;logger;constructor(e,t){t=t??{},this.log=t.log?.newScope("mplex")??e.logger.forComponent("libp2p:mplex"),this.logger=e.logger,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=t,this.closeTimeout=t.closeTimeout??500,this.sink=this._createSink(),this._source=Dr({objectMode:!0,onEnd:()=>{for(const e of this._streams.initiators.values())e.destroy();for(const e of this._streams.receivers.values())e.destroy()}}),this.source=Ur(this._source,e=>async function*(e){for await(const t of e){const e=new br;qm.write(t,e),yield e}}(e)),this.closeController=new AbortController,this.rateLimiter=new Lm({points:t.disconnectThreshold??5,duration:1})}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new wm("Muxer already closed");const t=this._streamId++;e=null==e?t.toString():e.toString();const n=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:n})}async close(e){if(this.closeController.signal.aborted)return;const t=e?.signal??AbortSignal.timeout(this.closeTimeout);try{await Promise.all(this.streams.map(async e=>e.close({signal:t}))),this._source.end(),await this._source.onEmpty({signal:t}),this.closeController.abort()}catch(e){this.abort(e)}}abort(e){this.closeController.signal.aborted||(this.streams.forEach(t=>{t.abort(e)}),this.closeController.abort(e))}_newReceiverStream(e){const{id:t,name:n}=e,r=this._streams.receivers;return this._newStream({id:t,name:n,type:"receiver",registry:r})}_newStream(e){const{id:t,name:n,type:r,registry:i}=e;if(this.log("new %s stream %s",r,t),"initiator"===r&&this._streams.initiators.size===(this._init.maxOutboundStreams??1024))throw new _m("Too many outbound streams open");if(i.has(t))throw Error(`${r} stream ${t} already exists!`);const s=function(e){const{id:t,name:n,send:r,onEnd:i,type:s="initiator",maxMsgSize:o=Fm}=e,a="initiator"===s?"outbound":"inbound";return new Xm({id:"initiator"===s?"i"+t:"r"+t,streamId:t,name:""+(n??t),direction:a,maxDataSize:o,onEnd:i,send:r,log:e.log.newScope(`${a}:${t}`)})}({id:t,name:n,send:async e=>{this.log.enabled&&this.log.trace("%s stream %s send",r,t,Ym(e)),this._source.push(e)},type:r,onEnd:()=>{this.log("%s stream with id %s and protocol %s ended",r,t,s.protocol),i.delete(t),null!=this._init.onStreamEnd&&this._init.onStreamEnd(s)},maxMsgSize:this._init.maxMsgSize,log:this.log});return i.set(t,s),s}_createSink(){return async e=>{const t=()=>{Sm(e,this.log)};this.closeController.signal.addEventListener("abort",t);try{const t=new Om(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const n of e)for(const e of t.write(n))await this._handleIncoming(e);this._source.end()}catch(e){this.log("error in sink",e),this._source.end(e)}finally{this.closeController.signal.removeEventListener("abort",t)}}}async _handleIncoming(e){const{id:t,type:n}=e;if(this.log.enabled&&this.log.trace("incoming message",Ym(e)),e.type===Rm.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??1024)){this.log("too many inbound streams open"),this._source.push({id:t,type:Rm.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{return this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),void this.abort(Error("Too many open streams"))}return}const n=this._newReceiverStream({id:t,name:Pn(e.data instanceof Uint8Array?e.data:e.data.subarray())});return void(null!=this._init.onIncomingStream&&this._init.onIncomingStream(n))}const r=(1&~n?this._streams.receivers:this._streams.initiators).get(t);if(null==r){this.log("missing stream %s for message type %s",t,Dm[n]);try{await this.rateLimiter.consume("missing-stream",1)}catch{return this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection"),void this.abort(Error("Too many messages for missing streams"))}return}const i=this._init.maxStreamBufferSize??4194304;try{switch(n){case Rm.MESSAGE_INITIATOR:case Rm.MESSAGE_RECEIVER:if(r.sourceReadableLength()>i)throw this._source.push({id:e.id,type:n===Rm.MESSAGE_INITIATOR?Rm.RESET_RECEIVER:Rm.RESET_INITIATOR}),new Vm("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");r.sourcePush(e.data);break;case Rm.CLOSE_INITIATOR:case Rm.CLOSE_RECEIVER:r.remoteCloseWrite();break;case Rm.RESET_INITIATOR:case Rm.RESET_RECEIVER:r.reset();break;default:this.log("unknown message type %s",n)}}catch(e){this.log.error("error while processing message",e),r.abort(e)}}}class Jm{protocol="/mplex/6.7.0";_init;components;constructor(e,t={}){this.components=e,this._init=t}[Symbol.toStringTag]="@libp2p/mplex";[Em]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new Zm(this.components,{...e,...this._init})}}function Qm(e={}){return t=>new Jm(t,e)}let eg=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},tg=class extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}};class ng extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let rg=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};function ig(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e)return t})();for(const t of e)return t}class sg{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.timeout=t.timeout??1e4,this.maxInboundStreams=t.maxInboundStreams??2,this.maxOutboundStreams=t.maxOutboundStreams??1,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now();AbortSignal.timeout(this.timeout).addEventListener("abort",()=>{t?.abort(new rg("ping timeout"))}),Ur(t,async function*(e){let n=0;for await(const r of e){if(n+=r.byteLength,n>32)return void t?.abort(new tg("Too much data received"));yield r}},t).catch(n=>{this.log.error("incoming ping from %p failed with error",e.connection.remotePeer,n),t?.abort(n)}).finally(()=>{const t=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,t)})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),r=Yc(32),i=await this.components.connectionManager.openConnection(e,t);let s,o=()=>{};if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{s=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection}),o=()=>{s?.abort(new eg)},t.signal?.addEventListener("abort",o,{once:!0});const e=await Ur([r],s,async e=>ig(e)),a=Date.now()-n;if(null==e)throw new ng(`Did not receive a ping ack after ${a}ms`);if(!fr(r,e.subarray()))throw new ng(`Received wrong ping ack after ${a}ms`);return this.log("ping %p complete in %dms",i.remotePeer,a),a}catch(e){throw this.log.error("error while pinging %p",i.remotePeer,e),s?.abort(e),e}finally{t.signal?.removeEventListener("abort",o),null!=s&&await s.close()}}}function og(e={}){return t=>new sg(t,e)}const ag=Symbol.for("@libp2p/transport");var lg;(e=>{e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(lg||(lg={}));let cg=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class hg extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}const ug=Symbol.for("@libp2p/service-capabilities"),dg=[6,53,56,54,55];function pg(e){return mg("sni",e)?.value}function fg(e){const t=mg("tcp",e)?.value;return null==t?"":":"+t}function mg(e,t){return t.find(t=>t.name===e)}function gg(e){return e.some(({code:e})=>e===is)}function yg(e,t){const n=bg[e.name];if(null==n)throw Error("Can't interpret protocol "+e.name);const r=n(e,t);return e.code===ns?`[${r}]`:r}const bg={ip4(e){return e.value},ip6(e,t){return 0===t.length?e.value:`[${e.value}]`},tcp(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return`tcp://${yg(n,t)}:${e.value}`},udp(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return`udp://${yg(n,t)}:${e.value}`},dnsaddr(e){return e.value},dns4(e){return e.value},dns6(e){return e.value},dns(e){return e.value},ipfs(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return""+yg(n,t)},p2p(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return""+yg(n,t)},http(e,t){const n=gg(t),r=pg(t),i=fg(t);if(n&&null!=r)return`https://${r}${i}`;const s=n?"https://":"http://",o=t.pop();if(null==o)throw Error("Unexpected end of multiaddr");let a=yg(o,t);return a=a?.replace("tcp://",""),`${s}${a}`},"http-path"(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return`${yg(n,t)}${decodeURIComponent(e.value??"")}`},tls(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return yg(n,t)},sni(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");return yg(n,t)},https(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");let r=yg(n,t);return r=r?.replace("tcp://",""),"https://"+r},ws(e,t){const n=gg(t),r=pg(t),i=fg(t);if(n&&null!=r)return`wss://${r}${i}`;const s=n?"wss://":"ws://",o=t.pop();if(null==o)throw Error("Unexpected end of multiaddr");let a=yg(o,t);return a=a?.replace("tcp://",""),`${s}${a}`},wss(e,t){const n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");let r=yg(n,t);return r=r?.replace("tcp://",""),"wss://"+r}};var vg,wg,xg=async e=>{if(e.readyState>=2)throw Error("socket closed");1!==e.readyState&&await new Promise((t,n)=>{function r(){e.removeEventListener("open",i),e.removeEventListener("error",s)}function i(){r(),t()}function s(t){r(),n(t.error??Error("connect ECONNREFUSED "+e.url))}e.addEventListener("open",i),e.addEventListener("error",s)})},_g=(e,t)=>{(t=t??{}).closeOnEnd=!1!==t.closeOnEnd;return async n=>{for await(const t of n){try{await xg(e)}catch(e){if("socket closed"===e.message)break;throw e}if(e.readyState===e.CLOSING||e.readyState===e.CLOSED)break;e.send(t)}null!=t.closeOnEnd&&e.readyState<=1&&await new Promise((t,n)=>{e.addEventListener("close",e=>{if(e.wasClean||1006===e.code)t();else{const t=Object.assign(Error("ws error"),{event:e});n(t)}}),setTimeout(()=>{e.close()})})}},Eg={},Sg={};var Mg=function(){if(wg)return Eg;wg=1,Object.defineProperty(Eg,"__esModule",{value:!0});const e=function(){if(vg)return Sg;vg=1,Object.defineProperty(Sg,"__esModule",{value:!0});class e{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(e){if(this.isStopped)return;const t={value:e,done:!1};if(this.pullQueue.length){const e=this.pullQueue.shift();e&&e.resolve(t)}else this.pushQueue.push(Promise.resolve(t)),void 0!==this.highWaterMark&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const e of this.pullQueue)e.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(e){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const t of this.pullQueue)t.reject(e);this.pullQueue.length=0}else{const t=Promise.reject(e);t.catch(()=>{}),this.pushQueue.push(t)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:()=>{const e=this.pushQueue.shift();return e?(void 0!==this.lowWaterMark&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),e):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((e,t)=>{this.pullQueue.push({resolve:e,reject:t})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class t{constructor(t,{highWaterMark:n=100,lowWaterMark:r=1}={}){const i=new e;i.highWaterMark=n,i.lowWaterMark=r,i.removeCallback=t({push:e=>i.push(e),stop:()=>i.stop(),fail:e=>i.fail(e),on(e,t){i.eventHandlers[e]=t}})||(()=>{}),this[Symbol.asyncIterator]=()=>i[Symbol.asyncIterator](),Object.freeze(this)}}return Sg.EventIterator=t,Sg.default=t,Sg}();return Eg.EventIterator=e.EventIterator,Eg.subscribe=function(t,n,r){return new e.EventIterator(({push:e})=>(this.addEventListener(t,e,n),()=>this.removeEventListener(t,e,n)),r)},Eg.default=e.EventIterator,Eg}();function Ag(e){return e instanceof ArrayBuffer||"ArrayBuffer"===e?.constructor?.name&&"number"==typeof e?.byteLength}var Cg=(e,t)=>{t=t??{};const n=(e=>{e.binaryType="arraybuffer";const t=async()=>{await new Promise((t,n)=>{if(i)return void t();if(null!=r)return void n(r);const s=t=>{e.removeEventListener("open",o),e.removeEventListener("error",a),t()},o=()=>{s(t)},a=t=>{s(()=>{n(t.error??Error("connect ECONNREFUSED "+e.url))})};e.addEventListener("open",o),e.addEventListener("error",a)})},n=async function*(){const n=new Mg.EventIterator(({push:t,stop:n,fail:r})=>{const i=e=>{let n=null;"string"==typeof e.data&&(n=rt(e.data)),Ag(e.data)&&(n=new Uint8Array(e.data)),e.data instanceof Uint8Array&&(n=e.data),null!=n&&t(n)},s=e=>{r(e.error??Error("Socket error"))};return e.addEventListener("message",i),e.addEventListener("error",s),e.addEventListener("close",n),()=>{e.removeEventListener("message",i),e.removeEventListener("error",s),e.removeEventListener("close",n)}},{highWaterMark:1/0});await t();for await(const e of n)yield Ag(e)?new Uint8Array(e):e}();let r,i=1===e.readyState;return e.addEventListener("open",()=>{i=!0,r=null}),e.addEventListener("close",()=>{i=!1,r=null}),e.addEventListener("error",t=>{i||(r=t.error??Error("connect ECONNREFUSED "+e.url))}),Object.assign(n,{connected:t})})(e);let r=t.remoteAddress,i=t.remotePort;if(null!=e.url)try{const t=new URL(e.url);r=t.hostname,i=parseInt(t.port,10)}catch{}if(null==r||null==i)throw Error("Remote connection did not have address and/or port");return{sink:_g(e,t),source:n,async connected(){await n.connected()},async close(){e.readyState!==e.CONNECTING&&e.readyState!==e.OPEN||await new Promise(t=>{e.addEventListener("close",()=>{t()}),e.close()})},destroy(){null!=e.terminate?e.terminate():e.close()},remoteAddress:r,remotePort:i,socket:e}},Tg=WebSocket;const Ig={"http:":"ws:","https:":"wss:"};function Lg(e,t){t=t??{};const n=((e,t)=>{if(e.startsWith("//")&&(e=`${t?.protocol??"ws:"}${e}`),e.startsWith("/")&&null!=t){const n=t.protocol??"ws:",r=t.host,i=null!=t.port&&!0!==r?.endsWith(":"+t.port)?":"+t.port:"";e=`${n}//${r}${i}${e}`}const n=new URL(e);for(const[e,t]of Object.entries(Ig))n.protocol===e&&(n.protocol=t);return n})(e,"undefined"==typeof window?void 0:window.location),r=new Tg(n.toString(),t.websocket);return Cg(r,t)}class Pg extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}function Rg(e){return e.filter(e=>fm.exactMatch(e)||dm.exactMatch(e))}function Dg(e){return e.filter(e=>fm.exactMatch(e))}let kg=class{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[ag]=!0;[Symbol.toStringTag]="@libp2p/websockets";[ug]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=function(e,t,n){const r=n.metrics,i=n.metricPrefix??"",s={log:n.logger.forComponent("libp2p:websockets:connection"),async sink(t){try{await e.sink(async function*(){for await(const e of t)e instanceof Uint8Array?yield e:yield e.subarray()}())}catch(e){"aborted"!==e.type&&s.log.error(e)}},source:e.source,remoteAddr:t,timeline:{open:Date.now()},async close(t={}){const n=Date.now();if(null==t.signal){const e=AbortSignal.timeout(500);t={...t,signal:e}}const r=()=>{const{host:e,port:t}=s.remoteAddr.toOptions();s.log("timeout closing stream to %s:%s after %dms, destroying it manually",e,t,Date.now()-n),this.abort(new cg("Socket close timeout"))};t.signal?.addEventListener("abort",r);try{await e.close()}catch(e){s.log.error("error closing WebSocket gracefully - %e",e),this.abort(e)}finally{t.signal?.removeEventListener("abort",r),s.timeline.close=Date.now()}},abort(t){s.log.error("destroying WebSocket after error - %e",t),e.destroy(),s.timeline.close=Date.now(),r?.increment({[i+"error"]:!0})}};let o=!1;const a=e.socket.close.bind(e.socket);return e.socket.close=(...e)=>(o=!0,a(...e)),e.socket.addEventListener("close",e=>{s.log('closed %s, code %d, reason "%s", wasClean %s',o?"locally":"by remote",e.code,e.reason,e.wasClean),e.wasClean?(r?.increment({[i+"close"]:!0}),s.timeline.close=Date.now()):s.abort(new hg((o?"Local":"Remote")+" did not close WebSocket cleanly"))},{once:!0}),s}(await this._connect(e,t),e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",n.remoteAddr);const r=await t.upgrader.upgradeOutbound(n,t);return this.log("outbound connection %s upgraded",n.remoteAddr),r}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const r=Ir(),i=Lg(function(e){const t=Us(e).getComponents(),n=t.pop();if(null==n)throw Error("Unexpected end of multiaddr");const r=bg[n.name];if(null==r)throw Error("No interpreter found for "+n.name);let i=r(n,t)??"";return dg.includes(n.code)&&(i=i.replace(/^.*:\/\//,""),i="443"===n.value?"https://"+i:"http://"+i),(i.startsWith("http://")||i.startsWith("https://")||i.startsWith("ws://")||i.startsWith("wss://"))&&(i=new URL(i).toString(),i.endsWith("/")&&(i=i.substring(0,i.length-1))),i}(e),this.init);i.socket.addEventListener("error",()=>{const t=new hg("Could not connect to "+e.toString());this.log.error("connection error:",t),this.metrics?.dialerEvents.increment({error:!0}),r.reject(t)});try{t.onProgress?.(new Pg("websockets:open-connection")),await Nr(Promise.race([i.connected(),r.promise]),t.signal)}catch(e){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(e=>{this.log.error("error closing raw socket",e)}),e}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return function(){throw Error("WebSocket Servers can not be created in the browser!")}((this.logger,this.components.events,this.components.metrics),this.init)}listenFilter(e){return e=Array.isArray(e)?e:[e],null!=this.init?.filter?this.init?.filter(e):Rg(e)}dialFilter(e){return this.listenFilter(e)}};function Ng(e={}){return t=>new kg(t,e)}var Fg,Og={exports:{}};var Bg=(Fg||(Fg=1,function(e){var t={}.hasOwnProperty,n="~";function r(){}function i(e,t,n){this.fn=e,this.context=t,this.once=n||!1}function s(e,t,r,s,o){if("function"!=typeof r)throw new TypeError("The listener must be a function");var a=new i(r,s||e,o),l=n?n+t:t;return e._events[l]?e._events[l].fn?e._events[l]=[e._events[l],a]:e._events[l].push(a):(e._events[l]=a,e._eventsCount++),e}function o(e,t){0===--e._eventsCount?e._events=new r:delete e._events[t]}function a(){this._events=new r,this._eventsCount=0}Object.create&&(r.prototype=Object.create(null),(new r).__proto__||(n=!1)),a.prototype.eventNames=function(){var e,r,i=[];if(0===this._eventsCount)return i;for(r in e=this._events)t.call(e,r)&&i.push(n?r.slice(1):r);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(e)):i},a.prototype.listeners=function(e){var t=n?n+e:e,r=this._events[t];if(!r)return[];if(r.fn)return[r.fn];for(var i=0,s=r.length,o=Array(s);i<s;i++)o[i]=r[i].fn;return o},a.prototype.listenerCount=function(e){var t=n?n+e:e,r=this._events[t];return r?r.fn?1:r.length:0},a.prototype.emit=function(e,t,r,i,s,o){var a=n?n+e:e;if(!this._events[a])return!1;var l,c,h=this._events[a],u=arguments.length;if(h.fn){switch(h.once&&this.removeListener(e,h.fn,void 0,!0),u){case 1:return h.fn.call(h.context),!0;case 2:return h.fn.call(h.context,t),!0;case 3:return h.fn.call(h.context,t,r),!0;case 4:return h.fn.call(h.context,t,r,i),!0;case 5:return h.fn.call(h.context,t,r,i,s),!0;case 6:return h.fn.call(h.context,t,r,i,s,o),!0}for(c=1,l=Array(u-1);c<u;c++)l[c-1]=arguments[c];h.fn.apply(h.context,l)}else{var d,p=h.length;for(c=0;c<p;c++)switch(h[c].once&&this.removeListener(e,h[c].fn,void 0,!0),u){case 1:h[c].fn.call(h[c].context);break;case 2:h[c].fn.call(h[c].context,t);break;case 3:h[c].fn.call(h[c].context,t,r);break;case 4:h[c].fn.call(h[c].context,t,r,i);break;default:if(!l)for(d=1,l=Array(u-1);d<u;d++)l[d-1]=arguments[d];h[c].fn.apply(h[c].context,l)}}return!0},a.prototype.on=function(e,t,n){return s(this,e,t,n,!1)},a.prototype.once=function(e,t,n){return s(this,e,t,n,!0)},a.prototype.removeListener=function(e,t,r,i){var s=n?n+e:e;if(!this._events[s])return this;if(!t)return o(this,s),this;var a=this._events[s];if(a.fn)a.fn!==t||i&&!a.once||r&&a.context!==r||o(this,s);else{for(var l=0,c=[],h=a.length;l<h;l++)(a[l].fn!==t||i&&!a[l].once||r&&a[l].context!==r)&&c.push(a[l]);c.length?this._events[s]=1===c.length?c[0]:c:o(this,s)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=n?n+e:e,this._events[t]&&o(this,t)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=n,a.EventEmitter=a,e.exports=a}(Og)),Og.exports),zg=$n(Bg);class Ug extends Error{constructor(e){super(e),this.name="TimeoutError"}}let Hg=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const qg=e=>void 0===globalThis.DOMException?new Hg(e):new DOMException(e),Vg=e=>{const t=void 0===e.reason?qg("This operation was aborted."):e.reason;return t instanceof Error?t:qg(t)};let Gg=class{#i=[];enqueue(e,t){const n={priority:(t={priority:0,...t}).priority,id:t.id,run:e};if(0===this.size||this.#i[this.size-1].priority>=t.priority)return void this.#i.push(n);const r=function(e,t,n){let r=0,i=e.length;for(;i>0;){const s=Math.trunc(i/2);let o=r+s;n(e[o],t)<=0?(r=++o,i-=s+1):i=s}return r}(this.#i,n,(e,t)=>t.priority-e.priority);this.#i.splice(r,0,n)}setPriority(e,t){const n=this.#i.findIndex(t=>t.id===e);if(-1===n)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[r]=this.#i.splice(n,1);this.enqueue(r.run,{priority:t,id:e})}dequeue(){const e=this.#i.shift();return e?.run}filter(e){return this.#i.filter(t=>t.priority===e.priority).map(e=>e.run)}get size(){return this.#i.length}};class Wg extends zg{#s;#o;#a=0;#l;#c;#h=0;#u;#d;#i;#p;#f=0;#m;#g;#y;#b=1n;timeout;constructor(e){if(super(),!("number"==typeof(e={carryoverConcurrencyCount:!1,intervalCap:1/0,interval:0,concurrency:1/0,autoStart:!0,queueClass:Gg,...e}).intervalCap&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(void 0===e.interval||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#s=e.carryoverConcurrencyCount,this.#o=e.intervalCap===1/0||0===e.interval,this.#l=e.intervalCap,this.#c=e.interval,this.#i=new e.queueClass,this.#p=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#y=!0===e.throwOnTimeout,this.#g=!1===e.autoStart}get#v(){return this.#o||this.#a<this.#l}get#w(){return this.#f<this.#m}#x(){this.#f--,this.#_(),this.emit("next")}#E(){this.#S(),this.#M(),this.#d=void 0}get#A(){const e=Date.now();if(void 0===this.#u){const t=this.#h-e;if(!(t<0))return void 0===this.#d&&(this.#d=setTimeout(()=>{this.#E()},t)),!0;this.#a=this.#s?this.#f:0}return!1}#_(){if(0===this.#i.size)return this.#u&&clearInterval(this.#u),this.#u=void 0,this.emit("empty"),0===this.#f&&this.emit("idle"),!1;if(!this.#g){const e=!this.#A;if(this.#v&&this.#w){const t=this.#i.dequeue();return!!t&&(this.emit("active"),t(),e&&this.#M(),!0)}}return!1}#M(){this.#o||void 0!==this.#u||(this.#u=setInterval(()=>{this.#S()},this.#c),this.#h=Date.now()+this.#c)}#S(){0===this.#a&&0===this.#f&&this.#u&&(clearInterval(this.#u),this.#u=void 0),this.#a=this.#s?this.#f:0,this.#C()}#C(){for(;this.#_(););}get concurrency(){return this.#m}set concurrency(e){if(!("number"==typeof e&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#m=e,this.#C()}async#T(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#i.setPriority(e,t)}async add(e,t={}){return t.id??=""+this.#b++,t={timeout:this.timeout,throwOnTimeout:this.#y,...t},new Promise((n,r)=>{this.#i.enqueue(async()=>{this.#f++;try{t.signal?.throwIfAborted(),this.#a++;let r=e({signal:t.signal});t.timeout&&(r=function(e,t){const{milliseconds:n,fallback:r,message:i,customTimers:s={setTimeout,clearTimeout}}=t;let o,a;const l=new Promise((l,c)=>{if("number"!=typeof n||1!==Math.sign(n))throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${n}\``);if(t.signal){const{signal:e}=t;e.aborted&&c(Vg(e)),a=()=>{c(Vg(e))},e.addEventListener("abort",a,{once:!0})}if(n===1/0)return void e.then(l,c);const h=new Ug;o=s.setTimeout.call(void 0,()=>{if(r)try{l(r())}catch(e){c(e)}else"function"==typeof e.cancel&&e.cancel(),!1===i?l():i instanceof Error?c(i):(h.message=i??`Promise timed out after ${n} milliseconds`,c(h))},n),(async()=>{try{l(await e)}catch(e){c(e)}})()}).finally(()=>{l.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}(Promise.resolve(r),{milliseconds:t.timeout})),t.signal&&(r=Promise.race([r,this.#T(t.signal)]));const i=await r;n(i),this.emit("completed",i)}catch(e){if(e instanceof Ug&&!t.throwOnTimeout)return void n();r(e),this.emit("error",e)}finally{this.#x()}},t),this.emit("add"),this.#_()})}async addAll(e,t){return Promise.all(e.map(async e=>this.add(e,t)))}start(){return this.#g?(this.#g=!1,this.#C(),this):this}pause(){this.#g=!0}clear(){this.#i=new this.#p}async onEmpty(){0!==this.#i.size&&await this.#I("empty")}async onSizeLessThan(e){this.#i.size<e||await this.#I("next",()=>this.#i.size<e)}async onIdle(){0===this.#f&&0===this.#i.size||await this.#I("idle")}async#I(e,t){return new Promise(n=>{const r=()=>{t&&!t()||(this.off(e,r),n())};this.on(e,r)})}get size(){return this.#i.size}sizeBy(e){return this.#i.filter(e).length}get pending(){return this.#f}get isPaused(){return this.#g}}function jg(e){const t=[ty.A];return null==e?t:Array.isArray(e)?0===e.length?t:e:[e]}function $g(e){return{Status:e.Status??0,TC:e.TC??e.flag_tc??!1,RD:e.RD??e.flag_rd??!1,RA:e.RA??e.flag_ra??!1,AD:e.AD??e.flag_ad??!1,CD:e.CD??e.flag_cd??!1,Question:(e.Question??e.questions??[]).map(e=>({name:e.name,type:ty[e.type]})),Answer:(e.Answer??e.answers??[]).map(e=>({name:e.name,type:ty[e.type],TTL:e.TTL??e.ttl??60,data:e.data instanceof Uint8Array?Pn(e.data):e.data}))}}function Kg(e,t={}){const n=new Wg({concurrency:t.queryConcurrency??4});return async(t,r={})=>{const i=new URLSearchParams;i.set("name",t),jg(r.types).forEach(e=>{i.append("type",ty[e])}),r.onProgress?.(new Pg("dns:query",t));const s=await n.add(async()=>{const t=await fetch(`${e}?${i}`,{headers:{accept:"application/dns-json"},signal:r?.signal});if(200!==t.status)throw Error(`Unexpected HTTP status: ${t.status} - ${t.statusText}`);const n=$g(await t.json());return r.onProgress?.(new Pg("dns:response",n)),n},{signal:r.signal});if(null==s)throw Error("No DNS response received");return s}}var Xg,Yg;var Zg=(Yg||(Yg=1,Xg=e=>{if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,n=Object.create(null),r=Object.create(null);function i(i,s){n[i]=s,++t>=e&&(t=0,r=n,n=Object.create(null))}return{has:e=>void 0!==n[e]||void 0!==r[e],remove(e){void 0!==n[e]&&(n[e]=void 0),void 0!==r[e]&&(r[e]=void 0)},get(e){var t=n[e];return void 0!==t?t:void 0!==(t=r[e])?(i(e,t),t):void 0},set(e,t){void 0!==n[e]?n[e]=t:i(e,t)},clear(){n=Object.create(null),r=Object.create(null)}}}),Xg),Jg=$n(Zg);class Qg{lru;constructor(e){this.lru=Jg(e)}get(e,t){let n=!0;const r=[];for(const i of t){const t=this.getAnswers(e,i);if(0===t.length){n=!1;break}r.push(...t)}if(n)return $g({answers:r})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,r=this.lru.get(n);if(null!=r){const e=r.filter(e=>e.expires>Date.now()).map(({expires:e,value:t})=>({...t,TTL:Math.round((e-Date.now())/1e3),type:ty[t.type]}));return 0===e.length&&this.lru.remove(n),e}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,r=this.lru.get(n)??[];r.push({expires:Date.now()+1e3*(t.TTL??60),value:t}),this.lru.set(n,r)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}class ey{resolvers;cache;constructor(e){var t;this.resolvers={},this.cache=(t=e.cacheSize??1e3,new Qg(t)),Object.entries(e.resolvers??{}).forEach(([e,t])=>{Array.isArray(t)||(t=[t]),e.endsWith(".")||(e+="."),this.resolvers[e]=t}),null==this.resolvers["."]&&(this.resolvers["."]=[Kg("https://cloudflare-dns.com/dns-query"),Kg("https://dns.google/resolve")])}async query(e,t={}){const n=jg(t.types),r=!1!==t.cached?this.cache.get(e,n):void 0;if(null!=r)return t.onProgress?.(new Pg("dns:cache",r)),r;const i=e.split(".").pop()+".",s=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),o=[];for(const r of s){if(!0===t.signal?.aborted)break;try{const i=await r(e,{...t,types:n});for(const t of i.Answer)this.cache.add(e,t);return i}catch(e){o.push(e),t.onProgress?.(new Pg("dns:error",e))}}if(1===o.length)throw o[0];throw new AggregateError(o,`DNS lookup of ${e} ${n} failed`)}}var ty;(e=>{e[e.A=1]="A",e[e.CNAME=5]="CNAME",e[e.TXT=16]="TXT",e[e.AAAA=28]="AAAA"})(ty||(ty={}));const ny=-1,ry={},iy={};[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,ny,"ip6zone"],[43,8,"ipcidr"],[53,ny,"dns",!0],[54,ny,"dns4",!0],[55,ny,"dns6",!0],[56,ny,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,ny,"unix",!1,!0],[421,ny,"ipfs"],[421,ny,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,ny,"garlic64"],[448,0,"tls"],[449,ny,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,ny,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,ny,"http-path"],[777,ny,"memory"]].forEach(e=>{const t=function(e,t,n,r,i){return{code:e,size:t,name:n,resolvable:!!r,path:!!i}}(...e);iy[t.code]=t,ry[t.name]=t});const{code:sy}=function(e){if(null!=ry[e])return ry[e];throw Error("no protocol with name: "+e)}("dnsaddr");class oy extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const ay=async function(e,t={}){const n=t.maxRecursiveDepth??32;if(0===n)throw new oy("Max recursive depth reached");const[,r]=e.stringTuples().find(([e])=>e===sy)??[],i=t?.dns??function(e={}){return new ey(e)}(),s=await i.query("_dnsaddr."+r,{signal:t?.signal,types:[ty.TXT]}),o=e.getPeerId(),a=[];for(const e of s.Answer){const r=e.data.replace(/["']/g,"").trim().split("=")[1];if(null==r)continue;if(null!=o&&!r.includes(o))continue;const i=Us(r);if(r.startsWith("/dnsaddr")){const e=await i.resolve({...t,maxRecursiveDepth:n-1});a.push(...e.map(e=>e.toString()))}else a.push(i.toString())}return a};var ly,cy,hy,uy;var dy=function(){if(uy)return hy;uy=1;const e=(cy||(cy=1,ly=e=>{if("[object Object]"!=={}.toString.call(e))return!1;const t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}),ly),{hasOwnProperty:t}=Object.prototype,{propertyIsEnumerable:n}=Object,r=(e,t,n)=>Object.defineProperty(e,t,{value:n,writable:!0,enumerable:!0,configurable:!0}),i=hy,s={concatArrays:!1,ignoreUndefined:!1},o=e=>{const r=[];for(const n in e)t.call(e,n)&&r.push(n);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(e);for(const i of t)n.call(e,i)&&r.push(i)}return r};function a(t){return Array.isArray(t)?function(e){const t=e.slice(0,0);return o(e).forEach(n=>{r(t,n,a(e[n]))}),t}(t):e(t)?function(e){const t=null===Object.getPrototypeOf(e)?Object.create(null):{};return o(e).forEach(n=>{r(t,n,a(e[n]))}),t}(t):t}const l=(e,t,n,i)=>(n.forEach(n=>{void 0===t[n]&&i.ignoreUndefined||(n in e&&e[n]!==Object.getPrototypeOf(e)?r(e,n,h(e[n],t[n],i)):r(e,n,a(t[n])))}),e),c=(e,n,i)=>{let s=e.slice(0,0),c=0;return[e,n].forEach(n=>{const h=[];for(let i=0;i<n.length;i++)t.call(n,i)&&(h.push(i+""),r(s,c++,n===e?n[i]:a(n[i])));s=l(s,n,o(n).filter(e=>!h.includes(e)),i)}),s};function h(t,n,r){return r.concatArrays&&Array.isArray(t)&&Array.isArray(n)?c(t,n,r):e(n)&&e(t)?l(t,n,o(n),r):a(n)}return hy=function(...t){const n=h(a(s),this!==i&&this||{},s);let r={_:{}};for(const i of t)if(void 0!==i){if(!e(i))throw new TypeError("`"+i+"` is not an Option Object");r=h(r,{_:i},n)}return r._},hy}(),py=$n(dy);const fy={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter(e){return e}},connectionManager:{resolvers:{dnsaddr:ay}},transportManager:{faultTolerance:Ci.FATAL_ALL}};async function my(e){const t=py(fy,e);if(null===t.connectionProtector&&null!=globalThis.process?.env?.LIBP2P_FORCE_PNET)throw new Ii("Private network is enforced, but no protector was provided");return t}const gy=1e3,yy=60*gy,by=60*yy,vy=24*by,wy=7*vy,xy=365.25*vy,_y=xy/12;var Ey=function(e,t){if("string"==typeof e)return Sy(e);if("number"==typeof e)return function(e,t){if("number"!=typeof e||!Number.isFinite(e))throw Error("Value provided to ms.format() must be of type number.");return t?.long?Ay(e):My(e)}(e,t);throw Error("Value provided to ms() must be a string or number. value="+JSON.stringify(e))};function Sy(e){if("string"!=typeof e||0===e.length||e.length>100)throw Error("Value provided to ms.parse() must be a string with length between 1 and 99. value="+JSON.stringify(e));let t=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(e);if(!t?.groups)return NaN;let{value:n,unit:r="ms"}=t.groups,i=parseFloat(n),s=r.toLowerCase();switch(s){case"years":case"year":case"yrs":case"yr":case"y":return i*xy;case"months":case"month":case"mo":return i*_y;case"weeks":case"week":case"w":return i*wy;case"days":case"day":case"d":return i*vy;case"hours":case"hour":case"hrs":case"hr":case"h":return i*by;case"minutes":case"minute":case"mins":case"min":case"m":return i*yy;case"seconds":case"second":case"secs":case"sec":case"s":return i*gy;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return i;default:throw Error(`Unknown unit "${s}" provided to ms.parse(). value=${JSON.stringify(e)}`)}}function My(e){let t=Math.abs(e);return t>=xy?Math.round(e/xy)+"y":t>=_y?Math.round(e/_y)+"mo":t>=wy?Math.round(e/wy)+"w":t>=vy?Math.round(e/vy)+"d":t>=by?Math.round(e/by)+"h":t>=yy?Math.round(e/yy)+"m":t>=gy?Math.round(e/gy)+"s":e+"ms"}function Ay(e){let t=Math.abs(e);return t>=xy?Cy(e,t,xy,"year"):t>=_y?Cy(e,t,_y,"month"):t>=wy?Cy(e,t,wy,"week"):t>=vy?Cy(e,t,vy,"day"):t>=by?Cy(e,t,by,"hour"):t>=yy?Cy(e,t,yy,"minute"):t>=gy?Cy(e,t,gy,"second"):e+" ms"}function Cy(e,t,n,r){let i=t>=1.5*n;return`${Math.round(e/n)} ${r}${i?"s":""}`}const Ty=function(){try{return localStorage}catch(e){}}();const Iy=console.debug??console.log??(()=>{});var Ly=function(e){function t(e){let r,i,s,o=null;function a(...e){if(!a.enabled)return;const n=a,i=Number(new Date),s=i-(r||i);n.diff=s,n.prev=r,n.curr=i,r=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let o=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(r,i)=>{if("%%"===r)return"%";o++;const s=t.formatters[i];if("function"==typeof s){const t=e[o];r=s.call(n,t),e.splice(o,1),o--}return r}),t.formatArgs.call(n,e);(n.log||t.log).apply(n,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=n,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get(){return null!==o?o:(i!==t.namespaces&&(i=t.namespaces,s=t.enabled(e)),s)},set(e){o=e}}),"function"==typeof t.init&&t.init(a),a}function n(e,n){const r=t(this.namespace+(void 0===n?":":n)+e);return r.log=this.log,r}function r(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){if(e instanceof Error)return e.stack??e.message;return e},t.disable=function(){const e=[...t.names.map(r),...t.skips.map(r).map(e=>"-"+e)].join(",");return t.enable(""),e},t.enable=function(e){let n;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const r=("string"==typeof e?e:"").split(/[\s,]+/),i=r.length;for(n=0;n<i;n++)r[n]&&("-"===(e=r[n].replace(/\*/g,".*?"))[0]?t.skips.push(RegExp("^"+e.substr(1)+"$")):t.names.push(RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let n,r;for(n=0,r=t.skips.length;n<r;n++)if(t.skips[n].test(e))return!1;for(n=0,r=t.names.length;n<r;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=Ey,t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach(n=>{t[n]=e[n]}),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.setupFormatters(t.formatters),t.enable(t.load()),t}({formatArgs(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+Ey(this.diff),!this.useColors)return;const t="color: "+this.color;e.splice(1,0,t,"color: inherit");let n=0,r=0;e[0].replace(/%[a-zA-Z%]/g,e=>{"%%"!==e&&(n++,"%c"===e&&(r=n))}),e.splice(r,0,t)},save(e){try{e?Ty?.setItem("debug",e):Ty?.removeItem("debug")}catch(e){}},load(){let e;try{e=Ty?.getItem("debug")}catch(e){}return!e&&void 0!==globalThis.process&&"env"in globalThis.process&&(e=globalThis.process.env.DEBUG),e},useColors(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||null==navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement?.style?.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&null!=navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/))},setupFormatters(e){e.j=e=>{try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},colors:["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],storage:Ty,log:Iy});function Py(){return{forComponent:e=>Ry(e)}}function Ry(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}(e+":trace");return Ly.enabled(e+":trace")&&null!=Ly.names.map(e=>e.toString()).find(e=>e.includes(":trace"))&&(t=Ly(e+":trace")),Object.assign(Ly(e),{error:Ly(e+":error"),trace:t,newScope(t){return Ry(`${e}:${t}`)}})}function Dy(e){if(null!=e&&0!==(e=e.trim()).length)return e}function ky(e,t){const n={[Symbol.iterator](){return n},next(){const n=e.next(),r=n.value;if(!0===n.done||null==r){return{done:!0,value:void 0}}return{done:!1,value:t(r)}}};return n}function Ny(e){return qh(Oe(ue.decode("z"+e)))}Ly.formatters.b=e=>null==e?"undefined":ue.baseEncode(e),Ly.formatters.t=e=>null==e?"undefined":J.baseEncode(e),Ly.formatters.m=e=>null==e?"undefined":fe.baseEncode(e),Ly.formatters.p=e=>null==e?"undefined":e.toString(),Ly.formatters.c=e=>null==e?"undefined":e.toString(),Ly.formatters.k=e=>null==e?"undefined":e.toString(),Ly.formatters.a=e=>null==e?"undefined":e.toString(),Ly.formatters.e=e=>null==e?"undefined":Dy(e.stack)??Dy(e.message)??e.toString();class Fy{map;constructor(e){if(this.map=new Map,null!=e)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return ky(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach(t=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return ky(this.map.values(),e=>e.key)}values(){return ky(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Oy{set;constructor(e){if(this.set=new Set,null!=e)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return ky(this.set.entries(),e=>{const t=Ny(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=Ny(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return ky(this.set.values(),e=>Ny(e))}intersection(e){const t=new Oy;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new Oy;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new Oy;for(const n of e)t.add(n);for(const e of this)t.add(e);return t}}const By={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},zy={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Uy=new globalThis.TextEncoder;function Hy(e,{size:t=32,utf8Buffer:n}={}){if(!By[t])throw Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if("string"==typeof e){if(n)return function(e,t,n){if(0===n.length)throw Error("The `utf8Buffer` option must have a length greater than zero");const r=By[t];let i=zy[t],s=e;for(;s.length>0;){const e=Uy.encodeInto(s,n);s=s.slice(e.read);for(let s=0;s<e.written;s++)i^=BigInt(n[s]),i=BigInt.asUintN(t,i*r)}return i}(e,t,n);e=Uy.encode(e)}return function(e,t){const n=By[t];let r=zy[t];for(let i=0;i<e.length;i++)r^=BigInt(e[i]),r=BigInt.asUintN(t,r*n);return r}(e,t)}const qy={hash(e){return Number(Hy(e,{size:32}))},hashV(e,t){return function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);return rt(t,"base16")}(qy.hash(e,t))}};class Vy{fp;h;seed;constructor(t,n,r,i=2){if(i>64)throw new TypeError("Invalid Fingerprint Size");const s=n.hashV(t,r),o=e(i);for(let e=0;e<o.length;e++)o[e]=s[e];0===o.length&&(o[0]=7),this.fp=o,this.h=n,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array&&fr(this.fp,e.fp)}}function Gy(e,t){return Math.floor(Math.random()*(t-e))+e}class Wy{contents;constructor(e){this.contents=Array(e).fill(null)}has(e){if(!(e instanceof Vy))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Vy))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(null==this.contents[t])return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Vy))throw new TypeError("Invalid Fingerprint");const t=Gy(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof Vy))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(t=>e.equals(t));return t>-1&&(this.contents[t]=null,!0)}}class jy{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??qy,this.seed=e.seed??Gy(0,1024)}add(e){"string"==typeof e&&(e=rt(e));const t=new Vy(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,r=(n^t.hash())%this.filterSize;if(null==this.buckets[n]&&(this.buckets[n]=new Wy(this.bucketSize)),null==this.buckets[r]&&(this.buckets[r]=new Wy(this.bucketSize)),this.buckets[n].add(t)||this.buckets[r].add(t))return this.count++,!0;const i=[n,r];let s=i[Gy(0,i.length-1)];null==this.buckets[s]&&(this.buckets[s]=new Wy(this.bucketSize));for(let e=0;e<500;e++){const e=this.buckets[s].swap(t);if(null!=e&&(s=(s^e.hash())%this.filterSize,null==this.buckets[s]&&(this.buckets[s]=new Wy(this.bucketSize)),this.buckets[s].add(e)))return this.count++,!0}return!1}has(e){"string"==typeof e&&(e=rt(e));const t=new Vy(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,r=this.buckets[n]?.has(t)??!1;if(r)return r;const i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){"string"==typeof e&&(e=rt(e));const t=new Vy(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,r=this.buckets[n]?.remove(t)??!1;if(r)return this.count--,r;const i=(n^t.hash())%this.filterSize,s=this.buckets[i]?.remove(t)??!1;return s&&this.count--,s}get reliable(){return Math.floor(this.count/this.filterSize*100)<=90}}const $y={1:.5,2:.84,4:.95,8:.98};function Ky(e,t=.001){const n=function(e=.001){return e>.002?2:e>1e-5?4:8}(t);return{filterSize:Math.round(e/$y[n]),bucketSize:n,fingerprintSize:Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*n)),64)}}class Xy{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??qy,this.seed=e.seed??Gy(0,1024),this.filterSeries=[new jy({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if("string"==typeof e&&(e=rt(e)),this.has(e))return!0;let t=this.filterSeries.find(e=>e.reliable);if(null==t){const e=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new jy({filterSize:e,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){"string"==typeof e&&(e=rt(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){"string"==typeof e&&(e=rt(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}class Yy extends Fy{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}const Zy=Symbol.for("@libp2p/peer-id");function Jy(e){return!!e?.[Zy]}class Qy extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}let eb=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}},tb=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};async function nb(e,t,n,r){const i=new tb(r?.errorMessage);null!=r?.errorCode&&(i.code=r.errorCode);const s=r?.errorEvent??"error";return!0===n?.aborted?Promise.reject(i):new Promise((o,a)=>{function l(){ib(n,"abort",u),ib(e,t,c),ib(e,s,h)}const c=e=>{try{if(!1===r?.filter?.(e))return}catch(e){return l(),void a(e)}l(),o(e)},h=e=>{l(),a(e instanceof Error?e:e.detail??r?.error??Error(`The "${r?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},u=()=>{l(),a(i)};rb(n,"abort",u),rb(e,t,c),rb(e,s,h)})}function rb(e,t,n){null!=e&&(sb(e)?e.addEventListener(t,n):e.addListener(t,n))}function ib(e,t,n){null!=e&&(sb(e)?e.removeEventListener(t,n):e.removeListener(t,n))}function sb(e){return"function"==typeof e.addEventListener&&"function"==typeof e.removeEventListener}class ob extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}let ab=class{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new tb)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};let lb=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(1e9*Math.random()+"",10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((e,t)=>e&&!0===t.signal?.aborted,!0)&&(this.controller.abort(new tb),this.cleanup())}async join(e={}){const t=new ab(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Nr(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}};function cb(e,t){let n;const r=()=>{clearTimeout(n),n=setTimeout(()=>{n=void 0,e()},t)};return r.start=()=>{},r.stop=()=>{clearTimeout(n)},r}let hb=class extends Hi{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??1/0,this.maxSize=e.maxSize??1/0,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=cb(this.emitEmpty.bind(this),1),this.emitIdle=cb(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}start(){!1===this.autoStart&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new ob;const n=new lb(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),n.join(t).then(e=>(this.safeDispatchEvent("success",{detail:{job:n,result:e}}),e)).catch(e=>{if("queued"===n.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===n){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:n,error:e}}),e})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new tb)}),this.clear()}async onEmpty(e){0!==this.size&&await nb(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await nb(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await nb(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=Dr({objectMode:!0}),n=e=>{null!=e?this.abort():this.clear(),t.end(e)},r=e=>{null!=e.detail&&t.push(e.detail.result)},i=e=>{n(e.detail.error)},s=()=>{n()},o=()=>{n(new tb("Queue aborted"))};this.addEventListener("success",r),this.addEventListener("failure",i),this.addEventListener("idle",s),e?.signal?.addEventListener("abort",o);try{yield*t}finally{this.removeEventListener("success",r),this.removeEventListener("failure",i),this.removeEventListener("idle",s),e?.signal?.removeEventListener("abort",o),n()}}};const ub="lock:worker:request-read",db="lock:worker:abort-read-request",pb="lock:worker:release-read",fb="lock:master:grant-read",mb="lock:master:error-read",gb="lock:worker:request-write",yb="lock:worker:abort-write-request",bb="lock:worker:release-write",vb="lock:master:grant-write",wb="lock:master:error-write",xb="lock:worker:finalize",_b="mortice",Eb={singleProcess:!1},Sb=(e,t,n,r,i,s,o,a,l)=>c=>{if(null==c.data)return;const h={type:c.data.type,name:c.data.name,identifier:c.data.identifier};h.type===i&&e.safeDispatchEvent(n,{detail:{name:h.name,identifier:h.identifier,async handler(){t.postMessage({type:l,name:h.name,identifier:h.identifier}),await new Promise(e=>{const n=r=>{if(null==r?.data)return;const i=r.data.type,s=(r.data.name,r.data.identifier);i===a&&s===h.identifier&&(t.removeEventListener("message",n),e())};t.addEventListener("message",n)})},onError(e){t.postMessage({type:o,name:h.name,identifier:h.identifier,error:{message:e.message,name:e.name,stack:e.stack}})}}}),h.type===s&&e.safeDispatchEvent(r,{detail:{name:h.name,identifier:h.identifier}}),h.type===xb&&e.safeDispatchEvent("finalizeRequest",{detail:{name:h.name}})};class Mb{name;channel;constructor(e){this.name=e,this.channel=new BroadcastChannel(_b)}readLock(e){return this.sendRequest(ub,db,fb,mb,pb,e)}writeLock(e){return this.sendRequest(gb,yb,vb,wb,bb,e)}finalize(){this.channel.postMessage({type:xb,name:this.name}),this.channel.close()}async sendRequest(e,t,n,r,i,s){s?.signal?.throwIfAborted();const o=((e=10)=>Math.random().toString().substring(2,e+2))();return this.channel.postMessage({type:e,identifier:o,name:this.name}),new Promise((e,a)=>{const l=()=>{this.channel.postMessage({type:t,identifier:o,name:this.name})};s?.signal?.addEventListener("abort",l,{once:!0});const c=t=>{if(t.data?.identifier===o&&(t.data?.type===n&&(this.channel.removeEventListener("message",c),s?.signal?.removeEventListener("abort",l),e(()=>{this.channel.postMessage({type:i,identifier:o,name:this.name})})),t.data.type===r)){this.channel.removeEventListener("message",c),s?.signal?.removeEventListener("abort",l);const e=Error();null!=t.data.error&&(e.message=t.data.error.message,e.name=t.data.error.name,e.stack=t.data.error.stack),a(e)}};this.channel.addEventListener("message",c)})}}const Ab=new Map;let Cb;function Tb(e){return"function"==typeof e?.readLock&&"function"==typeof e?.writeLock}function Ib(e){if(null==Cb&&(Cb=(e=>{if(e=Object.assign({},Eb,e),!!globalThis.document||e.singleProcess){const e=new BroadcastChannel(_b),t=new Hi;return e.addEventListener("message",Sb(t,e,"requestReadLock","abortReadLockRequest",ub,db,mb,pb,fb)),e.addEventListener("message",Sb(t,e,"requestWriteLock","abortWriteLockRequest",gb,yb,wb,bb,vb)),t}return new Mb(e.name)})(e),!Tb(Cb))){const e=Cb;e.addEventListener("requestReadLock",t=>{const n=t.detail.name,r=t.detail.identifier,i=Ab.get(n);if(null==i)return;const s=new AbortController,o=e=>{e.detail.name===n&&e.detail.identifier===r&&s.abort()};e.addEventListener("abortReadLockRequest",o),i.readLock({signal:s.signal}).then(async e=>{await t.detail.handler().finally(()=>{e()})}).catch(e=>{t.detail.onError(e)}).finally(()=>{e.removeEventListener("abortReadLockRequest",o)})}),e.addEventListener("requestWriteLock",t=>{const n=t.detail.name,r=t.detail.identifier,i=Ab.get(n);if(null==i)return;const s=new AbortController,o=e=>{e.detail.name===n&&e.detail.identifier===r&&s.abort()};e.addEventListener("abortWriteLockRequest",o),i.writeLock({signal:s.signal}).then(async e=>{await t.detail.handler().finally(()=>{e()})}).catch(e=>{t.detail.onError(e)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",o)})}),e.addEventListener("finalizeRequest",e=>{const t=e.detail.name,n=Ab.get(t);null!=n&&n.finalize()})}return Cb}async function Lb(e,t){let n,r;const i=new Promise((e,t)=>{n=e,r=t}),s=()=>{r(new tb)};return t?.signal?.addEventListener("abort",s,{once:!0}),e.add(async()=>{await new Promise(e=>{n(()=>{t?.signal?.removeEventListener("abort",s),e()})})},{signal:t?.signal}).catch(e=>{r(e)}),i}const Pb={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function Rb(e){const t=Object.assign({},Pb,e);return((e,t)=>{let n=Ab.get(e);if(null!=n)return n;const r=Ib(t);if(Tb(r))return n=r,Ab.set(e,n),n;const i=new hb({concurrency:1});let s;return n={async readLock(e){if(null!=s)return Lb(s,e);s=new hb({concurrency:t.concurrency,autoStart:!1});const n=s,r=Lb(s,e);return i.add(async()=>{n.start(),await n.onIdle().then(()=>{s===n&&(s=null)})}),r},async writeLock(e){return s=null,Lb(i,e)},finalize(){Ab.delete(e)},queue:i},Ab.set(e,n),!0===t.autoFinalize&&i.addEventListener("idle",()=>{n.finalize()},{once:!0}),n})(t.name,t)}var Db,kb,Nb;function Fb(e,t){if(null!=e.publicKey||null==t.publicKey)return e;let n;"RSA"===e.type&&(n=e.toMultihash());return Hh(Mh(t.publicKey,n))}function Ob(e,t,n){const r=new Map,i=BigInt(Date.now());for(const[e,n]of t.tags.entries())null!=n.expiry&&n.expiry<i||r.set(e,n);return{...t,id:Fb(e,t),addresses:t.addresses.filter(({observed:e})=>null!=e&&e>Date.now()-n).map(({multiaddr:e,isCertified:t})=>({multiaddr:Us(e),isCertified:t??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:r}}function Bb(e,t){return h=e.addresses,u=t.addresses,Ub(h,u,(e,t)=>e.isCertified===t.isCertified&&!!fr(e.multiaddr,t.multiaddr))&&(l=e.protocols,c=t.protocols,Ub(l,c,(e,t)=>e===t))&&(o=e.publicKey,a=t.publicKey,zb(o,a))&&(i=e.peerRecordEnvelope,s=t.peerRecordEnvelope,zb(i,s))&&(n=e.metadata,r=t.metadata,Hb(n,r,(e,t)=>fr(e,t)))&&function(e,t){return Hb(e,t,(e,t)=>e.value===t.value&&e.expiry===t.expiry)}(e.tags,t.tags);var n,r,i,s,o,a,l,c,h,u}function zb(e,t){return null==e&&null==t||null!=e&&null!=t&&fr(e,t)}function Ub(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(!n(e[r],t[r]))return!1;return!0}function Hb(e,t,n){if(e.size!==t.size)return!1;for(const[r,i]of e.entries()){const e=t.get(r);if(null==e)return!1;if(!n(i,e))return!1}return!0}(t=>{let n;(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&e.value.byteLength>0&&(t.uint32(18),t.bytes(e.value)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={key:"",value:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.key=t.string();break;case 2:r.value=t.bytes();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(t.Peer$metadataEntry||(t.Peer$metadataEntry={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&(t.uint32(18),Nb.codec().encode(e.value,t)),!1!==n.lengthDelimited&&t.ldelim()},(e,t,n={})=>{const r={key:""},i=null==t?e.len:e.pos+t;for(;e.pos<i;){const t=e.uint32();switch(t>>>3){case 1:r.key=e.string();break;case 2:r.value=Nb.codec().decode(e,e.uint32(),{limits:n.limits?.value});break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(t.Peer$tagsEntry||(t.Peer$tagsEntry={})),t.codec=()=>(null==n&&(n=Jt((e,n,r={})=>{if(!1!==r.lengthDelimited&&n.fork(),null!=e.addresses)for(const t of e.addresses)n.uint32(10),kb.codec().encode(t,n);if(null!=e.protocols)for(const t of e.protocols)n.uint32(18),n.string(t);if(null!=e.publicKey&&(n.uint32(34),n.bytes(e.publicKey)),null!=e.peerRecordEnvelope&&(n.uint32(42),n.bytes(e.peerRecordEnvelope)),null!=e.metadata&&0!==e.metadata.size)for(const[r,i]of e.metadata.entries())n.uint32(50),t.Peer$metadataEntry.codec().encode({key:r,value:i},n);if(null!=e.tags&&0!==e.tags.size)for(const[r,i]of e.tags.entries())n.uint32(58),t.Peer$tagsEntry.codec().encode({key:r,value:i},n);null!=e.updated&&(n.uint32(64),n.uint64Number(e.updated)),!1!==r.lengthDelimited&&n.ldelim()},(e,n,r={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},s=null==n?e.len:e.pos+n;for(;e.pos<s;){const n=e.uint32();switch(n>>>3){case 1:if(null!=r.limits?.addresses&&i.addresses.length===r.limits.addresses)throw new Qt('Decode error - map field "addresses" had too many elements');i.addresses.push(kb.codec().decode(e,e.uint32(),{limits:r.limits?.addresses$}));break;case 2:if(null!=r.limits?.protocols&&i.protocols.length===r.limits.protocols)throw new Qt('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break;case 4:i.publicKey=e.bytes();break;case 5:i.peerRecordEnvelope=e.bytes();break;case 6:{if(null!=r.limits?.metadata&&i.metadata.size===r.limits.metadata)throw new en('Decode error - map field "metadata" had too many elements');const n=t.Peer$metadataEntry.codec().decode(e,e.uint32());i.metadata.set(n.key,n.value);break}case 7:{if(null!=r.limits?.tags&&i.tags.size===r.limits.tags)throw new en('Decode error - map field "tags" had too many elements');const n=t.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:r.limits?.tags$value}});i.tags.set(n.key,n.value);break}case 8:i.updated=e.uint64Number();break;default:e.skipType(7&n)}}return i})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(Db||(Db={})),(t=>{let n;t.codec=()=>(null==n&&(n=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),null!=e.isCertified&&(t.uint32(16),t.bool(e.isCertified)),null!=e.observed&&(t.uint32(24),t.uint64Number(e.observed)),!1!==n.lengthDelimited&&t.ldelim()},(t,n)=>{const r={multiaddr:e(0)},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:r.multiaddr=t.bytes();break;case 2:r.isCertified=t.bool();break;case 3:r.observed=t.uint64Number();break;default:t.skipType(7&e)}}return r})),n),t.encode=e=>yt(e,t.codec()),t.decode=(e,n)=>T(e,t.codec(),n)})(kb||(kb={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,n={})=>{!1!==n.lengthDelimited&&t.fork(),null!=e.value&&0!==e.value&&(t.uint32(8),t.uint32(e.value)),null!=e.expiry&&(t.uint32(16),t.uint64(e.expiry)),!1!==n.lengthDelimited&&t.ldelim()},(e,t)=>{const n={value:0},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.value=e.uint32();break;case 2:n.expiry=e.uint64();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>yt(t,e.codec()),e.decode=(t,n)=>T(t,e.codec(),n)})(Nb||(Nb={}));const qb="/",Vb=(new TextEncoder).encode(qb),Gb=Vb[0];class Wb{_buf;constructor(e,t){if("string"==typeof e)this._buf=rt(e);else{if(!(e instanceof Uint8Array))throw Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==Gb)throw Error("Invalid key")}toString(e="utf8"){return Pn(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Wb(e.join(qb))}static random(){return new Wb(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||"string"==typeof e?new Wb(e):"function"==typeof e.uint8Array?new Wb(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=Vb),this._buf[0]!==Gb){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Gb,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Gb;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let e=0;e<t.length;e++){if(n.length<e+1)return!1;const r=t[e],i=n[e];if(r<i)return!0;if(r>i)return!1}return t.length<n.length}reverse(){return Wb.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(qb).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new Wb(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(qb)||(e+=qb),e+=this.type(),new Wb(e)}parent(){const e=this.list();return 1===e.length?new Wb(qb):new Wb(e.slice(0,-1).join(qb))}child(e){return this.toString()===qb?e:e.toString()===qb?this:new Wb(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(...e){return Wb.withNamespaces([...this.namespaces(),...(t=e.map(e=>e.namespaces()),[].concat(...t))]);var t}}const jb="/peers/";function $b(e){if(!Jy(e)||null==e.type)throw new Qy("Invalid PeerId");const t=e.toCID().toString();return new Wb(`${jb}${t}`)}async function Kb(e,t,n,r,i){const s=new Map;for(const r of n){if(null==r)continue;if(r.multiaddr instanceof Uint8Array&&(r.multiaddr=Us(r.multiaddr)),!zs(r.multiaddr))throw new Qy("Multiaddr was invalid");if(!await t(e,r.multiaddr,i))continue;const n=r.isCertified??!1,o=r.multiaddr.toString(),a=s.get(o);null!=a?r.isCertified=a.isCertified||n:s.set(o,{multiaddr:r.multiaddr,isCertified:n})}return[...s.values()].sort((e,t)=>e.multiaddr.toString().localeCompare(t.multiaddr.toString())).map(({isCertified:t,multiaddr:n})=>{const r=n.getPeerId();return e.equals(r)&&(n=n.decapsulate(Us("/p2p/"+e))),{isCertified:t,multiaddr:n.bytes}})}async function Xb(e,t,n,r){if(null==t)throw new Qy("Invalid PeerData");if(null!=t.publicKey&&null!=e.publicKey&&!t.publicKey.equals(e.publicKey))throw new Qy("publicKey bytes do not match peer id publicKey bytes");const i=r.existingPeer?.peer;if(null!=i&&!e.equals(i.id))throw new Qy("peer id did not match existing peer id");let s,o=i?.addresses??[],a=new Set(i?.protocols??[]),l=i?.metadata??new Map,c=i?.tags??new Map,h=i?.peerRecordEnvelope;if("patch"===n){if(null==t.multiaddrs&&null==t.addresses||(o=[],null!=t.multiaddrs&&o.push(...t.multiaddrs.map(e=>({isCertified:!1,multiaddr:e}))),null!=t.addresses&&o.push(...t.addresses)),null!=t.protocols&&(a=new Set(t.protocols)),null!=t.metadata){l=Yb(t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata),{validate:Zb})}if(null!=t.tags){c=Yb(t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),{validate:Jb,map:Qb})}null!=t.peerRecordEnvelope&&(h=t.peerRecordEnvelope)}if("merge"===n){if(null!=t.multiaddrs&&o.push(...t.multiaddrs.map(e=>({isCertified:!1,multiaddr:e}))),null!=t.addresses&&o.push(...t.addresses),null!=t.protocols&&(a=new Set([...a,...t.protocols])),null!=t.metadata){const e=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[t,n]of e)null==n?l.delete(t):l.set(t,n);l=Yb([...l.entries()],{validate:Zb})}if(null!=t.tags){const e=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),n=new Map(c);for(const[t,r]of e)null==r?n.delete(t):n.set(t,r);c=Yb([...n.entries()],{validate:Jb,map:Qb})}null!=t.peerRecordEnvelope&&(h=t.peerRecordEnvelope)}null!=i?.id.publicKey?s=Ah(i.id.publicKey):null!=t.publicKey?s=Ah(t.publicKey):null!=e.publicKey&&(s=Ah(e.publicKey));const u={addresses:await Kb(e,r.addressFilter??(async()=>!0),o,r.existingPeer?.peerPB.addresses,r),protocols:[...a.values()].sort((e,t)=>e.localeCompare(t)),metadata:l,tags:c,publicKey:s,peerRecordEnvelope:h};return u.addresses.forEach(e=>{e.observed=r.existingPeer?.peerPB.addresses?.find(e=>fr(e.multiaddr,e.multiaddr))?.observed??Date.now()}),"RSA"!==e.type&&delete u.publicKey,u}function Yb(e,t){const n=new Map;for(const[n,r]of e)null!=r&&t.validate(n,r);for(const[r,i]of e.sort(([e],[t])=>e.localeCompare(t)))null!=i&&n.set(r,t.map?.(r,i)??i);return n}function Zb(e,t){if("string"!=typeof e)throw new Qy("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new Qy("Metadata value must be a Uint8Array")}function Jb(e,t){if("string"!=typeof e)throw new Qy("Tag name must be a string");if(null!=t.value){if(parseInt(""+t.value,10)!==t.value)throw new Qy("Tag value must be an integer");if(t.value<0||t.value>100)throw new Qy("Tag value must be between 0-100")}if(null!=t.ttl){if(parseInt(""+t.ttl,10)!==t.ttl)throw new Qy("Tag ttl must be an integer");if(t.ttl<0)throw new Qy("Tag ttl must be between greater than 0")}}function Qb(e,t){let n;null!=t.expiry&&(n=t.expiry),null!=t.ttl&&(n=BigInt(Date.now()+Number(t.ttl)));const r={value:t.value??0};return null!=n&&(r.expiry=n),r}function ev(e){const t=e.toString().split("/")[2];return Vh($e.parse(t,J))}function tv(e,t,n){return function(e,t,n){return Ob(e,Db.decode(t),n)}(ev(e),t,n)}class nv{peerId;datastore;locks;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=function(e){const{name:t,metrics:n}=e;let r;return r=null!=n?new Yy({name:t,metrics:n}):new Fy,r}({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??36e5,this.maxPeerAge=t.maxPeerAge??216e5}getLock(e){let t=this.locks.get(e);return null==t&&(t={refs:0,lock:Rb({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,0===t.refs&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const n=this.getLock(e);try{const r=await n.lock.readLock(t);return()=>{r(),this.maybeRemoveLock(e,n)}}catch(t){throw this.maybeRemoveLock(e,n),t}}async getWriteLock(e,t){const n=this.getLock(e);try{const r=await n.lock.writeLock(t);return()=>{r(),this.maybeRemoveLock(e,n)}}catch(t){throw this.maybeRemoveLock(e,n),t}}async has(e,t){try{return await this.load(e,t),!0}catch(e){if("NotFoundError"!==e.name)throw e}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete($b(e),t)}async load(e,t){const n=$b(e),r=await this.datastore.get(n,t),i=Db.decode(r);if(this.#L(e,i))throw await this.datastore.delete(n,t),new eb;return Ob(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,n){const r=await this.#P(e,n),i=await Xb(e,t,"patch",{...n,addressFilter:this.addressFilter});return this.#R(e,i,r)}async patch(e,t,n){const r=await this.#P(e,n),i=await Xb(e,t,"patch",{...n,addressFilter:this.addressFilter,existingPeer:r});return this.#R(e,i,r)}async merge(e,t,n){const r=await this.#P(e,n),i=await Xb(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:r});return this.#R(e,i,r)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(function(e,t){return{prefix:jb,filters:(e.filters??[]).map(e=>({key:n,value:r})=>e(tv(n,r,t))),orders:(e.orders??[]).map(e=>(n,r)=>e(tv(n.key,n.value,t),tv(r.key,r.value,t)))}}(e??{},this.maxAddressAge),e)){const r=ev(t);if(r.equals(this.peerId))continue;const i=Db.decode(n);this.#L(r,i)?await this.datastore.delete(t,e):yield Ob(r,i,this.peerId.equals(r)?1/0:this.maxAddressAge)}}async#P(e,t){try{const n=$b(e),r=await this.datastore.get(n,t),i=Db.decode(r);if(this.#L(e,i))throw await this.datastore.delete(n,t),new eb;return{peerPB:i,peer:Ob(e,i,this.maxAddressAge)}}catch(e){"NotFoundError"!==e.name&&this.log.error("invalid peer data found in peer store - %e",e)}}async#R(e,t,n,r){t.updated=Date.now();const i=Db.encode(t);return await this.datastore.put($b(e),i,r),{peer:Ob(e,t,this.maxAddressAge),previous:n?.peer,updated:null==n||!Bb(t,n.peerPB)}}#L(e,t){if(null==t.updated)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,r=Date.now()-this.maxAddressAge,i=t.addresses.filter(e=>null!=e.observed&&e.observed>r);return n&&0===i.length}}class rv{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new nv(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){for await(const n of this.store.all(t))e(n)}async all(e){return dr(this.store.all(e))}async delete(e,t){const n=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{n()}}async has(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),n?.()}}async get(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{n?.()}}async getInfo(e,t){const n=await this.get(e,t);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:e})=>e)}}async save(e,t,n){const r=await this.store.getWriteLock(e,n);try{const r=await this.store.save(e,t,n);return this.#D(e,r),r.peer}finally{r?.()}}async patch(e,t,n){const r=await this.store.getWriteLock(e,n);try{const r=await this.store.patch(e,t,n);return this.#D(e,r),r.peer}finally{r?.()}}async merge(e,t,n){const r=await this.store.getWriteLock(e,n);try{const r=await this.store.merge(e,t,n);return this.#D(e,r),r.peer}finally{r?.()}}async consumePeerRecord(e,t,n){const r=Jy(t)?t:Jy(t?.expectedPeer)?t.expectedPeer:void 0,i=Jy(t)||void 0===t?n:t,s=await bf.openAndCertify(e,_f.DOMAIN,i),o=Vh(s.publicKey.toCID());if(!1===r?.equals(o))return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",r,o),!1;const a=_f.createFromProtobuf(s.payload);let l;try{l=await this.get(o,i)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=l?.peerRecordEnvelope){const e=bf.createFromProtobuf(l.peerRecordEnvelope),t=_f.createFromProtobuf(e.payload);if(t.seqNumber>=a.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",t.seqNumber,a.seqNumber),!1}return await this.patch(a.peerId,{peerRecordEnvelope:e,addresses:a.multiaddrs.map(e=>({isCertified:!0,multiaddr:e}))},i),!0}#D(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}class iv extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=iv.name;code=iv.code;constructor(e="Not Found"){super(e)}}function sv(e,t){let n=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const r of e)await t(r,n++)&&(yield r)}();const r=function(e){const[t,n]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push(e){r.push(e)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[n](){return this}}}(e),{value:i,done:s}=r.next();if(!0===s)return function*(){}();const o=t(i,n++);if("function"==typeof o.then)return async function*(){await o&&(yield i);for(const e of r)await t(e,n++)&&(yield e)}();const a=t;return function*(){!0===o&&(yield i);for(const e of r)a(e,n++)&&(yield e)}()}function ov(e,t){return null!=e[Symbol.asyncIterator]?async function*(){const n=await dr(e);yield*n.sort(t)}():function*(){const n=dr(e);yield*n.sort(t)}()}function av(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let n=0;if(!(t<1))for await(const r of e)if(yield r,n++,n===t)return}():function*(){let n=0;if(!(t<1))for(const r of e)if(yield r,n++,n===t)return}()}class lv{put(e,t,n){return Promise.reject(Error(".put is not implemented"))}get(e,t){return Promise.reject(Error(".get is not implemented"))}has(e,t){return Promise.reject(Error(".has is not implemented"))}delete(e,t){return Promise.reject(Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:r}of e)await this.put(n,r,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(t,n){e.push({key:t,value:n})},delete(e){t.push(e)},commit:async n=>{await Sf(this.putMany(e,n)),e=[],await Sf(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw Error("._all is not implemented")}async*_allKeys(e,t){throw Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(null!=e.prefix){const t=e.prefix;n=sv(n,e=>e.key.toString().startsWith(t))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((e,t)=>sv(e,t),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((e,t)=>ov(e,t),n)),null!=e.offset){let t=0;const r=e.offset;n=sv(n,()=>t++>=r)}return null!=e.limit&&(n=av(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;n=sv(n,e=>e.toString().startsWith(t))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((e,t)=>sv(e,t),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((e,t)=>ov(e,t),n)),null!=e.offset){const t=e.offset;let r=0;n=sv(n,()=>r++>=t)}return null!=e.limit&&(n=av(n,e.limit)),n}}class cv extends lv{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(null==n)throw new iv;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[e,n]of this.data.entries())yield{key:new Wb(e),value:n},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const e of this.data.keys())yield new Wb(e),t?.signal?.throwIfAborted()}}const hv=e=>e;function uv(e,t){const n=e.getPeerId();if(null!=n){Uh(n).equals(t)&&(e=e.decapsulate(Us("/p2p/"+t.toString())))}return e}class dv{log;components;listen;announce;observed;announceFilter;constructor(e,t={}){const{listen:n=[],announce:r=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(e=>e.toString()),this.announce=new Set(r.map(e=>e.toString())),this.observed=new Map,this.announceFilter=t.announceFilter??hv,this._updatePeerStoreAddresses=function(e,t){let n;return()=>{clearTimeout(n),n=setTimeout(()=>{n=void 0,e()},t)}}(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([e,t])=>t.confident).map(([e])=>Us(e))).map(e=>e.getPeerId()===this.components.peerId.toString()?e.decapsulate("/p2p/"+this.components.peerId.toString()):e);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(e=>{this.log.error("error updating addresses",e)})}getListenAddrs(){return Array.from(this.listen).map(e=>Us(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Us(e))}getObservedAddrs(){return Array.from(this.observed).map(([e])=>Us(e))}addObservedAddr(e){const t=(e=uv(e,this.components.peerId)).toString();this.observed.has(t)||this.observed.set(t,{confident:!1})}confirmObservedAddr(e){const t=(e=uv(e,this.components.peerId)).toString(),n=(this.observed.get(t)??{confident:!1}).confident;this.observed.set(t,{confident:!0}),n||this._updatePeerStoreAddresses()}removeObservedAddr(e){const t=(e=uv(e,this.components.peerId)).toString();this.observed.delete(t)}getAddresses(){let e=this.getAnnounceAddrs().map(e=>e.toString());0===e.length&&(e=this.components.transportManager.getAddrs().map(e=>e.toString())),e=e.concat(Array.from(this.observed).filter(([e,t])=>t.confident).map(([e])=>e));const t=new Set(e);return this.announceFilter(Array.from(t).map(e=>Us(e))).map(e=>!0===e.protos().pop()?.path||e.getPeerId()===this.components.peerId.toString()?e:e.encapsulate("/p2p/"+this.components.peerId.toString()))}}var pv;(e=>{e.NOT_STARTED_YET="The libp2p node is not started yet",e.NOT_FOUND="Not found"})(pv||(pv={}));class fv extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class mv extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class gv extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class yv extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class bv extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class vv extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class wv extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class xv extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class _v extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class Ev extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class Sv extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Mv extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Av extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class Cv extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class Tv{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;null==this.components.logger&&(this.components.logger=Py())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(e=>qi(e)).map(async t=>{await(t[e]?.())}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Iv=["metrics","connectionProtector","dns"],Lv=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function Pv(e){return Array.isArray(e?.[Vi])?e[Vi]:[]}function Rv(e){return Array.isArray(e?.[Gi])?e[Gi]:[]}function Dv(e){return e?.[Symbol.toStringTag]??e?.toString()??"unknown"}function kv(e={}){return{async denyDialPeer(){return!1},async denyDialMultiaddr(e){const t=e.stringTuples();return(4===t[0][0]||41===t[0][0])&&!!Hf(""+t[0][1])},async denyInboundConnection(){return!1},async denyOutboundConnection(){return!1},async denyInboundEncryptedConnection(){return!1},async denyOutboundEncryptedConnection(){return!1},async denyInboundUpgradedConnection(){return!1},async denyOutboundUpgradedConnection(){return!1},async filterMultiaddrForPeer(){return!0},...e}}function Nv(e){if(Si(e))return{peerId:e,multiaddrs:[]};let t;if(Array.isArray(e)||(e=[e]),e.length>0){const n=e[0].getPeerId();t=null==n?void 0:Uh(n),e.forEach(e=>{if(!zs(e))throw new ki("Invalid multiaddr");const n=e.getPeerId();if(null==n){if(null!=t)throw new Ii("Multiaddrs must all have the same peer id or have no peer id")}else{const e=Uh(n);if(!0!==t?.equals(e))throw new Ii("Multiaddrs must all have the same peer id or have no peer id")}})}return{peerId:t,multiaddrs:e}}const Fv=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];const Ov="last-dial-failure",Bv="last-dial-success",zv={maxConnections:100,allow:[]};class Uv{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??zv.maxConnections,this.allow=t.allow??zv.allow,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const n=new Fy;for(const t of e){const e=t.remotePeer;if(!n.has(e)){n.set(e,0);try{const t=await this.peerStore.get(e);n.set(e,[...t.tags.values()].reduce((e,t)=>e+t.value,0))}catch(e){"NotFoundError"!==e.name&&this.log.error("error loading peer tags",e)}}}const r=this.sortConnections(e,n),i=Math.max(t-this.maxConnections,0),s=[];for(const e of r){this.log("too many connections open - closing a connection to %p",e.remotePeer);const t=this.allow.some(t=>e.remoteAddr.toString().startsWith(t.toString()));if(t||s.push(e),s.length===i)break}await Promise.all(s.map(async e=>{await async function(e,t){const n=e?.streams?.map(e=>e.protocol)??[],r=t?.closableProtocols??Fv;if(!(n.filter(e=>null!=e&&!r.includes(e)).length>0))try{await(e?.close(t))}catch(t){e?.abort(t)}}(e,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:s})}sortConnections(e,t){return e.sort((e,t)=>{const n=e.timeline.open,r=t.timeline.open;return n<r?1:n>r?-1:0}).sort((e,t)=>"outbound"===e.direction&&"inbound"===t.direction?1:"inbound"===e.direction&&"outbound"===t.direction?-1:0).sort((e,t)=>e.streams.length>t.streams.length?1:e.streams.length<t.streams.length?-1:0).sort((e,n)=>{const r=t.get(e.remotePeer)??0,i=t.get(n.remotePeer)??0;return r>i?1:r<i?-1:0})}}class Hv{deferred;signal;constructor(e){this.signal=e,this.deferred=Ir(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Gm)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}class qv{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(1e9*Math.random()+"",10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((e,t)=>e&&!0===t.signal?.aborted,!0)&&(this.controller.abort(new Gm),this.cleanup())}async join(e={}){const t=new Hv(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Nr(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class Vv extends Hi{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??1/0,this.maxSize=e.maxSize??1/0,this.pending=0,null!=e.metricName&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=Ef(this.emitEmpty.bind(this),1),this.emitIdle=Ef(this.emitIdle.bind(this),1)}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Im;const n=new qv(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(e=>(this.safeDispatchEvent("completed",{detail:e}),this.safeDispatchEvent("success",{detail:{job:n,result:e}}),e)).catch(e=>{if("queued"===n.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===n){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:n,error:e}}),e})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Gm)}),this.clear()}async onEmpty(e){0!==this.size&&await nb(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await nb(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await nb(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=Dr({objectMode:!0}),n=e=>{null!=e?this.abort():this.clear(),t.end(e)},r=e=>{null!=e.detail&&t.push(e.detail)},i=e=>{n(e.detail.error)},s=()=>{n()},o=()=>{n(new Gm("Queue aborted"))};this.addEventListener("completed",r),this.addEventListener("failure",i),this.addEventListener("idle",s),e?.signal?.addEventListener("abort",o);try{yield*t}finally{this.removeEventListener("completed",r),this.removeEventListener("failure",i),this.removeEventListener("idle",s),e?.signal?.removeEventListener("abort",o),n()}}}class Gv extends Vv{constructor(e={}){super({...e,sort(e,t){return e.options.priority>t.options.priority?-1:e.options.priority<t.options.priority?1:0}})}}const Wv=e=>({match(t){return!(t.length<1)&&(!!e(t[0])&&t.slice(1))},pattern:"fn"}),jv=e=>({match(t){return Wv(t=>t===e).match(t)},pattern:e}),$v=()=>({match(e){return Wv(e=>"string"==typeof e).match(e)},pattern:"{string}"}),Kv=()=>({match(e){return Wv(e=>!isNaN(parseInt(e))).match(e)},pattern:"{number}"}),Xv=()=>({match(e){if(e.length<2)return!1;if("p2p"!==e[0]&&"ipfs"!==e[0])return!1;if(!e[1].startsWith("Q")&&!e[1].startsWith("1"))return!1;try{ue.decode("z"+e[1])}catch(e){return!1}return e.slice(2)},pattern:"/p2p/{peerid}"}),Yv=()=>({match(e){if(e.length<2)return!1;if("certhash"!==e[0])return!1;try{ge.decode(e[1])}catch{return!1}return e.slice(2)},pattern:"/certhash/{certhash}"}),Zv=e=>({match(t){const n=e.match(t);return!1===n?t:n},pattern:`optional(${e.pattern})`}),Jv=(...e)=>({match(t){let n;for(const r of e){const e=r.match(t);!1!==e&&((null==n||e.length<n.length)&&(n=e))}return null!=n&&n},pattern:`or(${e.map(e=>e.pattern).join(", ")})`}),Qv=(...e)=>({match(t){for(const n of e){const e=n.match(t);if(!1===e)return!1;t=e}return t},pattern:`and(${e.map(e=>e.pattern).join(", ")})`});function ew(...e){function t(t){let n=(e=>e.toString().split("/").slice(1))(t);for(const t of e){const e=t.match(n);if(!1===e)return!1;n=e}return n}return{matchers:e,matches(e){return!1!==t(e)},exactMatch(e){const n=t(e);return!1!==n&&0===n.length}}}ew(Xv());const tw=Qv(jv("dns4"),$v()),nw=Qv(jv("dns6"),$v()),rw=Qv(jv("dnsaddr"),$v()),iw=Qv(jv("dns"),$v());ew(tw,Zv(Xv())),ew(nw,Zv(Xv())),ew(rw,Zv(Xv())),ew(Jv(iw,rw,tw,nw),Zv(Xv()));const sw=Qv(jv("ip4"),Wv(Qi)),ow=Qv(jv("ip6"),Wv(es)),aw=Jv(sw,ow),lw=Jv(aw,iw,tw,nw,rw);ew(Jv(aw,Qv(Jv(iw,rw,tw,nw),Zv(Xv())))),ew(sw),ew(ow),ew(aw);const cw=Qv(lw,jv("tcp"),Kv()),hw=Qv(lw,jv("udp"),Kv()),uw=ew(Qv(cw,Zv(Xv())));ew(hw);const dw=Qv(hw,jv("quic"),Zv(Xv())),pw=Qv(hw,jv("quic-v1"),Zv(Xv())),fw=Jv(dw,pw);ew(dw),ew(pw);const mw=Jv(lw,cw,hw,dw,pw),gw=Jv(Qv(mw,jv("ws"),Zv(Xv()))),yw=ew(gw),bw=Jv(Qv(mw,jv("wss"),Zv(Xv())),Qv(mw,jv("tls"),Zv(Qv(jv("sni"),$v())),jv("ws"),Zv(Xv()))),vw=ew(bw),ww=Qv(hw,jv("webrtc-direct"),Zv(Yv()),Zv(Yv()),Zv(Xv())),xw=ew(ww),_w=Qv(pw,jv("webtransport"),Zv(Yv()),Zv(Yv()),Zv(Xv())),Ew=ew(_w),Sw=Jv(gw,bw,Qv(cw,Zv(Xv())),Qv(fw,Zv(Xv())),Qv(lw,Zv(Xv())),ww,_w,Xv());ew(Sw);const Mw=ew(Qv(Sw,jv("p2p-circuit"),Xv())),Aw=ew(Jv(Qv(Sw,jv("p2p-circuit"),jv("webrtc"),Zv(Xv())),Qv(Sw,jv("webrtc"),Zv(Xv())),Qv(jv("webrtc"),Zv(Xv()))));ew(Jv(Qv(lw,jv("tcp"),Kv(),jv("http"),Zv(Xv())),Qv(lw,jv("http"),Zv(Xv()))));ew(Jv(Qv(lw,jv("tcp"),Jv(Qv(jv("443"),jv("http")),Qv(Kv(),jv("https")),Qv(Kv(),jv("tls"),jv("http"))),Zv(Xv())),Qv(lw,jv("tls"),jv("http"),Zv(Xv())),Qv(lw,jv("https"),Zv(Xv()))));ew(Jv(Qv(jv("memory"),$v(),Zv(Xv()))));function Cw(e){const t=new globalThis.AbortController;function n(){t.abort();for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",n)}for(const t of e){if(!0===t?.aborted){n();break}null!=t?.addEventListener&&t.addEventListener("abort",n)}const r=t.signal;return r.clear=function(){for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",n)},r}function Tw(e,t){const n=uw.exactMatch(e.multiaddr),r=uw.exactMatch(t.multiaddr);if(n&&!r)return-1;if(!n&&r)return 1;const i=vw.exactMatch(e.multiaddr),s=vw.exactMatch(t.multiaddr);if(i&&!s)return-1;if(!i&&s)return 1;const o=yw.exactMatch(e.multiaddr),a=yw.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const l=Aw.exactMatch(e.multiaddr),c=Aw.exactMatch(t.multiaddr);if(l&&!c)return-1;if(!l&&c)return 1;const h=xw.exactMatch(e.multiaddr),u=xw.exactMatch(t.multiaddr);if(h&&!u)return-1;if(!h&&u)return 1;const d=Ew.exactMatch(e.multiaddr),p=Ew.exactMatch(t.multiaddr);return d&&!p?-1:!d&&p?1:0}function Iw(e,t){const n=qf(e.multiaddr),r=qf(t.multiaddr);return n&&!r?1:!n&&r?-1:0}function Lw(e,t){return e.isCertified&&!t.isCertified?-1:!e.isCertified&&t.isCertified?1:0}function Pw(e,t){const n=Mw.exactMatch(e.multiaddr),r=Mw.exactMatch(t.multiaddr);return n&&!r?1:!n&&r?-1:0}ew(Jv(Qv(jv("unix"),$v(),Zv(Xv()))));const Rw=50,Dw=500,kw=25,Nw=5e3;class Fw{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??kw,this.maxDialQueueLength=t.maxDialQueueLength??Dw,this.dialTimeout=t.dialTimeout??Nw,this.connections=t.connections??new Fy,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[e,n]of Object.entries(t.resolvers??{}))Bs.set(e,n);this.queue=new Gv({concurrency:t.maxParallelDials??Rw,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",e=>{e.detail.name!==Ti.name&&this.log.error("error in dial queue - %e",e.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:r}=Nv(e),i=Array.from(this.connections.values()).flat().find(e=>!0!==t.force&&(!!e.remotePeer.equals(n)||r.find(t=>t.equals(e.remoteAddr))));if("open"===i?.status)return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new Pg("dial-queue:already-connected")),i;const s=this.queue.queue.find(e=>{if(!0===n?.equals(e.options.peerId))return!0;const t=e.options.multiaddrs;if(null==t)return!1;for(const e of r)if(t.has(e.toString()))return!0;return!1});if(null!=s){this.log("joining existing dial target for %p",n);for(const e of r)s.options.multiaddrs.add(e.toString());return t.onProgress?.(new Pg("dial-queue:already-in-dial-queue")),s.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Oi("Dial queue is full");return this.log("creating dial target for %p",n,r.map(e=>e.toString())),t.onProgress?.(new Pg("dial-queue:add-to-dial-queue")),this.queue.add(async e=>{e?.onProgress?.(new Pg("dial-queue:start-dial"));const t=this.createDialAbortController(e?.signal);let r;try{r=await this.calculateMultiaddrs(n,e?.multiaddrs,{...e,signal:t}),e?.onProgress?.(new Pg("dial-queue:calculated-addresses",r)),r.map(({multiaddr:e})=>e.toString()).forEach(t=>{e?.multiaddrs.add(t)})}catch(e){throw t.clear(),e}try{let i=0;const s=[];for(const o of r){if(i===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",i,n),new Oi("Peer had more than maxPeerAddrsToDial");i++;try{const r=await this.components.transportManager.dial(o.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",o.multiaddr);try{await this.components.peerStore.merge(r.remotePeer,{multiaddrs:[r.remoteAddr],metadata:{[Bv]:rt(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",n,e)}return r}catch(e){if(this.log.error("dial failed to %a",o.multiaddr,e),null!=n)try{await this.components.peerStore.merge(n,{metadata:{[Ov]:rt(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",n,e)}if(t.aborted)throw new Ni(e.message);s.push(e)}}if(1===s.length)throw s[0];throw new AggregateError(s,"All multiaddr dials failed")}finally{t.clear()}},{peerId:n,priority:t.priority??Qw,multiaddrs:new Set(r.map(e=>e.toString())),signal:t.signal,onProgress:t.onProgress})}createDialAbortController(e){return Cw([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,e])}async calculateMultiaddrs(e,t=new Set,n={}){const r=[...t].map(e=>({multiaddr:Us(e),isCertified:!1}));if(null!=e){if(this.components.peerId.equals(e))throw new Oi("Tried to dial self");if(!0===await(this.components.connectionGater.denyDialPeer?.(e)))throw new xv("The dial request is blocked by gater.allowDialPeer");if(0===r.length){this.log("loading multiaddrs for %p",e);try{const t=await this.components.peerStore.get(e);r.push(...t.addresses),this.log("loaded multiaddrs for %p",e,r.map(({multiaddr:e})=>e.toString()))}catch(e){if("NotFoundError"!==e.name)throw e}}if(0===r.length){this.log("looking up multiaddrs for %p in the peer routing",e);try{const t=await this.components.peerRouting.findPeer(e);this.log("found multiaddrs for %p in the peer routing",e,r.map(({multiaddr:e})=>e.toString())),r.push(...t.multiaddrs.map(e=>({multiaddr:e,isCertified:!1})))}catch(t){"NoPeerRoutersError"!==t.name&&this.log.error("looking up multiaddrs for %p in the peer routing failed",e,t)}}}let i=(await Promise.all(r.map(async e=>{const t=await async function(e,t){let n=!1;for(const t of Bs.keys())if(n=e.protoNames().includes(t),n)break;if(!n)return[e];const r=await e.resolve(t);return t.log("resolved %s to",e,r.map(e=>e.toString())),r}(e.multiaddr,{dns:this.components.dns,...n,log:this.log});return 1===t.length&&t[0].equals(e.multiaddr)?e:t.map(e=>({multiaddr:e,isCertified:!1}))}))).flat();if(null!=e){const t="/p2p/"+e.toString();i=i.map(e=>{const n=e.multiaddr.protos().pop();return!0===n?.path?e:null==e.multiaddr.getPeerId()?{multiaddr:e.multiaddr.encapsulate(t),isCertified:e.isCertified}:e})}const s=i.filter(t=>{if(null==this.components.transportManager.dialTransportForMultiaddr(t.multiaddr))return!1;const n=t.multiaddr.getPeerId();return null==e||null==n||e.equals(n)}),o=new Map;for(const e of s){const t=e.multiaddr.toString(),n=o.get(t);null==n?o.set(t,e):n.isCertified=n.isCertified||e.isCertified||!1}const a=[...o.values()];if(0===a.length)throw new _v("The dial request has no valid addresses");const l=[];for(const e of a)null!=this.components.connectionGater.denyDialMultiaddr&&await this.components.connectionGater.denyDialMultiaddr(e.multiaddr)||l.push(e);const c=null==this.addressSorter?l.sort(Tw).sort(Lw).sort(Pw).sort(Iw):l.sort(this.addressSorter);if(0===c.length)throw new xv("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:e})=>e.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",c.map(({multiaddr:e})=>e.toString())),c}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(e=>e.toString())),t);return!1!==t.runOnLimitedConnection||null!=n.find(e=>!Mw.matches(e.multiaddr))}catch(e){this.log.trace("error calculating if multiaddr(s) were dialable",e)}return!1}}class Ow extends Vv{has(e){return null!=this.find(e)}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}var Bw,zw,Uw,Hw,qw,Vw={};function Gw(){return Uw||(Uw=1,e=Vw,t=function(){if(zw)return Bw;function e(e,t){"boolean"==typeof t&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return zw=1,Bw=e,e.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},e.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},e.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=(new Date).getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(void 0===n){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1)}var r=this;return this._timer=setTimeout(()=>{r._attempts++,r._operationTimeoutCb&&(r._timeout=setTimeout(()=>{r._operationTimeoutCb(r._attempts)},r._operationTimeout),r._options.unref&&r._timeout.unref()),r._fn(r._attempts)},n),this._options.unref&&this._timer.unref(),!0},e.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(()=>{n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},e.prototype.try=function(e){this.attempt(e)},e.prototype.start=function(e){this.attempt(e)},e.prototype.start=e.prototype.try,e.prototype.errors=function(){return this._errors},e.prototype.attempts=function(){return this._attempts},e.prototype.mainError=function(){if(0===this._errors.length)return null;for(var e={},t=null,n=0,r=0;r<this._errors.length;r++){var i=this._errors[r],s=i.message,o=(e[s]||0)+1;e[s]=o,o>=n&&(t=i,n=o)}return t},Bw}(),e.operation=n=>{var r=e.timeouts(n);return new t(r,{forever:n&&(n.forever||n.retries===1/0),unref:n&&n.unref,maxRetryTime:n&&n.maxRetryTime})},e.timeouts=function(e){if(e instanceof Array)return[].concat(e);var t={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var n in e)t[n]=e[n];if(t.minTimeout>t.maxTimeout)throw Error("minTimeout is greater than maxTimeout");for(var r=[],i=0;i<t.retries;i++)r.push(this.createTimeout(i,t));return e&&e.forever&&!r.length&&r.push(this.createTimeout(i,t)),r.sort((e,t)=>e-t),r},e.createTimeout=(e,t)=>{var n=t.randomize?Math.random()+1:1,r=Math.round(n*Math.max(t.minTimeout,1)*Math.pow(t.factor,e));return r=Math.min(r,t.maxTimeout)},e.wrap=function(t,n,r){if(n instanceof Array&&(r=n,n=null),!r)for(var i in r=[],t)"function"==typeof t[i]&&r.push(i);for(var s=0;s<r.length;s++){var o=r[s],a=t[o];t[o]=function(r){var i=e.operation(n),s=[].slice.call(arguments,1),o=s.pop();s.push(function(e){i.retry(e)||(e&&(arguments[0]=i.mainError()),o.apply(this,arguments))}),i.attempt(()=>{r.apply(t,s)})}.bind(t,a),t[o].options=n}}),Vw;var e,t}var Ww=$n(qw?Hw:(qw=1,Hw=Gw()));const jw={}.toString,$w=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function Kw(e){const t=e&&(e=>"[object Error]"===jw.call(e))(e)&&"TypeError"===e.name&&"string"==typeof e.message;if(!t)return!1;const{message:n,stack:r}=e;return"Load failed"===n?void 0===r||"__sentry_captured__"in e:!!n.startsWith("error sending request for url")||$w.has(n)}class Xw extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,({message:e}=e)):(this.originalError=Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const Yw=(e,t,n)=>{const r=n.retries-(t-1);return e.attemptNumber=t,e.retriesLeft=r,e};class Zw{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new Ow({concurrency:t.maxParallelReconnects??5,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",e=>{this.maybeReconnect(e.detail).catch(t=>{this.log.error("failed to maybe reconnect to %p - %e",e.detail,t)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Jw(t)&&(this.queue.has(e)||this.queue.add(async t=>{await async function(e,t){return new Promise((n,r)=>{t={...t},t.onFailedAttempt??=()=>{},t.shouldRetry??=()=>!0,t.retries??=10;const i=Ww.operation(t),s=()=>{i.stop(),r(t.signal?.reason)};t.signal&&!t.signal.aborted&&t.signal.addEventListener("abort",s,{once:!0});const o=()=>{t.signal?.removeEventListener("abort",s),i.stop()};i.attempt(async s=>{try{const t=await e(s);o(),n(t)}catch(e){try{if(!(e instanceof Error))throw new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`);if(e instanceof Xw)throw e.originalError;if(e instanceof TypeError&&!Kw(e))throw e;if(Yw(e,s,t),await t.shouldRetry(e)||(i.stop(),r(e)),await t.onFailedAttempt(e),!i.retry(e))throw i.mainError()}catch(e){Yw(e,s,t),o(),r(e)}}})})}(async n=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:t?.signal})}catch(t){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,n,this.retries,t),t}},{signal:t?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const r={};[...t.tags.keys()].forEach(e=>{e.startsWith(Ai)&&(r[e]=void 0)}),await this.peerStore.merge(e,{tags:r}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async t=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,t)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[e=>Jw(e)]});await Promise.all(e.map(async e=>{await this.connectionManager.openConnection(e.id).catch(e=>{this.log.error(e)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function Jw(e){for(const t of e.tags.keys())if(t.startsWith(Ai))return!0;return!1}const Qw=50,ex=100,tx=5,nx=10;class rx{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??ex,this.maxConnections<1)throw new Ii("Connection Manager maxConnections must be greater than 0");this.connections=new Fy,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(e=>Us(e)),this.deny=(t.deny??[]).map(e=>Us(e)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??nx,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new Lm({points:t.inboundConnectionThreshold??tx,duration:1}),this.connectionPruner=new Uv({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new Fw(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??50,maxDialQueueLength:t.maxDialQueueLength??500,maxPeerAddrsToDial:t.maxPeerAddrsToDial??25,dialTimeout:t.dialTimeout??5e3,resolvers:t.resolvers??{dnsaddr:ay},connections:this.connections}),this.reconnectQueue=new Zw({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const t of n.streams){const n=`${t.direction} ${t.protocol??"unnegotiated"}`;e[n]=(e[n]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t){const t={};for(const e of n.streams){const n=`${e.direction} ${e.protocol??"unnegotiated"}`;t[n]=(t[n]??0)+1}for(const[n,r]of Object.entries(t))e[n]=e[n]??[],e[n].push(r)}const t={};for(let[n,r]of Object.entries(e)){r=r.sort((e,t)=>e-t);const e=Math.floor(.9*r.length);t[n]=r[e]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await async function(...e){const t=[];for(const n of e)qi(n)&&t.push(n);await Promise.all(t.map(async e=>{null!=e.beforeStart&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{null!=e.afterStart&&await e.afterStart()}))}(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await async function(...e){const t=[];for(const n of e)qi(n)&&t.push(n);await Promise.all(t.map(async e=>{null!=e.beforeStop&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{null!=e.afterStop&&await e.afterStop()}))}(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(e){this.log.error(e)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}onConnect(e){this._onConnect(e).catch(e=>{this.log.error(e)})}async _onConnect(e){const{detail:t}=e;if(!this.started)return void await t.close();if("open"!==t.status)return;const n=t.remotePeer,r=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),null!=n.publicKey&&"RSA"===n.type&&await this.peerStore.patch(n,{publicKey:n.publicKey}),r&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,r=(this.connections.get(n)??[]).filter(e=>e.id!==t.id);this.connections.set(n,r),0===r.length&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(null!=e)return this.connections.get(e)??[];let t=[];for(const e of this.connections.values())t=t.concat(e);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new Fi("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=Nv(e);if(this.peerId.equals(n))throw new Di("Can not dial self");if(null!=n&&!0!==t.force){this.log("dial %p",n);const e=this.getConnections(n).find(e=>null==e.limits);if(null!=e)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new Pg("dial-queue:already-connected")),e}const r=await this.dialQueue.dial(e,{...t,priority:t.priority??Qw});if("open"!==r.status)throw new Pi("Remote closed connection during opening");let i=this.connections.get(r.remotePeer);null==i&&(i=[],this.connections.set(r.remotePeer,i));let s=!1;for(const e of i)if(e.id===r.id&&(s=!0),!0!==t.force&&e.id!==r.id&&e.remoteAddr.equals(r.remoteAddr))return r.abort(new ki("Duplicate multiaddr connection")),e;return s||i.push(r),r}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async e=>{try{await e.close(t)}catch(t){e.abort(t)}}))}async acceptIncomingConnection(e){const t=this.deny.some(t=>e.remoteAddr.toString().startsWith(t.toString()));if(t)return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;const n=this.allow.some(t=>e.remoteAddr.toString().startsWith(t.toString()));if(n)return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const t=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(t,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,t),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(e=>Us(e))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class ix{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(null!=this.previousTime){const n=this.alpha(t,this.previousTime),r=e-this.movingAverage,i=n*r;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+r*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*r}else this.movingAverage=e;this.previousTime=t}}class sx{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??5e3;this.success=new ix(t),this.failure=new ix(t),this.next=new ix(t),this.failureMultiplier=e.failureMultiplier??2,this.timeoutMultiplier=e.timeoutMultiplier??1.2,this.minTimeout=e.minTimeout??5e3,this.maxTimeout=e.maxTimeout??6e4,null!=e.metricName&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),r=Cw([e.signal,n]);return r.start=Date.now(),r.timeout=t,r}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class ox{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??1e4,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??true,this.timeout=new sx({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[Vi]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),r=Kh(await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}));t=Date.now(),await Promise.all([r.write(Yc(32),{signal:n}),r.read(32,{signal:n})]),e.rtt=Date.now()-t,await r.unwrap().close({signal:n})}catch(n){if("UnsupportedProtocolError"!==n.name)throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),null!=this.heartbeatInterval&&clearInterval(this.heartbeatInterval)}}class ax{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(0===this.routers.length)throw new gv("No content routers available");const n=this,r=new Oy;for await(const i of zr(...n.routers.map(n=>n.findProviders(e,t))))null!=i&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),r.has(i.id)||(r.add(i.id),yield i))}async provide(e,t={}){if(0===this.routers.length)throw new gv("No content routers available");await Promise.all(this.routers.map(async n=>{await n.provide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new Fi;await Promise.all(this.routers.map(async r=>{await r.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new Fi;return Promise.any(this.routers.map(async n=>n.get(e,t)))}}class lx{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[]}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(0===this.routers.length)throw new yv("No peer routers available");if(e.toString()===this.peerId.toString())throw new bv("Should not try to find self");const n=this,r=zr(...this.routers.map(r=>async function*(){try{yield await r.findPeer(e,t)}catch(e){n.log.error(e)}}()));for await(const e of r)if(null!=e)return e.multiaddrs.length>0&&await this.peerStore.merge(e.id,{multiaddrs:e.multiaddrs}),e;throw new Ri}async*getClosestPeers(e,t={}){if(0===this.routers.length)throw new yv("No peer routers available");const n=this,r=function(e,t=.001){return new Xy({...Ky(e,t)})}(1024);for await(const i of async function*(e,t={}){let n=t.concurrency??1/0;n<1&&(n=1/0);const r=t.ordered??!1,i=new EventTarget,s=[];let o,a=Ir(),l=Ir(),c=!1,h=!1;function u(){return r?s[0]?.done:!!s.find(e=>e.done)}function*d(){for(;s.length>0&&s[0].done;){const e=s[0];if(s.shift(),!e.ok)throw h=!0,a.resolve(),e.err;yield e.value,a.resolve()}}function*p(){for(;u();)for(let e=0;e<s.length;e++)if(s[e].done){const t=s[e];if(s.splice(e,1),e--,!t.ok)throw h=!0,a.resolve(),t.err;yield t.value,a.resolve()}}for(i.addEventListener("task-complete",()=>{l.resolve()}),Promise.resolve().then(async()=>{try{for await(const t of e){if(s.length===n&&(a=Ir(),await a.promise),h)break;const e={done:!1};s.push(e),t().then(t=>{e.done=!0,e.ok=!0,e.value=t,i.dispatchEvent(new Mf("task-complete"))},t=>{e.done=!0,e.err=t,i.dispatchEvent(new Mf("task-complete"))})}c=!0,i.dispatchEvent(new Mf("task-complete"))}catch(e){o=e,i.dispatchEvent(new Mf("task-complete"))}});;){if(u()||(l=Ir(),await l.promise),null!=o)throw o;if(r?yield*d():yield*p(),null!=o)throw o;if(c&&0===s.length)break}}(async function*(){const r=zr(...n.routers.map(n=>n.getClosestPeers(e,t)));for await(let e of r)yield async()=>{if(0===e.multiaddrs.length)try{e=await n.findPeer(e.id,{...t,useCache:!1})}catch(e){return void n.log.error("could not find peer multiaddrs",e)}return e}}()))null!=i&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),r.has(i.id.toMultihash().bytes)||(r.add(i.id.toMultihash().bytes),yield i))}}class cx extends Hi{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Cw([this.shutdownController.signal,e?.signal]);try{for(;;){this.needNext?.resolve(),this.needNext=Ir();const e=await nb(this,"walk:peer",t,{errorEvent:"walk:error"});yield e.detail}}finally{t.clear(),this.walkers--,0===this.walkers&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Cw([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const t=Yc(32);let r=Date.now();for await(const i of this.peerRouting.getClosestPeers(t,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",i.id,Date.now()-r,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:i}),1===this.walkers&&null!=this.needNext&&(this.log("wait for need next"),await Nr(this.needNext.promise,e)),r=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",t,this.walkers,n)}catch(e){this.log.error("randomwalk errored",e),this.safeDispatchEvent("walk:error",{detail:e})}this.log("no walkers left, ended walk")}).catch(e=>{this.log.error("randomwalk errored",e)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}class hx{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(null==t)throw new vv("No handler registered for protocol "+e);return t}getTopologies(e){const t=this.topologies.get(e);return null==t?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e))throw new wv("Handler already registered for protocol "+e);const r=py.bind({ignoreUndefined:!0})({maxInboundStreams:32,maxOutboundStreams:64},n);this.handlers.set(e,{handler:t,options:r}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(e=>{this.handlers.delete(e)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(null==t)throw new Ii("invalid topology");const n=`${(1e9*Math.random()).toString(36)}${Date.now()}`;let r=this.topologies.get(e);return null==r&&(r=new Map,this.topologies.set(e,r)),r.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),0===n.size&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(e=>{for(const n of e.protocols){const e=this.topologies.get(n);if(null!=e)for(const n of e.values())!1!==n.filter?.has(t)&&(n.filter?.remove(t),n.onDisconnect?.(t))}}).catch(e=>{"NotFoundError"!==e.name&&this.log.error("could not inform topologies of disconnecting peer %p",t,e)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,r=(n?.protocols??[]).filter(e=>!t.protocols.includes(e));for(const e of r){const n=this.topologies.get(e);if(null!=n)for(const e of n.values())!1!==e.filter?.has(t.id)&&(e.filter?.remove(t.id),e.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,r=e.detail.peerId;for(const e of t){const t=this.topologies.get(e);if(null!=t)for(const e of t.values())null!=n.limits&&!0!==e.notifyOnLimitedConnection||!0!==e.filter?.has(r)&&(e.filter?.add(r),e.onConnect?.(r,n))}}}class ux extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}class dx{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=function(e){const{name:t,metrics:n}=e;let r;return r=null!=n?new ux({name:t,metrics:n}):new Map,r}({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Ci.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(null==t)throw new Ii("Transport must have a valid tag");if(this.transports.has(t))throw new Ii("There is already a transport with the tag "+t);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const t=n.pop();null!=t&&e.push(t.close())}await Promise.all(e),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(null==n)throw new Cv("No transport available for address "+(e+""));return t?.onProgress?.(new Pg("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values()){if(t.dialFilter([e]).length>0)return t}}listenTransportForMultiaddr(e){for(const t of this.transports.values()){if(t.listenFilter([e]).length>0)return t}}async listen(e){if(!this.isStarted())throw new Fi("Not started");if(null==e||0===e.length)return void this.log("no addresses were provided for listening, this node is dial only");const t=[];for(const[n,r]of this.transports.entries()){const i=r.listenFilter(e),s=[];for(const e of i){this.log("creating listener for %s on %a",n,e);const t=r.createListener({upgrader:this.components.upgrader});let i=this.listeners.get(n)??[];null==i&&(i=[],this.listeners.set(n,i)),i.push(t),t.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:t})}),t.addEventListener("close",()=>{const e=i.findIndex(e=>e===t);i.splice(e,1),this.components.events.safeDispatchEvent("transport:close",{detail:t})}),s.push(t.listen(e))}if(0===s.length){t.push(n);continue}const o=(await Promise.allSettled(s)).find(e=>"fulfilled"===e.status);if(null==o&&this.faultTolerance!==Ci.NO_FATAL)throw new _v(`Transport (${n}) could not listen on any available address`)}if(t.length===this.transports.size){const e=`no valid addresses were provided for transports [${t.join(", ")}]`;if(this.faultTolerance===Ci.FATAL_ALL)throw new _v(e);this.log("libp2p in dial mode only: "+e)}}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const e=t.pop();null!=e&&n.push(e.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const px="/multistream/1.0.0",fx=1024;class mx extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class gx extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class yx{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=Ir(),this.haveNext=Ir()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Ir(),e}async throw(e){this.ended=!0,this.error=e,null!=e&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw this.error??Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Ir(),await Nr(this.readNext.promise,t?.signal,t)}}class bx extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function vx(e,t){const n=new yx;e.sink(n).catch(async e=>{await n.end(e)}),e.sink=async e=>{for await(const t of e)await n.push(t);await n.end()};let r=e.source;null!=e.source[Symbol.iterator]?r=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(r=e.source[Symbol.asyncIterator]());const i=new br,s={async read(e){if(e?.signal?.throwIfAborted(),null==e?.bytes){const{done:t,value:n}=await Nr(r.next(),e?.signal);return!0===t?null:n}for(;i.byteLength<e.bytes;){const{value:t,done:n}=await Nr(r.next(),e?.signal);if(!0===n)throw new bx("unexpected end of input");i.append(t)}const t=i.sublist(0,e.bytes);return i.consume(e.bytes),t},async write(e,t){t?.signal?.throwIfAborted(),e instanceof Uint8Array?await n.push(e,t):await n.push(e.subarray(),t)},unwrap(){if(i.byteLength>0){const n=e.source;e.source=async function*(){!1===t?.yieldBytes?yield i:yield*i,yield*n}()}return e}};return s}class wx extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}let xx=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"};class _x extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function Ex(e,t={}){const n=vx(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=l(t.maxDataLength));const r=t?.lengthDecoder??d,i=t?.lengthEncoder??u;return{async read(e){let i=-1;const s=new br;for(;;){s.append(await n.read({...e,bytes:1}));try{i=r(s)}catch(e){if(e instanceof RangeError)continue;throw e}if(i<0)throw new wx("Invalid message length");if(null!=t?.maxLengthLength&&s.byteLength>t.maxLengthLength)throw new _x("message length length too long");if(i>-1)break}if(null!=t?.maxDataLength&&i>t.maxDataLength)throw new xx("message length too long");return n.read({...e,bytes:i})},async write(e,t){await n.write(new br(i(e.byteLength),e),t)},async writeV(e,t){const r=new br(...e.flatMap(e=>[i(e.byteLength),e]));await n.write(r,t)},unwrap(){return n.unwrap()}}}const Sx=rt("\n");async function Mx(e,t,n){await e.write(t,n)}async function Ax(e,t){const n=await async function(e,t){const n=await e.read(t);if(0===n.byteLength||n.get(n.byteLength-1)!==Sx[0])throw t.log.error("Invalid mss message - missing newline",n),new gx("Missing newline");return n.sublist(0,-1)}(e,t);return Pn(n.subarray())}async function Cx(e,t,n){if(1===(t=Array.isArray(t)?[...t]:[t]).length&&!1===n.negotiateFully)return function(e,t,n){const r=e.sink.bind(e),i=e.source;let s=!1,o=!1;const a=Ir();let l=!1,c=!1;const h=Ir();let d=!1,p=!1;const f=Ir(),m=Ex({sink:r,source:i},{...n,maxDataLength:fx});async function g(){if(o)return n.log.trace("optimistic: already negotiating %s stream",t),void await a.promise;o=!0;try{l||(n.log.trace("optimistic: doing send protocol for %s stream",t),await y()),d||(n.log.trace("optimistic: doing read protocol for %s stream",t),await b())}finally{o=!1,s=!0,a.resolve()}}async function y(){if(c)await h.promise;else{c=!0;try{n.log.trace('optimistic: write ["%s", "%s", data] in source',px,t),await m.writeV([rt(px+"\n"),rt(t+"\n")]),n.log.trace('optimistic: wrote ["%s", "%s", data] in source',px,t)}finally{l=!0,c=!1,h.resolve()}}}async function b(){if(p)await f.promise;else{p=!0;try{n.log.trace("optimistic: reading multistream select header");let e=await Ax(m,n);if(n.log.trace('optimistic: read multistream select header "%s"',e),e===px&&(e=await Ax(m,n)),n.log.trace('optimistic: read protocol "%s", expecting "%s"',e,t),e!==t)throw new mx("protocol selection failed")}finally{d=!0,p=!1,f.resolve()}}}if(e.sink=async e=>{const{sink:r}=m.unwrap();await r(async function*(){let r=!1;for await(const i of e){if(c&&await h.promise,l)yield i;else{c=!0,n.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',px,t,i.byteLength);const e=t+"\n";yield new br(Uint8Array.from([19]),rt(px+"\n"),u(e.length),rt(e),i).subarray(),n.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',px,t,i.byteLength),l=!0,c=!1,h.resolve(),g().catch(e=>{n.log.error("could not finish optimistic protocol negotiation of %s",t,e)})}r=!0}r||await g()}())},e.source=async function*(){await g(),n.log.trace('optimistic: reading data from "%s" stream',t),yield*m.unwrap().source}(),null!=e.closeRead){const t=e.closeRead.bind(e);e.closeRead=async e=>{s||await g().catch(e=>{n.log.error("could not negotiate protocol before close read",e)}),await t(e)}}if(null!=e.closeWrite){const t=e.closeWrite.bind(e);e.closeWrite=async e=>{s||await g().catch(e=>{n.log.error("could not negotiate protocol before close write",e)}),await t(e)}}if(null!=e.close){const t=e.close.bind(e);e.close=async e=>{const n=[];c&&n.push(h.promise),p&&n.push(f.promise),n.length>0?await Nr(Promise.all(n),e?.signal):(s=!0,o=!1,a.resolve()),await t(e)}}return{stream:e,protocol:t}}(e,t[0],n);const r=Ex(e,{...n,maxDataLength:fx}),i=t.shift();if(null==i)throw Error("At least one protocol must be specified");n.log.trace('select: write ["%s", "%s"]',px,i);const s=rt(px+"\n"),o=rt(i+"\n");await async function(e,t,n){await e.writeV(t,n)}(r,[s,o],n),n.log.trace("select: reading multistream-select header");let a=await Ax(r,n);if(n.log.trace('select: read "%s"',a),a===px&&(n.log.trace("select: reading protocol response"),a=await Ax(r,n),n.log.trace('select: read "%s"',a)),a===i)return{stream:r.unwrap(),protocol:i};for(const e of t){n.log.trace('select: write "%s"',e),await Mx(r,rt(e+"\n"),n),n.log.trace("select: reading protocol response");const t=await Ax(r,n);if(n.log.trace('select: read "%s" for "%s"',t,e),t===e)return{stream:r.unwrap(),protocol:e}}throw new mx("protocol selection failed")}const Tx=4194304;class Ix extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}function Lx(e,t){if(e.byteLength>t)throw new Ix("Message length too long")}const Px=e=>{const n=l(e),r=t(n);return u(e,r),Px.bytes=n,r};function Rx(e,t){const n=(t=t??{}).lengthEncoder??Px,r=t?.maxDataLength??Tx;function*i(e){Lx(e,r);const t=n(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return null!=e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*i(t)}():function*(){for(const t of e)yield*i(t)}()}var Dx;async function kx(e,t,n){t=Array.isArray(t)?t:[t],n.log.trace("handle: available protocols %s",t);const r=Ex(e,{...n,maxDataLength:fx,maxLengthLength:2});for(;;){n.log.trace("handle: reading incoming string");const e=await Ax(r,n);if(n.log.trace('handle: read "%s"',e),e!==px){if(t.includes(e))return n.log.trace('handle: respond with "%s" for "%s"',e,e),await Mx(r,rt(e+"\n"),n),n.log.trace('handle: responded with "%s" for "%s"',e,e),{stream:r.unwrap(),protocol:e};if("ls"===e){const i=new br(...t.map(e=>Rx.single(rt(e+"\n"))),rt("\n"));n.log.trace('handle: respond with "%s" for %s',t,e),await Mx(r,i,n),n.log.trace('handle: responded with "%s" for %s',t,e);continue}n.log.trace('handle: respond with "na" for "%s"',e),await Mx(r,rt("na\n"),n),n.log('handle: responded with "na" for "%s"',e)}else n.log.trace('handle: respond with "%s" for "%s"',px,e),await Mx(r,rt(px+"\n"),n),n.log.trace('handle: responded with "%s" for "%s"',px,e)}}Px.bytes=0,Rx.single=(e,t)=>{const n=(t=t??{}).lengthEncoder??Px;return Lx(e,t?.maxDataLength??Tx),new br(n(e.byteLength),e)},(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(Dx||(Dx={}));class Nx{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:r,close:i,abort:s,getStreams:o}=e;this.id=`${parseInt(1e9*Math.random()+"").toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),null==this.remoteAddr.getPeerId()&&(this.remoteAddr=this.remoteAddr.encapsulate("/p2p/"+this.remotePeer)),this._newStream=r,this._close=i,this._abort=s,this._getStreams=o,this.tags=[]}[Symbol.toStringTag]="Connection";[wi]=!0;get streams(){return this._getStreams()}async newStream(e,t){if("closing"===this.status)throw new Li("the connection is being closed");if("closed"===this.status)throw new Pi("the connection is closed");if(Array.isArray(e)||(e=[e]),null!=this.limits&&!0!==t?.runOnLimitedConnection)throw new Bi("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if("closed"!==this.status&&"closing"!==this.status){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",null==e.signal){const t=AbortSignal.timeout(500);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(e){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,e),this.abort(e)}}}abort(e){"closed"!==this.status&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function Fx(e,t,n){let r=0;return n.streams.forEach(n=>{n.direction===t&&n.protocol===e&&r++}),r}class Ox{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;outboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(e=>{this.connectionEncrypters.set(e.protocol,e)}),this.streamMuxers=new Map,t.streamMuxers.forEach(e=>{this.streamMuxers.set(e.protocol,e)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??3e3,this.outboundUpgradeTimeout=t.outboundUpgradeTimeout??3e3,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??2e3,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??2e3,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(null==n)return;if(!0===await n.apply(this.components.connectionGater,t))throw new Ev("The multiaddr connection is blocked by gater."+e)}async upgradeInbound(e,t={}){try{this.metrics.dials?.increment({inbound:!0});if(!await this.components.connectionManager.acceptIncomingConnection(e))throw new Sv("connection denied");await this.shouldBlockConnection("denyInboundConnection",e);return await this._performUpgrade(e,"inbound",t)}catch(e){throw this.metrics.errors?.increment({inbound:!0}),e}finally{this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t={}){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let r;return null!=n&&(r=Uh(n),await this.shouldBlockConnection("denyOutboundConnection",r,e)),await this._performUpgrade(e,"outbound",t)}catch(e){throw this.metrics.errors?.increment({outbound:!0}),e}}async _performUpgrade(e,t,n){let r,i,s,o,a;const l=Cw([AbortSignal.timeout("inbound"===t?this.inboundUpgradeTimeout:this.outboundUpgradeTimeout),n.signal]);n.signal=l,this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let c=e;if(!0!==n?.skipProtection){const r=this.components.connectionProtector;null!=r&&(e.log("protecting the %s connection",t),c=await r.protect(e,n))}try{if(r=c,!0!==n?.skipEncryption){n?.onProgress?.(new Pg(`upgrader:encrypt-${t}-connection`)),({conn:r,remotePeer:i,protocol:a}=await("inbound"===t?this._encryptInbound(c,{...n,signal:l}):this._encryptOutbound(c,{...n,signal:l})));const e={...c,...r};await this.shouldBlockConnection("inbound"===t?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,e)}else{const n=e.remoteAddr.getPeerId();if(null==n)throw new ki(t+" connection that skipped encryption must have a peer id");const r=Uh(n);a="native",i=r}if(i.equals(this.components.peerId)){const t=new Di("Can not dial self");throw e.abort(t),t}if(s=r,null!=n?.muxerFactory)o=n.muxerFactory;else if(this.streamMuxers.size>0){n?.onProgress?.(new Pg(`upgrader:multiplex-${t}-connection`));const e=await("inbound"===t?this._multiplexInbound({...c,...r},this.streamMuxers,n):this._multiplexOutbound({...c,...r},this.streamMuxers,n));o=e.muxerFactory,s=e.stream}}catch(n){throw e.log.error("failed to upgrade inbound connection %s %a - %e","inbound"===t?"from":"to",e.remoteAddr,n),n}finally{l.clear()}return await this.shouldBlockConnection("inbound"===t?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:a,direction:t,maConn:e,upgradedConn:s,muxerFactory:o,remotePeer:i,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:r,upgradedConn:i,remotePeer:s,muxerFactory:o,limits:a}=e;let l,c,h;null!=o&&(l=o.createStreamMuxer({direction:n,onIncomingStream:e=>{null!=h&&Promise.resolve().then(async()=>{const t=this.components.registrar.getProtocols(),n=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:r,protocol:i}=await kx(e,t,{signal:n,log:e.log,yieldBytes:!1});if(null==h)return;h.log("incoming stream opened on %s",i);const o=function(e,t){try{const{options:n}=t.getHandler(e);return n.maxInboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return 32}(i,this.components.registrar);if(Fx(i,"inbound",h)===o){const t=new zi(`Too many inbound protocol streams for protocol "${i}" - limit ${o}`);throw e.abort(t),t}e.source=r.source,e.sink=r.sink,e.protocol=i,null!=r.closeWrite&&(e.closeWrite=r.closeWrite),null!=r.closeRead&&(e.closeRead=r.closeRead),null!=r.close&&(e.close=r.close),await this.components.peerStore.merge(s,{protocols:[i]}),this.components.metrics?.trackProtocolStream(e,h),this._onStream({connection:h,stream:e,protocol:i})}).catch(async t=>{h.log.error("error handling incoming stream id %s - %e",e.id,t),null==e.timeline.close&&await e.close()})}}),c=async(t,r={})=>{if(null==l)throw new Mv("Connection is not multiplexed");h.log.trace("starting new stream for protocols %s",t);const i=await l.newStream();h.log.trace("started new stream %s for protocols %s",i.id,t);try{if(null==r.signal){i.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const e=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);r={...r,signal:e}}i.log.trace("selecting protocol from protocols %s",t);const{stream:e,protocol:n}=await Cx(i,t,{...r,log:i.log,yieldBytes:!0});i.log.trace("selected protocol %s",n);const o=function(e,t,n={}){try{const{options:n}=t.getHandler(e);if(null!=n.maxOutboundStreams)return n.maxOutboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return n.maxOutboundStreams??64}(n,this.components.registrar,r),a=Fx(n,"outbound",h);if(a>=o){const e=new Ui(`Too many outbound protocol streams for protocol "${n}" - ${a}/${o}`);throw i.abort(e),e}return await this.components.peerStore.merge(s,{protocols:[n]}),i.source=e.source,i.sink=e.sink,i.protocol=n,null!=e.closeWrite&&(i.closeWrite=e.closeWrite),null!=e.closeRead&&(i.closeRead=e.closeRead),null!=e.close&&(i.close=e.close),this.components.metrics?.trackProtocolStream(i,h),i}catch(r){throw h.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e","inbound"===n?"from":"to",e.maConn.remoteAddr,t,r),null==i.timeline.close&&i.abort(r),r}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(e=>{h.log.error("error piping data through muxer - %e",e)}));const u=r.timeline;r.timeline=new Proxy(u,{set:(...e)=>("close"===e[1]&&null!=e[2]&&null==u.close&&(async()=>{try{"open"===h.status&&await h.close()}catch(e){h.log.error("error closing connection after timeline close %e",e)}finally{this.events.safeDispatchEvent("connection:close",{detail:h})}})().catch(e=>{h.log.error("error thrown while dispatching connection:close event %e",e)}),Reflect.set(...e))}),r.timeline.upgraded=Date.now();var d;return d={remoteAddr:r.remoteAddr,remotePeer:s,status:"open",direction:n,timeline:r.timeline,multiplexer:l?.protocol,encryption:t,limits:a,logger:this.components.logger,newStream:c??(()=>{throw new Mv("Connection is not multiplexed")}),getStreams:()=>l?.streams??[],async close(e){await(l?.close(e)),await r.close(e)},abort(e){r.abort(e),l?.abort(e)}},h=new Nx(d),this.events.safeDispatchEvent("connection:open",{detail:h}),h.__maConnTimeline=u,h}_onStream(e){const{connection:t,stream:n,protocol:r}=e,{handler:i,options:s}=this.components.registrar.getHandler(r);if(null!=t.limits&&!0!==s.runOnLimitedConnection)throw new Bi("Cannot open protocol stream on limited connection");i({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:r,protocol:i}=await kx(e,n,{...t,log:e.log}),s=this.connectionEncrypters.get(i);if(null==s)throw new Av("no crypto module found for "+i);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await s.secureInbound(r,t),protocol:i}}catch(t){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,t),new Av(t.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:r,protocol:i}=await Cx(e,n,{...t,log:e.log,yieldBytes:!0}),s=this.connectionEncrypters.get(i);if(null==s)throw new Av("no crypto module found for "+i);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await s.secureOutbound(r,t),protocol:i}}catch(t){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,t),new Av(t.message)}}async _multiplexOutbound(e,t,n){const r=Array.from(t.keys());e.log("outbound selecting muxer %s",r);try{e.log.trace("selecting stream muxer from %s",r);const{stream:i,protocol:s}=await Cx(e,r,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",s);return{stream:i,muxerFactory:t.get(s)}}catch(t){throw e.log.error("error multiplexing outbound connection",t),new Mv(t+"")}}async _multiplexInbound(e,t,n){const r=Array.from(t.keys());e.log("inbound handling muxers %s",r);try{const{stream:i,protocol:s}=await kx(e,r,{...n,log:e.log});return{stream:i,muxerFactory:t.get(s)}}catch(t){throw e.log.error("error multiplexing inbound connection",t),new Mv(t+"")}}}class Bx extends Hi{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new Hi,n=t.dispatchEvent.bind(t);t.dispatchEvent=e=>{const t=n(e),r=this.dispatchEvent(new CustomEvent(e.type,{detail:e.detail}));return t||r},this.peerId=e.peerId,this.logger=e.logger??Py(),this.log=this.logger.forComponent("libp2p"),this.services={};const r=this.components=function(e={}){const t=new Tv(e),n=new Proxy(t,{get(e,n,r){if("string"==typeof n&&!Lv.includes(n)){const e=t.components[n];if(null==e&&!Iv.includes(n))throw new fv(n+" not set");return e}return Reflect.get(e,n,r)},set(e,n,r){return"string"==typeof n?t.components[n]=r:Reflect.set(e,n,r),!0}});return n}({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:e.nodeInfo??{name:"libp2p",version:"2.1.8"},logger:this.logger,events:t,datastore:e.datastore??new cv,connectionGater:kv(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",function(e,t={}){return new rv(e,t)}(r,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),null!=e.metrics&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),r.events.addEventListener("peer:update",e=>{if(null==e.detail.previous){const t={id:e.detail.peer.id,multiaddrs:e.detail.peer.addresses.map(e=>e.multiaddr)};r.events.safeDispatchEvent("peer:discovery",{detail:t})}}),null!=e.connectionProtector&&this.configureComponent("connectionProtector",e.connectionProtector(r)),this.components.upgrader=new Ox(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((e,t)=>this.configureComponent("connection-encryption-"+t,e(this.components))),streamMuxers:(e.streamMuxers??[]).map((e,t)=>this.configureComponent("stream-muxers-"+t,e(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,outboundUpgradeTimeout:e.connectionManager?.outboundUpgradeTimeout}),this.configureComponent("transportManager",new dx(this.components,e.transportManager)),this.configureComponent("connectionManager",new rx(this.components,e.connectionManager)),!1!==e.connectionMonitor?.enabled&&this.configureComponent("connectionMonitor",new ox(this.components,e.connectionMonitor)),this.configureComponent("registrar",new hx(this.components)),this.configureComponent("addressManager",new dv(this.components,e.addresses));const i=(e.peerRouters??[]).map((e,t)=>this.configureComponent("peer-router-"+t,e(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new lx(this.components,{routers:i}));const s=(e.contentRouters??[]).map((e,t)=>this.configureComponent("content-router-"+t,e(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new ax(this.components,{routers:s})),this.configureComponent("randomWalk",new cx(this.components)),(e.peerDiscovery??[]).forEach((e,t)=>{this.configureComponent("peer-discovery-"+t,e(this.components)).addEventListener("peer",e=>{this.#k(e)})}),e.transports?.forEach((e,t)=>{this.components.transportManager.add(this.configureComponent("transport-"+t,e(this.components)))}),null!=e.services)for(const t of Object.keys(e.services)){const n=(0,e.services[t])(this.components);null!=n?(this.services[t]=n,this.configureComponent(t,n),null!=n[xi]&&(this.log("registering service %s for content routing",t),s.push(n[xi])),null!=n[Mi]&&(this.log("registering service %s for peer routing",t),i.push(n[Mi])),null!=n[_i]&&(this.log("registering service %s for peer discovery",t),n[_i].addEventListener?.("peer",e=>{this.#k(e)}))):this.log.error("service factory %s returned null or undefined instance",t)}!function(e){const t={};for(const n of Object.values(e.components))for(const e of Pv(n))t[e]=!0;for(const n of Object.values(e.components))for(const e of Rv(n))if(!0!==t[e])throw new mv(`Service "${Dv(n)}" required capability "${e}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}(r)}configureComponent(e,t){return null==t&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if("stopped"===this.status){this.status="starting",this.log("libp2p is starting");try{await(this.components.beforeStart?.()),await this.components.start(),await(this.components.afterStart?.()),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){"started"===this.status&&(this.log("libp2p is stopping"),this.status="stopping",await(this.components.beforeStop?.()),await this.components.stop(),await(this.components.afterStop?.()),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Oy;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(null==t)throw new Ii("no protocols were provided to open a stream");if(0===(t=Array.isArray(t)?t:[t]).length)throw new Ii("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){zs(e)&&(e=Uh(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),null!=e.publicKey)return e.publicKey;try{const t=await this.peerStore.get(e);if(null!=t.id.publicKey)return t.id.publicKey}catch(e){if("NotFoundError"!==e.name)throw e}const n=pr([rt("/pk/"),e.toMultihash().bytes]),r=Mh(await this.contentRouting.get(n,t));return await this.peerStore.patch(e,{publicKey:r}),r}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async e=>{await this.components.registrar.handle(e,t,n)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async e=>{await this.components.registrar.unhandle(e)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#k(e){const{detail:t}=e;t.id.toString()!==this.peerId.toString()?this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(e=>{this.log.error(e)}):this.log.error("peer discovery mechanism discovered self")}}function zx(){try{return!1}catch(e){return!1}}const Ux=Symbol.for("@libp2p/peer-discovery"),Hx="enrtree://AIRVQ5DDA4FFWLRBCHJWUWOO6X6S4ZTZ5B667LQ6AJU6PEYDLRD5O@sandbox.waku.nodes.status.im",qx="bootstrap",Vx={store:1,filter:2,lightPush:2},Gx="Invalid record id";var Wx=Object.freeze({__proto__:null,default:{}});const jx=BigInt(0),$x=BigInt(1),Kx=BigInt(2),Xx=BigInt(3),Yx=BigInt(8),Zx=Object.freeze({a:jx,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:$x,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),Jx=(e,t)=>(e+t/Kx)/t,Qx={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){const{n:t}=Zx,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-$x*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,o=BigInt("0x100000000000000000000000000000000"),a=Jx(s*e,t),l=Jx(-r*e,t);let c=I_(e-a*n-l*i,t),h=I_(-a*r-l*s,t);const u=c>o,d=h>o;if(u&&(c=t-c),d&&(h=t-h),c>o||h>o)throw Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:u,k1:c,k2neg:d,k2:h}}},e_=32,t_=32;function n_(e){const{a:t,b:n}=Zx,r=I_(e*e),i=I_(r*e);return I_(i+t*e+n)}const r_=Zx.a===jx;class i_ extends Error{constructor(e){super(e)}}function s_(e){if(!(e instanceof o_))throw new TypeError("JacobianPoint expected")}class o_{constructor(e,t,n){this.x=e,this.y=t,this.z=n}static fromAffine(e){if(!(e instanceof c_))throw new TypeError("JacobianPoint#fromAffine: expected Point");return e.equals(c_.ZERO)?o_.ZERO:new o_(e.x,e.y,$x)}static toAffineBatch(e){const t=function(e,t=Zx.P){const n=Array(e.length),r=e.reduce((e,r,i)=>r===jx?e:(n[i]=e,I_(e*r,t)),$x),i=P_(r,t);return e.reduceRight((e,r,i)=>r===jx?e:(n[i]=I_(e*n[i],t),I_(e*r,t)),i),n}(e.map(e=>e.z));return e.map((e,n)=>e.toAffine(t[n]))}static normalizeZ(e){return o_.toAffineBatch(e).map(o_.fromAffine)}equals(e){s_(e);const{x:t,y:n,z:r}=this,{x:i,y:s,z:o}=e,a=I_(r*r),l=I_(o*o),c=I_(t*l),h=I_(i*a),u=I_(I_(n*o)*l),d=I_(I_(s*r)*a);return c===h&&u===d}negate(){return new o_(this.x,I_(-this.y),this.z)}double(){const{x:e,y:t,z:n}=this,r=I_(e*e),i=I_(t*t),s=I_(i*i),o=e+i,a=I_(Kx*(I_(o*o)-r-s)),l=I_(Xx*r),c=I_(l*l),h=I_(c-Kx*a),u=I_(l*(a-h)-Yx*s),d=I_(Kx*t*n);return new o_(h,u,d)}add(e){s_(e);const{x:t,y:n,z:r}=this,{x:i,y:s,z:o}=e;if(i===jx||s===jx)return this;if(t===jx||n===jx)return e;const a=I_(r*r),l=I_(o*o),c=I_(t*l),h=I_(i*a),u=I_(I_(n*o)*l),d=I_(I_(s*r)*a),p=I_(h-c),f=I_(d-u);if(p===jx)return f===jx?this.double():o_.ZERO;const m=I_(p*p),g=I_(p*m),y=I_(c*m),b=I_(f*f-g-Kx*y),v=I_(f*(y-b)-u*g),w=I_(r*o*p);return new o_(b,v,w)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){const t=o_.ZERO;if("bigint"==typeof e&&e===jx)return t;let n=T_(e);if(n===$x)return this;if(!r_){let e=t,r=this;for(;n>jx;)n&$x&&(e=e.add(r)),r=r.double(),n>>=$x;return e}let{k1neg:r,k1:i,k2neg:s,k2:o}=Qx.splitScalar(n),a=t,l=t,c=this;for(;i>jx||o>jx;)i&$x&&(a=a.add(c)),o&$x&&(l=l.add(c)),c=c.double(),i>>=$x,o>>=$x;return r&&(a=a.negate()),s&&(l=l.negate()),l=new o_(I_(l.x*Qx.beta),l.y,l.z),a.add(l)}precomputeWindow(e){const t=r_?128/e+1:256/e+1,n=[];let r=this,i=r;for(let s=0;s<t;s++){i=r,n.push(i);for(let t=1;t<2**(e-1);t++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(e,t){!t&&this.equals(o_.BASE)&&(t=c_.BASE);const n=t&&t._WINDOW_SIZE||1;if(256%n)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=t&&l_.get(t);r||(r=this.precomputeWindow(n),t&&1!==n&&(r=o_.normalizeZ(r),l_.set(t,r)));let i=o_.ZERO,s=o_.BASE;const o=1+(r_?128/n:256/n),a=2**(n-1),l=BigInt(2**n-1),c=2**n,h=BigInt(n);for(let t=0;t<o;t++){const n=t*a;let o=Number(e&l);e>>=h,o>a&&(o-=c,e+=$x);const u=n,d=n+Math.abs(o)-1,p=t%2!=0,f=o<0;0===o?s=s.add(a_(p,r[u])):i=i.add(a_(f,r[d]))}return{p:i,f:s}}multiply(e,t){let n,r,i=T_(e);if(r_){const{k1neg:e,k1:s,k2neg:o,k2:a}=Qx.splitScalar(i);let{p:l,f:c}=this.wNAF(s,t),{p:h,f:u}=this.wNAF(a,t);l=a_(e,l),h=a_(o,h),h=new o_(I_(h.x*Qx.beta),h.y,h.z),n=l.add(h),r=c.add(u)}else{const{p:e,f:s}=this.wNAF(i,t);n=e,r=s}return o_.normalizeZ([n,r])[0]}toAffine(e){const{x:t,y:n,z:r}=this,i=this.equals(o_.ZERO);null==e&&(e=i?Yx:P_(r));const s=e,o=I_(s*s),a=I_(o*s),l=I_(t*o),c=I_(n*a),h=I_(r*s);if(i)return c_.ZERO;if(h!==$x)throw Error("invZ was invalid");return new c_(l,c)}}function a_(e,t){const n=t.negate();return e?n:t}o_.BASE=new o_(Zx.Gx,Zx.Gy,$x),o_.ZERO=new o_(jx,$x,jx);const l_=new WeakMap;class c_{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,l_.delete(this)}hasEvenY(){return this.y%Kx===jx}static fromCompressedHex(e){const t=32===e.length,n=A_(t?e:e.subarray(1));if(!O_(n))throw Error("Point is not on curve");let r=function(e){const{P:t}=Zx,n=BigInt(6),r=BigInt(11),i=BigInt(22),s=BigInt(23),o=BigInt(44),a=BigInt(88),l=e*e*e%t,c=l*l*e%t,h=L_(c,Xx)*c%t,u=L_(h,Xx)*c%t,d=L_(u,Kx)*l%t,p=L_(d,r)*d%t,f=L_(p,i)*p%t,m=L_(f,o)*f%t,g=L_(m,a)*m%t,y=L_(g,o)*f%t,b=L_(y,Xx)*c%t,v=L_(b,s)*p%t,w=L_(v,n)*l%t,x=L_(w,Kx),_=x*x%t;if(_!==e)throw Error("Cannot find square root");return x}(n_(n));const i=(r&$x)===$x;if(t)i&&(r=I_(-r));else{!(1&~e[0])!==i&&(r=I_(-r))}const s=new c_(n,r);return s.assertValidity(),s}static fromUncompressedHex(e){const t=A_(e.subarray(1,33)),n=A_(e.subarray(33,65)),r=new c_(t,n);return r.assertValidity(),r}static fromHex(e){const t=C_(e),n=t.length,r=t[0];if(n===e_)return this.fromCompressedHex(t);if(33===n&&(2===r||3===r))return this.fromCompressedHex(t);if(65===n&&4===r)return this.fromUncompressedHex(t);throw Error("Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not "+n)}static fromPrivateKey(e){return c_.BASE.multiply(z_(e))}static fromSignature(e,t,n){const{r,s:i}=U_(t);if(![0,1,2,3].includes(n))throw Error("Cannot recover: invalid recovery bit");const s=R_(C_(e)),{n:o}=Zx,a=2===n||3===n?r+o:r,l=P_(a,o),c=I_(-s*l,o),h=I_(i*l,o),u=1&n?"03":"02",d=c_.fromHex(u+__(a)),p=c_.BASE.multiplyAndAddUnsafe(d,c,h);if(!p)throw Error("Cannot recover signature: point at infinify");return p.assertValidity(),p}toRawBytes(e=!1){return w_(this.toHex(e))}toHex(e=!1){const t=__(this.x);if(e){return`${this.hasEvenY()?"02":"03"}${t}`}return`04${t}${__(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const e="Point is not on elliptic curve",{x:t,y:n}=this;if(!O_(t)||!O_(n))throw Error(e);const r=I_(n*n);if(I_(r-n_(t))!==jx)throw Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new c_(this.x,I_(-this.y))}double(){return o_.fromAffine(this).double().toAffine()}add(e){return o_.fromAffine(this).add(o_.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return o_.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,n){const r=o_.fromAffine(this),i=t===jx||t===$x||this!==c_.BASE?r.multiplyUnsafe(t):r.multiply(t),s=o_.fromAffine(e).multiplyUnsafe(n),o=i.add(s);return o.equals(o_.ZERO)?void 0:o.toAffine()}}function h_(e){return Number.parseInt(e[0],16)>=8?"00"+e:e}function u_(e){if(e.length<2||2!==e[0])throw Error("Invalid signature integer tag: "+y_(e));const t=e[1],n=e.subarray(2,t+2);if(!t||n.length!==t)throw Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw Error("Invalid signature integer: trailing length");return{data:A_(n),left:e.subarray(t+2)}}c_.BASE=new c_(Zx.Gx,Zx.Gy),c_.ZERO=new c_(jx,jx);class d_{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromCompact(e){const t=p_(e),n="Signature.fromCompact";if("string"!=typeof e&&!t)throw new TypeError(n+": Expected string or Uint8Array");const r=t?y_(e):e;if(128!==r.length)throw Error(n+": Expected 64-byte hex");return new d_(M_(r.slice(0,64)),M_(r.slice(64,128)))}static fromDER(e){const t=p_(e);if("string"!=typeof e&&!t)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(e){if(e.length<2||48!=e[0])throw Error("Invalid signature tag: "+y_(e));if(e[1]!==e.length-2)throw Error("Invalid signature: incorrect length");const{data:t,left:n}=u_(e.subarray(2)),{data:r,left:i}=u_(n);if(i.length)throw Error("Invalid signature: left bytes after parsing: "+y_(i));return{r:t,s:r}}(t?e:w_(e));return new d_(n,r)}static fromHex(e){return this.fromDER(e)}assertValidity(){const{r:e,s:t}=this;if(!F_(e))throw Error("Invalid Signature: r must be 0 < r < n");if(!F_(t))throw Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const e=Zx.n>>$x;return this.s>e}normalizeS(){return this.hasHighS()?new d_(this.r,I_(-this.s,Zx.n)):this}toDERRawBytes(){return w_(this.toDERHex())}toDERHex(){const e=h_(S_(this.s)),t=h_(S_(this.r)),n=e.length/2,r=t.length/2,i=S_(n),s=S_(r);return`30${S_(r+n+4)}02${s}${t}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return w_(this.toCompactHex())}toCompactHex(){return __(this.r)+__(this.s)}}function p_(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function f_(e){if(!p_(e))throw Error("Uint8Array expected")}function m_(...e){if(e.every(f_),1===e.length)return e[0];const t=e.reduce((e,t)=>e+t.length,0),n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const i=e[t];n.set(i,r),r+=i.length}return n}const g_=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function y_(e){f_(e);let t="";for(let n=0;n<e.length;n++)t+=g_[e[n]];return t}const b_={_0:48,_9:57,A:65,F:70,a:97,f:102};function v_(e){return e>=b_._0&&e<=b_._9?e-b_._0:e>=b_.A&&e<=b_.F?e-(b_.A-10):e>=b_.a&&e<=b_.f?e-(b_.a-10):void 0}function w_(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,i=0;t<n;t++,i+=2){const n=v_(e.charCodeAt(i)),s=v_(e.charCodeAt(i+1));if(void 0===n||void 0===s){const t=e[i]+e[i+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+i)}r[t]=16*n+s}return r}const x_=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function __(e){if("bigint"!=typeof e)throw Error("Expected bigint");if(!(jx<=e&&e<x_))throw Error("Expected number 0 <= n < 2^256");return e.toString(16).padStart(64,"0")}function E_(e){const t=w_(__(e));if(32!==t.length)throw Error("Error: expected 32 bytes");return t}function S_(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function M_(e){if("string"!=typeof e)throw new TypeError("hexToNumber: expected string, got "+typeof e);return BigInt("0x"+e)}function A_(e){return M_(y_(e))}function C_(e){return p_(e)?Uint8Array.from(e):w_(e)}function T_(e){if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)return BigInt(e);if("bigint"==typeof e&&F_(e))return e;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function I_(e,t=Zx.P){const n=e%t;return n>=jx?n:t+n}function L_(e,t){const{P:n}=Zx;let r=e;for(;t-- >jx;)r*=r,r%=n;return r}function P_(e,t=Zx.P){if(e===jx||t<=jx)throw Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=I_(e,t),r=t,i=jx,s=$x;for(;n!==jx;){const e=r%n,t=i-s*(r/n);r=n,n=e,i=s,s=t}if(r!==$x)throw Error("invert: does not exist");return I_(i,t)}function R_(e,t=!1){const n=function(e){const t=8*e.length-256,n=A_(e);return t>0?n>>BigInt(t):n}(e);if(t)return n;const{n:r}=Zx;return n>=r?n-r:n}let D_,k_;class N_{constructor(e,t){if(this.hashLen=e,this.qByteLen=t,"number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof t||t<2)throw Error("qByteLen must be a number");this.v=new Uint8Array(e).fill(1),this.k=new Uint8Array(e).fill(0),this.counter=0}hmac(...e){return X_.hmacSha256(this.k,...e)}hmacSync(...e){return k_(this.k,...e)}checkSync(){if("function"!=typeof k_)throw new i_("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(e=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),e),this.v=await this.hmac(this.v),0!==e.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),e),this.v=await this.hmac(this.v))}reseedSync(e=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),e),this.v=this.hmacSync(this.v),0!==e.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),e),this.v=this.hmacSync(this.v))}async generate(){this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=await this.hmac(this.v);const n=this.v.slice();t.push(n),e+=this.v.length}return m_(...t)}generateSync(){this.checkSync(),this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=this.hmacSync(this.v);const n=this.v.slice();t.push(n),e+=this.v.length}return m_(...t)}}function F_(e){return jx<e&&e<Zx.n}function O_(e){return jx<e&&e<Zx.P}function B_(e,t,n,r=!0){const{n:i}=Zx,s=R_(e,!0);if(!F_(s))return;const o=P_(s,i),a=c_.BASE.multiply(s),l=I_(a.x,i);if(l===jx)return;const c=I_(o*I_(t+n*l,i),i);if(c===jx)return;let h=new d_(l,c),u=(a.x===h.r?0:2)|Number(a.y&$x);return r&&h.hasHighS()&&(h=h.normalizeS(),u^=1),{sig:h,recovery:u}}function z_(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)t=BigInt(e);else if("string"==typeof e){if(64!==e.length)throw Error("Expected 32 bytes of private key");t=M_(e)}else{if(!p_(e))throw new TypeError("Expected valid private key");if(e.length!==t_)throw Error("Expected 32 bytes of private key");t=A_(e)}if(!F_(t))throw Error("Expected private key: 0 < key < n");return t}function U_(e){if(e instanceof d_)return e.assertValidity(),e;try{return d_.fromDER(e)}catch(t){return d_.fromCompact(e)}}function H_(e){return A_(e.length>e_?e.slice(0,e_):e)}function q_(e){const t=H_(e),n=I_(t,Zx.n);return V_(n<jx?t:n)}function V_(e){return E_(e)}async function G_(e,t,n={}){const{seed:r,m:i,d:s}=function(e,t,n){if(null==e)throw Error(`sign: expected valid message hash, not "${e}"`);const r=C_(e),i=z_(t),s=[V_(i),q_(r)];if(null!=n){!0===n&&(n=X_.randomBytes(e_));const e=C_(n);if(e.length!==e_)throw Error("sign: Expected 32 bytes of extra data");s.push(e)}return{seed:m_(...s),m:H_(r),d:i}}(e,t,n.extraEntropy),o=new N_(32,t_);let a;for(await o.reseed(r);!(a=B_(await o.generate(),i,s,n.canonical));)await o.reseed();return function(e,t){const{sig:n,recovery:r}=e,{der:i,recovered:s}=Object.assign({canonical:!0,der:!0},t),o=i?n.toDERRawBytes():n.toCompactRawBytes();return s?[o,r]:o}(a,n)}const W_={strict:!0};function j_(e,t,n,r=W_){let i;try{i=U_(e),t=C_(t)}catch(e){return!1}const{r:s,s:o}=i;if(r.strict&&i.hasHighS())return!1;const a=R_(t);let l;try{l=function(e){return e instanceof c_?(e.assertValidity(),e):c_.fromHex(e)}(n)}catch(e){return!1}const{n:c}=Zx,h=P_(o,c),u=I_(a*h,c),d=I_(s*h,c),p=c_.BASE.multiplyAndAddUnsafe(l,u,d);if(!p)return!1;return I_(p.x,c)===s}c_.BASE._setWindowSize(8);const $_={node:Wx,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},K_={},X_={bytesToHex:y_,hexToBytes:w_,concatBytes:m_,mod:I_,invert:P_,isValidPrivateKey(e){try{return z_(e),!0}catch(e){return!1}},_bigintTo32Bytes:E_,_normalizePrivateKey:z_,hashToPrivateKey(e){if((e=C_(e)).length<40||e.length>1024)throw Error("Expected valid bytes of private key as per FIPS 186");return E_(I_(A_(e),Zx.n-$x)+$x)},randomBytes(e=32){if($_.web)return $_.web.getRandomValues(new Uint8Array(e));if($_.node){const{randomBytes:t}=$_.node;return Uint8Array.from(t(e))}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey(){return X_.hashToPrivateKey(X_.randomBytes(40))},precompute(e=8,t=c_.BASE){const n=t===c_.BASE?t:new c_(t.x,t.y);return n._setWindowSize(e),n.multiply(Xx),n},async sha256(...e){if($_.web){const t=await $_.web.subtle.digest("SHA-256",m_(...e));return new Uint8Array(t)}if($_.node){const{createHash:t}=$_.node,n=t("sha256");return e.forEach(e=>n.update(e)),Uint8Array.from(n.digest())}throw Error("The environment doesn't have sha256 function")},async hmacSha256(e,...t){if($_.web){const n=await $_.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=m_(...t),i=await $_.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if($_.node){const{createHmac:n}=$_.node,r=n("sha256",e);return t.forEach(e=>r.update(e)),Uint8Array.from(r.digest())}throw Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,async taggedHash(e,...t){let n=K_[e];if(void 0===n){const t=await X_.sha256(Uint8Array.from(e,e=>e.charCodeAt(0)));n=m_(t,t),K_[e]=n}return X_.sha256(n,...t)},taggedHashSync(e,...t){if("function"!=typeof D_)throw new i_("sha256Sync is undefined, you need to set it");let n=K_[e];if(void 0===n){const t=D_(Uint8Array.from(e,e=>e.charCodeAt(0)));n=m_(t,t),K_[e]=n}return D_(n,...t)},_JacobianPoint:o_};Object.defineProperties(X_,{sha256Sync:{configurable:!1,get:()=>D_,set(e){D_||(D_=e)}},hmacSha256Sync:{configurable:!1,get:()=>k_,set(e){k_||(k_=e)}}});var Y_,Z_={exports:{}};var J_,Q_=(Y_||(Y_=1,J_=Z_,function(){var e="input is invalid type",t="object"==typeof window,n=t?window:{};n.JS_SHA3_NO_WINDOW&&(t=!1);var r=!t&&"object"==typeof self;!n.JS_SHA3_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node?n=jn:r&&(n=self);for(var i=!n.JS_SHA3_NO_COMMON_JS&&J_.exports,s=!n.JS_SHA3_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,o="0123456789abcdef".split(""),a=[4,1024,262144,67108864],l=[0,8,16,24],c=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],h=[224,256,384,512],u=[128,256],d=["hex","buffer","arrayBuffer","array","digest"],p={128:168,256:136},f=n.JS_SHA3_NO_NODE_JS||!Array.isArray?e=>"[object Array]"==={}.toString.call(e):Array.isArray,m=!s||!n.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW&&ArrayBuffer.isView?ArrayBuffer.isView:e=>"object"==typeof e&&e.buffer&&e.buffer.constructor===ArrayBuffer,g=t=>{var n=typeof t;if("string"===n)return[t,!0];if("object"!==n||null===t)throw Error(e);if(s&&t.constructor===ArrayBuffer)return[new Uint8Array(t),!1];if(!f(t)&&!m(t))throw Error(e);return[t,!1]},y=e=>0===g(e)[0].length,b=e=>{for(var t=[],n=0;n<e.length;++n)t[n]=e[n];return t},v=(e,t,n)=>r=>new k(e,t,e).update(r)[n](),w=(e,t,n)=>(r,i)=>new k(e,t,i).update(r)[n](),x=(e,t,n)=>(t,r,i,s)=>A["cshake"+e].update(t,r,i,s)[n](),_=(e,t,n)=>(t,r,i,s)=>A["kmac"+e].update(t,r,i,s)[n](),E=(e,t,n,r)=>{for(var i=0;i<d.length;++i){var s=d[i];e[s]=t(n,r,s)}return e},S=(e,t)=>{var n=v(e,t,"hex");return n.create=()=>new k(e,t,e),n.update=e=>n.create().update(e),E(n,v,e,t)},M=[{name:"keccak",padding:[1,256,65536,16777216],bits:h,createMethod:S},{name:"sha3",padding:[6,1536,393216,100663296],bits:h,createMethod:S},{name:"shake",padding:[31,7936,2031616,520093696],bits:u,createMethod(e,t){var n=w(e,t,"hex");return n.create=n=>new k(e,t,n),n.update=(e,t)=>n.create(t).update(e),E(n,w,e,t)}},{name:"cshake",padding:a,bits:u,createMethod(e,t){var n=p[e],r=x(e,0,"hex");return r.create=(r,i,s)=>y(i)&&y(s)?A["shake"+e].create(r):new k(e,t,r).bytepad([i,s],n),r.update=(e,t,n,i)=>r.create(t,n,i).update(e),E(r,x,e,t)}},{name:"kmac",padding:a,bits:u,createMethod(e,t){var n=p[e],r=_(e,0,"hex");return r.create=(r,i,s)=>new N(e,t,i).bytepad(["KMAC",s],n).bytepad([r],n),r.update=(e,t,n,i)=>r.create(e,n,i).update(t),E(r,_,e,t)}}],A={},C=[],T=0;T<M.length;++T)for(var I=M[T],L=I.bits,P=0;P<L.length;++P){var R=I.name+"_"+L[P];if(C.push(R),A[R]=I.createMethod(L[P],I.padding),"sha3"!==I.name){var D=I.name+L[P];C.push(D),A[D]=A[R]}}function k(e,t,n){this.blocks=[],this.s=[],this.padding=t,this.outputBits=n,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=n>>5,this.extraBytes=(31&n)>>3;for(var r=0;r<50;++r)this.s[r]=0}function N(e,t,n){k.call(this,e,t,n)}k.prototype.update=function(e){if(this.finalized)throw Error("finalize already called");var t=g(e);e=t[0];for(var n,r,i=t[1],s=this.blocks,o=this.byteCount,a=e.length,c=this.blockCount,h=0,u=this.s;h<a;){if(this.reset)for(this.reset=!1,s[0]=this.block,n=1;n<c+1;++n)s[n]=0;if(i)for(n=this.start;h<a&&n<o;++h)(r=e.charCodeAt(h))<128?s[n>>2]|=r<<l[3&n++]:r<2048?(s[n>>2]|=(192|r>>6)<<l[3&n++],s[n>>2]|=(128|63&r)<<l[3&n++]):r<55296||r>=57344?(s[n>>2]|=(224|r>>12)<<l[3&n++],s[n>>2]|=(128|r>>6&63)<<l[3&n++],s[n>>2]|=(128|63&r)<<l[3&n++]):(r=65536+((1023&r)<<10|1023&e.charCodeAt(++h)),s[n>>2]|=(240|r>>18)<<l[3&n++],s[n>>2]|=(128|r>>12&63)<<l[3&n++],s[n>>2]|=(128|r>>6&63)<<l[3&n++],s[n>>2]|=(128|63&r)<<l[3&n++]);else for(n=this.start;h<a&&n<o;++h)s[n>>2]|=e[h]<<l[3&n++];if(this.lastByteIndex=n,n>=o){for(this.start=n-o,this.block=s[c],n=0;n<c;++n)u[n]^=s[n];F(u),this.reset=!0}else this.start=n}return this},k.prototype.encode=function(e,t){var n=255&e,r=1,i=[n];for(n=255&(e>>=8);n>0;)i.unshift(n),n=255&(e>>=8),++r;return t?i.push(r):i.unshift(r),this.update(i),i.length},k.prototype.encodeString=function(e){var t=g(e);e=t[0];var n=t[1],r=0,i=e.length;if(n)for(var s=0;s<e.length;++s){var o=e.charCodeAt(s);o<128?r+=1:o<2048?r+=2:o<55296||o>=57344?r+=3:(o=65536+((1023&o)<<10|1023&e.charCodeAt(++s)),r+=4)}else r=i;return r+=this.encode(8*r),this.update(e),r},k.prototype.bytepad=function(e,t){for(var n=this.encode(t),r=0;r<e.length;++r)n+=this.encodeString(e[r]);var i=(t-n%t)%t,s=[];return s.length=i,this.update(s),this},k.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var e=this.blocks,t=this.lastByteIndex,n=this.blockCount,r=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[n],t=1;t<n+1;++t)e[t]=0;for(e[n-1]|=2147483648,t=0;t<n;++t)r[t]^=e[t];F(r)}},k.prototype.toString=k.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,n=this.s,r=this.outputBlocks,i=this.extraBytes,s=0,a=0,l="";a<r;){for(s=0;s<t&&a<r;++s,++a)e=n[s],l+=o[e>>4&15]+o[15&e]+o[e>>12&15]+o[e>>8&15]+o[e>>20&15]+o[e>>16&15]+o[e>>28&15]+o[e>>24&15];a%t===0&&(n=b(n),F(n),s=0)}return i&&(e=n[s],l+=o[e>>4&15]+o[15&e],i>1&&(l+=o[e>>12&15]+o[e>>8&15]),i>2&&(l+=o[e>>20&15]+o[e>>16&15])),l},k.prototype.arrayBuffer=function(){this.finalize();var e,t=this.blockCount,n=this.s,r=this.outputBlocks,i=this.extraBytes,s=0,o=0,a=this.outputBits>>3;e=i?new ArrayBuffer(r+1<<2):new ArrayBuffer(a);for(var l=new Uint32Array(e);o<r;){for(s=0;s<t&&o<r;++s,++o)l[o]=n[s];o%t===0&&(n=b(n),F(n))}return i&&(l[o]=n[s],e=e.slice(0,a)),e},k.prototype.buffer=k.prototype.arrayBuffer,k.prototype.digest=k.prototype.array=function(){this.finalize();for(var e,t,n=this.blockCount,r=this.s,i=this.outputBlocks,s=this.extraBytes,o=0,a=0,l=[];a<i;){for(o=0;o<n&&a<i;++o,++a)e=a<<2,t=r[o],l[e]=255&t,l[e+1]=t>>8&255,l[e+2]=t>>16&255,l[e+3]=t>>24&255;a%n===0&&(r=b(r),F(r))}return s&&(e=a<<2,t=r[o],l[e]=255&t,s>1&&(l[e+1]=t>>8&255),s>2&&(l[e+2]=t>>16&255)),l},N.prototype=new k,N.prototype.finalize=function(){return this.encode(this.outputBits,!0),k.prototype.finalize.call(this)};var F=e=>{var t,n,r,i,s,o,a,l,h,u,d,p,f,m,g,y,b,v,w,x,_,E,S,M,A,C,T,I,L,P,R,D,k,N,F,O,B,z,U,H,q,V,G,W,j,$,K,X,Y,Z,J,Q,ee,te,ne,re,ie,se,oe,ae,le,ce,he;for(r=0;r<48;r+=2)i=e[0]^e[10]^e[20]^e[30]^e[40],s=e[1]^e[11]^e[21]^e[31]^e[41],o=e[2]^e[12]^e[22]^e[32]^e[42],a=e[3]^e[13]^e[23]^e[33]^e[43],l=e[4]^e[14]^e[24]^e[34]^e[44],h=e[5]^e[15]^e[25]^e[35]^e[45],u=e[6]^e[16]^e[26]^e[36]^e[46],d=e[7]^e[17]^e[27]^e[37]^e[47],t=(p=e[8]^e[18]^e[28]^e[38]^e[48])^(o<<1|a>>>31),n=(f=e[9]^e[19]^e[29]^e[39]^e[49])^(a<<1|o>>>31),e[0]^=t,e[1]^=n,e[10]^=t,e[11]^=n,e[20]^=t,e[21]^=n,e[30]^=t,e[31]^=n,e[40]^=t,e[41]^=n,t=i^(l<<1|h>>>31),n=s^(h<<1|l>>>31),e[2]^=t,e[3]^=n,e[12]^=t,e[13]^=n,e[22]^=t,e[23]^=n,e[32]^=t,e[33]^=n,e[42]^=t,e[43]^=n,t=o^(u<<1|d>>>31),n=a^(d<<1|u>>>31),e[4]^=t,e[5]^=n,e[14]^=t,e[15]^=n,e[24]^=t,e[25]^=n,e[34]^=t,e[35]^=n,e[44]^=t,e[45]^=n,t=l^(p<<1|f>>>31),n=h^(f<<1|p>>>31),e[6]^=t,e[7]^=n,e[16]^=t,e[17]^=n,e[26]^=t,e[27]^=n,e[36]^=t,e[37]^=n,e[46]^=t,e[47]^=n,t=u^(i<<1|s>>>31),n=d^(s<<1|i>>>31),e[8]^=t,e[9]^=n,e[18]^=t,e[19]^=n,e[28]^=t,e[29]^=n,e[38]^=t,e[39]^=n,e[48]^=t,e[49]^=n,m=e[0],g=e[1],$=e[11]<<4|e[10]>>>28,K=e[10]<<4|e[11]>>>28,I=e[20]<<3|e[21]>>>29,L=e[21]<<3|e[20]>>>29,ae=e[31]<<9|e[30]>>>23,le=e[30]<<9|e[31]>>>23,V=e[40]<<18|e[41]>>>14,G=e[41]<<18|e[40]>>>14,N=e[2]<<1|e[3]>>>31,F=e[3]<<1|e[2]>>>31,y=e[13]<<12|e[12]>>>20,b=e[12]<<12|e[13]>>>20,X=e[22]<<10|e[23]>>>22,Y=e[23]<<10|e[22]>>>22,P=e[33]<<13|e[32]>>>19,R=e[32]<<13|e[33]>>>19,ce=e[42]<<2|e[43]>>>30,he=e[43]<<2|e[42]>>>30,te=e[5]<<30|e[4]>>>2,ne=e[4]<<30|e[5]>>>2,O=e[14]<<6|e[15]>>>26,B=e[15]<<6|e[14]>>>26,v=e[25]<<11|e[24]>>>21,w=e[24]<<11|e[25]>>>21,Z=e[34]<<15|e[35]>>>17,J=e[35]<<15|e[34]>>>17,D=e[45]<<29|e[44]>>>3,k=e[44]<<29|e[45]>>>3,M=e[6]<<28|e[7]>>>4,A=e[7]<<28|e[6]>>>4,re=e[17]<<23|e[16]>>>9,ie=e[16]<<23|e[17]>>>9,z=e[26]<<25|e[27]>>>7,U=e[27]<<25|e[26]>>>7,x=e[36]<<21|e[37]>>>11,_=e[37]<<21|e[36]>>>11,Q=e[47]<<24|e[46]>>>8,ee=e[46]<<24|e[47]>>>8,W=e[8]<<27|e[9]>>>5,j=e[9]<<27|e[8]>>>5,C=e[18]<<20|e[19]>>>12,T=e[19]<<20|e[18]>>>12,se=e[29]<<7|e[28]>>>25,oe=e[28]<<7|e[29]>>>25,H=e[38]<<8|e[39]>>>24,q=e[39]<<8|e[38]>>>24,E=e[48]<<14|e[49]>>>18,S=e[49]<<14|e[48]>>>18,e[0]=m^~y&v,e[1]=g^~b&w,e[10]=M^~C&I,e[11]=A^~T&L,e[20]=N^~O&z,e[21]=F^~B&U,e[30]=W^~$&X,e[31]=j^~K&Y,e[40]=te^~re&se,e[41]=ne^~ie&oe,e[2]=y^~v&x,e[3]=b^~w&_,e[12]=C^~I&P,e[13]=T^~L&R,e[22]=O^~z&H,e[23]=B^~U&q,e[32]=$^~X&Z,e[33]=K^~Y&J,e[42]=re^~se&ae,e[43]=ie^~oe&le,e[4]=v^~x&E,e[5]=w^~_&S,e[14]=I^~P&D,e[15]=L^~R&k,e[24]=z^~H&V,e[25]=U^~q&G,e[34]=X^~Z&Q,e[35]=Y^~J&ee,e[44]=se^~ae&ce,e[45]=oe^~le&he,e[6]=x^~E&m,e[7]=_^~S&g,e[16]=P^~D&M,e[17]=R^~k&A,e[26]=H^~V&N,e[27]=q^~G&F,e[36]=Z^~Q&W,e[37]=J^~ee&j,e[46]=ae^~ce&te,e[47]=le^~he&ne,e[8]=E^~m&y,e[9]=S^~g&b,e[18]=D^~M&C,e[19]=k^~A&T,e[28]=V^~N&O,e[29]=G^~F&B,e[38]=Q^~W&$,e[39]=ee^~j&K,e[48]=ce^~te&re,e[49]=he^~ne&ie,e[0]^=c[r],e[1]^=c[r+1]};if(i)J_.exports=A;else for(T=0;T<C.length;++T)n[C[T]]=A[C[T]]}()),Z_.exports),eE=$n(Q_);function tE(e){return new Uint8Array(eE.keccak256.arrayBuffer(e))}function nE(e,t,n){try{return j_(d_.fromCompact(e.slice(0,64)),t,n)}catch{return!1}}function rE(e,t){switch(t){case"udp":return rE(e,"udp4")||rE(e,"udp6");case"tcp":return rE(e,"tcp4")||rE(e,"tcp6")}const n=t.endsWith("6"),r=e.get(n?"ip6":"ip");if(!r)return;const i=t.slice(0,3);let s;switch(i){case"udp":s=n?e.get("udp6"):e.get("udp");break;case"tcp":s=n?e.get("tcp6"):e.get("tcp");break;default:return}return s?function(e,t,n,r){let i=Us("/"+e+"/"+Fs(e,n));return i=i.encapsulate(Us("/"+t+"/"+Fs(t,r))),i}(n?"ip6":"ip4",i,r,s):void 0}function iE(e){const t=function(e){if(32===e.byteLength)return Gc(e);if(33===e.byteLength)return Eh(e);const t=Ko(e),n=t[1]?.[0];if("1.2.840.10045.3.1.7"===n||"1.3.132.0.34"===n||"1.3.132.0.35"===n)return la(t);if("1.2.840.113549.1.1.1"===t[0]?.[0])return Qc(t,e);throw new Ho("Could not extract public key from raw bytes")}(e);if("secp256k1"!==t.type)throw Error("Keypair type not implemented");return Hh(t)}function sE(e){const t=e.reduce((e,t)=>e+2+t.bytes.length,0),n=new Uint8Array(t),r=new DataView(n.buffer);let i=0;return e.forEach(e=>{if(e.getPeerId())throw Error("`multiaddr` field MUST not contain peer id");r.setUint16(i,e.bytes.length),i+=2,n.set(e.bytes,i),i+=e.bytes.length}),n}function oE(e){let t=0;return e.lightPush&&(t+=1),t<<=1,e.filter&&(t+=1),t<<=1,e.store&&(t+=1),t<<=1,e.relay&&(t+=1),t}class aE extends Map{seq;signature;constructor(e={},t=BigInt(1),n){super(Object.entries(e)),this.seq=t,this.signature=n}set(e,t){return this.signature=void 0,this.seq++,super.set(e,t)}get id(){const e=this.get("id");if(!e)throw Error("id not found.");return kn(e)}get publicKey(){if("v4"===this.id)return this.get("secp256k1");throw Error(Gx)}get rs(){const e=this.get("rs");if(e)return Gn(e)}get rsv(){const e=this.get("rsv");if(e)return Gn(e)}get ip(){return lE(this,"ip","ip4")}set ip(e){hE(this,"ip","ip4",e)}get tcp(){return cE(this,"tcp","tcp")}set tcp(e){uE(this,"tcp","tcp",e)}get udp(){return cE(this,"udp","udp")}set udp(e){uE(this,"udp","udp",e)}get ip6(){return lE(this,"ip6","ip6")}set ip6(e){hE(this,"ip6","ip6",e)}get tcp6(){return cE(this,"tcp6","tcp")}set tcp6(e){uE(this,"tcp6","tcp",e)}get udp6(){return cE(this,"udp6","udp")}set udp6(e){uE(this,"udp6","udp",e)}get multiaddrs(){const e=this.get("multiaddrs");if(e)return function(e){const t=[];let n=0;for(;n<e.length;){const r=new DataView(e.buffer,n,2).getUint16(0);n+=2;const i=e.slice(n,n+r);n+=r,t.push(Us(i))}return t}(e)}set multiaddrs(e){dE(this,"multiaddrs",e,sE)}get waku2(){const e=this.get("waku2");if(e)return function(e){const t={relay:!1,store:!1,filter:!1,lightPush:!1};return e%2&&(t.relay=!0),(e>>=1)%2&&(t.store=!0),(e>>=1)%2&&(t.filter=!0),(e>>=1)%2&&(t.lightPush=!0),t}(e[0])}set waku2(e){dE(this,"waku2",e,e=>new Uint8Array([oE(e)]))}}function lE(e,t,n){const r=e.get(t);if(r)return Fs(n,r)}function cE(e,t,n){const r=e.get(t);if(r)return Number(Fs(n,r))}function hE(e,t,n,r){dE(e,t,r,Os.bind({},n))}function uE(e,t,n,r){hE(e,t,n,r?.toString(10))}function dE(e,t,n,r){void 0!==n?e.set(t,r(n)):e.delete(t)}const pE=new ir("enr");var fE,mE;(e=>{e.TCP="tcp",e.UDP="udp"})(fE||(fE={})),(e=>{e.TCP4="tcp4",e.UDP4="udp4",e.TCP6="tcp6",e.UDP6="udp6"})(mE||(mE={}));class gE extends aE{static RECORD_PREFIX="enr:";peerId;static create(e={},t=BigInt(1),n){const r=new gE(e,t,n);try{const e=r.publicKey;e&&(r.peerId=iE(e))}catch(e){pE.error("Could not calculate peer id for ENR",e)}return r}get nodeId(){if("v4"===this.id)return this.publicKey?function(e){const t=c_.fromHex(e).toRawBytes(!1);return Dn(tE(t.slice(1)))}(this.publicKey):void 0;throw Error(Gx)}getLocationMultiaddr=rE.bind({},this);get shardInfo(){return this.rs&&this.rsv&&pE.warn("ENR contains both `rs` and `rsv` fields."),this.rs||this.rsv}setLocationMultiaddr(e){const t=e.protoNames();if(2!==t.length&&"udp"!==t[1]&&"tcp"!==t[1])throw Error("Invalid multiaddr");const n=e.tuples();if(!n[0][1]||!n[1][1])throw Error("Invalid multiaddr");4===n[0][0]?(this.set("ip",n[0][1]),this.set(t[1],n[1][1])):(this.set("ip6",n[0][1]),this.set(t[1]+"6",n[1][1]))}getAllLocationMultiaddrs(){const e=[];for(const t of Object.values(mE)){const n=this.getLocationMultiaddr(t);n&&e.push(n)}const t=this.multiaddrs??[];return e.concat(t).map(e=>this.peerId?e.encapsulate("/p2p/"+this.peerId.toString()):e)}get peerInfo(){const e=this.peerId;if(e)return{id:e,multiaddrs:this.getAllLocationMultiaddrs()}}getFullMultiaddr(e){if(this.peerId){const t=this.getLocationMultiaddr(e);if(t)return t.encapsulate("/p2p/"+this.peerId.toString())}}getFullMultiaddrs(){if(this.peerId&&this.multiaddrs){const e=this.peerId;return this.multiaddrs.map(t=>t.encapsulate("/p2p/"+e.toString()))}return[]}verify(e,t){if(!this.get("id")||"v4"!==this.id)throw Error(Gx);if(!this.publicKey)throw Error("Failed to verify ENR: No public key");return nE(t,tE(e),this.publicKey)}async sign(e,t){if("v4"!==this.id)throw Error(Gx);return this.signature=await async function(e,t){return G_(tE(t),e,{der:!1})}(t,e),this.signature}}let yE=!1,bE=!1;const vE={debug:1,default:2,info:2,warning:3,error:4,off:5};let wE=vE.default,xE=null;const _E=function(){try{const e=[];if(["NFD","NFC","NFKD","NFKC"].forEach(t=>{try{if("test"!=="test".normalize(t))throw Error("bad normalize")}catch(n){e.push(t)}}),e.length)throw Error("missing "+e.join(", "));0}catch(e){return e.message}return null}();var EE,SE;(e=>{e.DEBUG="DEBUG",e.INFO="INFO",e.WARNING="WARNING",e.ERROR="ERROR",e.OFF="OFF"})(EE||(EE={})),(e=>{e.UNKNOWN_ERROR="UNKNOWN_ERROR",e.NOT_IMPLEMENTED="NOT_IMPLEMENTED",e.UNSUPPORTED_OPERATION="UNSUPPORTED_OPERATION",e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.TIMEOUT="TIMEOUT",e.BUFFER_OVERRUN="BUFFER_OVERRUN",e.NUMERIC_FAULT="NUMERIC_FAULT",e.MISSING_NEW="MISSING_NEW",e.INVALID_ARGUMENT="INVALID_ARGUMENT",e.MISSING_ARGUMENT="MISSING_ARGUMENT",e.UNEXPECTED_ARGUMENT="UNEXPECTED_ARGUMENT",e.CALL_EXCEPTION="CALL_EXCEPTION",e.INSUFFICIENT_FUNDS="INSUFFICIENT_FUNDS",e.NONCE_EXPIRED="NONCE_EXPIRED",e.REPLACEMENT_UNDERPRICED="REPLACEMENT_UNDERPRICED",e.UNPREDICTABLE_GAS_LIMIT="UNPREDICTABLE_GAS_LIMIT",e.TRANSACTION_REPLACED="TRANSACTION_REPLACED",e.ACTION_REJECTED="ACTION_REJECTED"})(SE||(SE={}));const ME="0123456789abcdef";class AE{constructor(e){Object.defineProperty(this,"version",{enumerable:!0,value:e,writable:!1})}_log(e,t){const n=e.toLowerCase();null==vE[n]&&this.throwArgumentError("invalid log level name","logLevel",e)}debug(...e){this._log(AE.levels.DEBUG,e)}info(...e){this._log(AE.levels.INFO,e)}warn(...e){this._log(AE.levels.WARNING,e)}makeError(e,t,n){if(bE)return this.makeError("censored error",t,{});t||(t=AE.errors.UNKNOWN_ERROR),n||(n={});const r=[];Object.keys(n).forEach(e=>{const t=n[e];try{if(t instanceof Uint8Array){let n="";for(let e=0;e<t.length;e++)n+=ME[t[e]>>4],n+=ME[15&t[e]];r.push(e+"=Uint8Array(0x"+n+")")}else r.push(e+"="+JSON.stringify(t))}catch(t){r.push(e+"="+JSON.stringify(n[e].toString()))}}),r.push("code="+t),r.push("version="+this.version);const i=e;let s="";switch(t){case SE.NUMERIC_FAULT:{s="NUMERIC_FAULT";const t=e;switch(t){case"overflow":case"underflow":case"division-by-zero":s+="-"+t;break;case"negative-power":case"negative-width":s+="-unsupported";break;case"unbound-bitwise-result":s+="-unbound-result"}break}case SE.CALL_EXCEPTION:case SE.INSUFFICIENT_FUNDS:case SE.MISSING_NEW:case SE.NONCE_EXPIRED:case SE.REPLACEMENT_UNDERPRICED:case SE.TRANSACTION_REPLACED:case SE.UNPREDICTABLE_GAS_LIMIT:s=t}s&&(e+=" [ See: https://links.ethers.org/v5-errors-"+s+" ]"),r.length&&(e+=" ("+r.join(", ")+")");const o=Error(e);return o.reason=i,o.code=t,Object.keys(n).forEach(e=>{o[e]=n[e]}),o}throwError(e,t,n){throw this.makeError(e,t,n)}throwArgumentError(e,t,n){return this.throwError(e,AE.errors.INVALID_ARGUMENT,{argument:t,value:n})}assert(e,t,n,r){e||this.throwError(t,n,r)}assertArgument(e,t,n,r){e||this.throwArgumentError(t,n,r)}checkNormalize(e){_E&&this.throwError("platform missing String.prototype.normalize",AE.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:_E})}checkSafeUint53(e,t){"number"==typeof e&&(null==t&&(t="value not safe"),(e<0||e>=9007199254740991)&&this.throwError(t,AE.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:e}),e%1&&this.throwError(t,AE.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:e}))}checkArgumentCount(e,t,n){n=n?": "+n:"",e<t&&this.throwError("missing argument"+n,AE.errors.MISSING_ARGUMENT,{count:e,expectedCount:t}),e>t&&this.throwError("too many arguments"+n,AE.errors.UNEXPECTED_ARGUMENT,{count:e,expectedCount:t})}checkNew(e,t){e!==Object&&null!=e||this.throwError("missing new",AE.errors.MISSING_NEW,{name:t.name})}checkAbstract(e,t){e===t?this.throwError("cannot instantiate abstract class "+JSON.stringify(t.name)+" directly; use a sub-class",AE.errors.UNSUPPORTED_OPERATION,{name:e.name,operation:"new"}):e!==Object&&null!=e||this.throwError("missing new",AE.errors.MISSING_NEW,{name:t.name})}static globalLogger(){return xE||(xE=new AE("logger/5.8.0")),xE}static setCensorship(e,t){if(!e&&t&&this.globalLogger().throwError("cannot permanently disable censorship",AE.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"}),yE){if(!e)return;this.globalLogger().throwError("error censorship permanent",AE.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}bE=!!e,yE=!!t}static setLogLevel(e){const t=vE[e.toLowerCase()];null!=t?wE=t:AE.globalLogger().warn("invalid log level - "+e)}static from(e){return new AE(e)}}AE.errors=SE,AE.levels=EE;const CE=new AE("bytes/5.8.0");function TE(e){return!!e.toHexString}function IE(e){return e.slice||(e.slice=function(){const t=[].slice.call(arguments);return IE(new Uint8Array([].slice.apply(e,t)))}),e}function LE(e){return"number"==typeof e&&e==e&&e%1==0}function PE(e){if(null==e)return!1;if(e.constructor===Uint8Array)return!0;if("string"==typeof e)return!1;if(!LE(e.length)||e.length<0)return!1;for(let t=0;t<e.length;t++){const n=e[t];if(!LE(n)||n<0||n>=256)return!1}return!0}function RE(e,t){if(t||(t={}),"number"==typeof e){CE.checkSafeUint53(e,"invalid arrayify value");const t=[];for(;e;)t.unshift(255&e),e=parseInt(e/256+"");return 0===t.length&&t.push(0),IE(new Uint8Array(t))}if(t.allowMissingPrefix&&"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),TE(e)&&(e=e.toHexString()),DE(e)){let n=e.substring(2);n.length%2&&("left"===t.hexPad?n="0"+n:"right"===t.hexPad?n+="0":CE.throwArgumentError("hex data is odd-length","value",e));const r=[];for(let e=0;e<n.length;e+=2)r.push(parseInt(n.substring(e,e+2),16));return IE(new Uint8Array(r))}return PE(e)?IE(new Uint8Array(e)):CE.throwArgumentError("invalid arrayify value","value",e)}function DE(e){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))}const kE="0123456789abcdef";function NE(e,t){if(t||(t={}),"number"==typeof e){CE.checkSafeUint53(e,"invalid hexlify value");let t="";for(;e;)t=kE[15&e]+t,e=Math.floor(e/16);return t.length?(t.length%2&&(t="0"+t),"0x"+t):"0x00"}if("bigint"==typeof e)return(e=e.toString(16)).length%2?"0x0"+e:"0x"+e;if(t.allowMissingPrefix&&"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),TE(e))return e.toHexString();if(DE(e))return e.length%2&&("left"===t.hexPad?e="0x0"+e.substring(2):"right"===t.hexPad?e+="0":CE.throwArgumentError("hex data is odd-length","value",e)),e.toLowerCase();if(PE(e)){let t="0x";for(let n=0;n<e.length;n++){let r=e[n];t+=kE[(240&r)>>4]+kE[15&r]}return t}return CE.throwArgumentError("invalid hexlify value","value",e)}const FE=new AE("rlp/5.8.0");function OE(e){const t=[];for(;e;)t.unshift(255&e),e>>=8;return t}function BE(e,t,n){let r=0;for(let i=0;i<n;i++)r=256*r+e[t+i];return r}function zE(e){if(Array.isArray(e)){let t=[];if(e.forEach(e=>{t=t.concat(zE(e))}),t.length<=55)return t.unshift(192+t.length),t;const n=OE(t.length);return n.unshift(247+n.length),n.concat(t)}(function(e){return DE(e)&&!(e.length%2)||PE(e)})(e)||FE.throwArgumentError("RLP object must be BytesLike","object",e);const t=[].slice.call(RE(e));if(1===t.length&&t[0]<=127)return t;if(t.length<=55)return t.unshift(128+t.length),t;const n=OE(t.length);return n.unshift(183+n.length),n.concat(t)}function UE(e,t,n,r){const i=[];for(;n<t+1+r;){const s=HE(e,n);i.push(s.result),(n+=s.consumed)>t+1+r&&FE.throwError("child data too short",AE.errors.BUFFER_OVERRUN,{})}return{consumed:1+r,result:i}}function HE(e,t){if(0===e.length&&FE.throwError("data too short",AE.errors.BUFFER_OVERRUN,{}),e[t]>=248){const n=e[t]-247;t+1+n>e.length&&FE.throwError("data short segment too short",AE.errors.BUFFER_OVERRUN,{});const r=BE(e,t+1,n);return t+1+n+r>e.length&&FE.throwError("data long segment too short",AE.errors.BUFFER_OVERRUN,{}),UE(e,t,t+1+n,n+r)}if(e[t]>=192){const n=e[t]-192;return t+1+n>e.length&&FE.throwError("data array too short",AE.errors.BUFFER_OVERRUN,{}),UE(e,t,t+1,n)}if(e[t]>=184){const n=e[t]-183;t+1+n>e.length&&FE.throwError("data array too short",AE.errors.BUFFER_OVERRUN,{});const r=BE(e,t+1,n);t+1+n+r>e.length&&FE.throwError("data array too short",AE.errors.BUFFER_OVERRUN,{});return{consumed:1+n+r,result:NE(e.slice(t+1+n,t+1+n+r))}}if(e[t]>=128){const n=e[t]-128;t+1+n>e.length&&FE.throwError("data too short",AE.errors.BUFFER_OVERRUN,{});return{consumed:1+n,result:NE(e.slice(t+1,t+1+n))}}return{consumed:1,result:NE(e[t])}}const qE=new ir("enr:decoder");class VE{static fromString(e){if(!e.startsWith(gE.RECORD_PREFIX))throw Error(`"string encoded ENR must start with '${gE.RECORD_PREFIX}'`);return VE.fromRLP(rt(e.slice(4),"base64url"))}static fromRLP(e){const t=function(e){const t=RE(e),n=HE(t,0);return n.consumed!==t.length&&FE.throwArgumentError("invalid rlp data","data",e),n.result}(e).map(Rn);return async function(e){const{signature:t,seq:n,kvs:r}=function(e){if(!Array.isArray(e))throw Error("Decoded ENR must be an array");if(e.length%2!=0)throw Error("Decoded ENR must have an even number of elements");const[t,n,...r]=e;if(!t||Array.isArray(t))throw Error("Decoded ENR invalid signature: must be a byte array");if(!n||Array.isArray(n))throw Error("Decoded ENR invalid sequence number: must be a byte array");return{signature:t,seq:n,kvs:r}}(e),i={};for(let e=0;e<r.length;e+=2)try{i[kn(r[e])]=r[e+1]}catch(t){qE.error("Failed to decode ENR key to UTF-8, skipping it",r[e],t)}const s=function(e){return e.length?BigInt("0x"+Dn(e)):BigInt(0)}(n),o=gE.create(i,s,t);return function(e,t,n,r){const i=Rn((s=[e,...t],NE(zE(s))));var s;if(!n.verify(i,r))throw Error("Unable to verify ENR signature")}(n,r,o,t),o}(t)}}class GE extends Map{#N=0;#F=new Map;#O=new Map;#B;#z;#U;constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"==typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.#B=e.maxSize,this.#z=e.maxAge||1/0,this.#U=e.onEviction}get __oldCache(){return this.#O}#H(e){if("function"==typeof this.#U)for(const[t,n]of e)this.#U(t,n.value)}#q(e,t){return"number"==typeof t.expiry&&t.expiry<=Date.now()&&("function"==typeof this.#U&&this.#U(e,t.value),this.delete(e))}#V(e,t){if(!1===this.#q(e,t))return t.value}#G(e,t){return t.expiry?this.#V(e,t):t.value}#W(e,t){const n=t.get(e);return this.#G(e,n)}#j(e,t){this.#F.set(e,t),this.#N++,this.#N>=this.#B&&(this.#N=0,this.#H(this.#O),this.#O=this.#F,this.#F=new Map)}#$(e,t){this.#O.delete(e),this.#j(e,t)}*#K(){for(const e of this.#O){const[t,n]=e;if(!this.#F.has(t)){!1===this.#q(t,n)&&(yield e)}}for(const e of this.#F){const[t,n]=e;!1===this.#q(t,n)&&(yield e)}}get(e){if(this.#F.has(e)){const t=this.#F.get(e);return this.#G(e,t)}if(this.#O.has(e)){const t=this.#O.get(e);if(!1===this.#q(e,t))return this.#$(e,t),t.value}}set(e,t,{maxAge:n=this.#z}={}){const r="number"==typeof n&&n!==1/0?Date.now()+n:void 0;return this.#F.has(e)?this.#F.set(e,{value:t,expiry:r}):this.#j(e,{value:t,expiry:r}),this}has(e){return this.#F.has(e)?!this.#q(e,this.#F.get(e)):!!this.#O.has(e)&&!this.#q(e,this.#O.get(e))}peek(e){return this.#F.has(e)?this.#W(e,this.#F):this.#O.has(e)?this.#W(e,this.#O):void 0}expiresIn(e){const t=this.#F.get(e)??this.#O.get(e);if(t)return t.expiry?t.expiry-Date.now():1/0}delete(e){const t=this.#F.delete(e);return t&&this.#N--,this.#O.delete(e)||t}clear(){this.#F.clear(),this.#O.clear(),this.#N=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this.#K()],n=t.length-e;n<0?(this.#F=new Map(t),this.#O=new Map,this.#N=t.length):(n>0&&this.#H(t.slice(0,n)),this.#O=new Map(t.slice(n)),this.#F=new Map,this.#N=0),this.#B=e}evict(e=1){const t=Number(e);if(!t||t<=0)return;const n=[...this.#K()],r=Math.trunc(Math.min(t,Math.max(n.length-1,0)));r<=0||(this.#H(n.slice(0,r)),this.#O=new Map(n.slice(r)),this.#F=new Map,this.#N=0)}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.#F){const[t,n]=e;!1===this.#q(t,n)&&(yield[t,n.value])}for(const e of this.#O){const[t,n]=e;if(!this.#F.has(t)){!1===this.#q(t,n)&&(yield[t,n.value])}}}*entriesDescending(){let e=[...this.#F];for(let t=e.length-1;t>=0;--t){const n=e[t],[r,i]=n;!1===this.#q(r,i)&&(yield[r,i.value])}e=[...this.#O];for(let t=e.length-1;t>=0;--t){const n=e[t],[r,i]=n;if(!this.#F.has(r)){!1===this.#q(r,i)&&(yield[r,i.value])}}}*entriesAscending(){for(const[e,t]of this.#K())yield[e,t.value]}get size(){if(!this.#N)return this.#O.size;let e=0;for(const t of this.#O.keys())this.#F.has(t)||e++;return Math.min(this.#N+e,this.#B)}get maxSize(){return this.#B}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[n,r]of this.entriesAscending())e.call(t,r,n,this)}get[Symbol.toStringTag](){return"QuickLRU"}toString(){return`QuickLRU(${this.size}/${this.maxSize})`}[Symbol.for("nodejs.util.inspect.custom")](){return this.toString()}}function WE(e,t,n){return`${e}?name=${t}&type=${n}`}async function jE(e,t){const n=await fetch(e,{headers:new Headers({accept:"application/dns-json"}),signal:t});return await n.json()}function $E(e,t){return`${t}_${e}`}const KE=Object.assign(Ly("dns-over-http-resolver"),{error:Ly("dns-over-http-resolver:error")});class XE{_cache;_TXTcache;_servers;_request;_abortControllers;constructor(e={}){this._cache=new GE({maxSize:e?.maxCache??100}),this._TXTcache=new GE({maxSize:e?.maxCache??100}),this._servers=["https://cloudflare-dns.com/dns-query","https://dns.google/resolve"],this._request=e.request??jE,this._abortControllers=[]}cancel(){this._abortControllers.forEach(e=>{e.abort()})}getServers(){return this._servers}_getShuffledServers(){const e=[...this._servers];for(let t=e.length-1;t>0;t--){const n=Math.floor(Math.random()*t),r=e[t];e[t]=e[n],e[n]=r}return e}setServers(e){this._servers=e}async resolve(e,t="A"){switch(t){case"A":return this.resolve4(e);case"AAAA":return this.resolve6(e);case"TXT":return this.resolveTxt(e);default:throw Error(t+" is not supported")}}async resolve4(e){const t="A",n=this._cache.get($E(e,t));if(null!=n)return n;let r=!1;for(const n of this._getShuffledServers()){const i=new AbortController;this._abortControllers.push(i);try{const r=await this._request(WE(n,e,t),i.signal),s=r.Answer.map(e=>e.data),o=Math.min(...r.Answer.map(e=>e.TTL));return this._cache.set($E(e,t),s,{maxAge:o}),s}catch(s){i.signal.aborted&&(r=!0),KE.error(`${n} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter(e=>e!==i)}}if(r)throw Object.assign(Error("queryA ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}async resolve6(e){const t="AAAA",n=this._cache.get($E(e,t));if(null!=n)return n;let r=!1;for(const n of this._getShuffledServers()){const i=new AbortController;this._abortControllers.push(i);try{const r=await this._request(WE(n,e,t),i.signal),s=r.Answer.map(e=>e.data),o=Math.min(...r.Answer.map(e=>e.TTL));return this._cache.set($E(e,t),s,{maxAge:o}),s}catch(s){i.signal.aborted&&(r=!0),KE.error(`${n} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter(e=>e!==i)}}if(r)throw Object.assign(Error("queryAaaa ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}async resolveTxt(e){const t="TXT",n=this._TXTcache.get($E(e,t));if(null!=n)return n;let r=!1;for(const n of this._getShuffledServers()){const i=new AbortController;this._abortControllers.push(i);try{const r=await this._request(WE(n,e,t),i.signal),s=r.Answer.map(e=>[e.data.replace(/['"]+/g,"")]),o=Math.min(...r.Answer.map(e=>e.TTL));return this._TXTcache.set($E(e,t),s,{maxAge:o}),s}catch(s){i.signal.aborted&&(r=!0),KE.error(`${n} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter(e=>e!==i)}}if(r)throw Object.assign(Error("queryTxt ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}clearCache(){this._cache.clear(),this._TXTcache.clear()}}const YE=new ir("dns-over-https");class ZE{resolver;static async create(){return new ZE}constructor(e=new XE){this.resolver=e}async resolveTXT(e){let t;try{t=await this.resolver.resolveTxt(e)}catch(e){throw YE.error("query failed: ",e),Error("DNS query failed")}if(!t)throw Error("Could not resolve "+e);const n=[];return t.forEach(e=>{"string"==typeof e?n.push(e):Array.isArray(e)?e.forEach(e=>{"string"==typeof e?n.push(e):n.push(kn(e))}):n.push(kn(e))}),n}}var JE,QE={exports:{}};var eS=(JE||(JE=1,(e=>{(()=>{var t="object"==typeof window?window:{};!t.HI_BASE32_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node&&(t=jn);var n=!t.HI_BASE32_NO_COMMON_JS&&e.exports,r="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""),i={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,2:26,3:27,4:28,5:29,6:30,7:31},s=[0,0,0,0,0,0,0,0],o=(e,t)=>{t.length>10&&(t="..."+t.substr(-10));var n=Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading "+e+" bytes: "+t+" <-");throw n.position=e,n},a=e=>{if(""===e)return[];if(!/^[A-Z2-7=]+$/.test(e))throw Error("Invalid base32 characters");for(var t,n,r,s,o,a,l,c,h=[],u=0,d=(e=e.replace(/=/g,"")).length,p=0,f=d>>3<<3;p<f;)t=i[e.charAt(p++)],n=i[e.charAt(p++)],r=i[e.charAt(p++)],s=i[e.charAt(p++)],o=i[e.charAt(p++)],a=i[e.charAt(p++)],l=i[e.charAt(p++)],c=i[e.charAt(p++)],h[u++]=255&(t<<3|n>>>2),h[u++]=255&(n<<6|r<<1|s>>>4),h[u++]=255&(s<<4|o>>>1),h[u++]=255&(o<<7|a<<2|l>>>3),h[u++]=255&(l<<5|c);var m=d-f;return 2===m?(t=i[e.charAt(p++)],n=i[e.charAt(p++)],h[u++]=255&(t<<3|n>>>2)):4===m?(t=i[e.charAt(p++)],n=i[e.charAt(p++)],r=i[e.charAt(p++)],s=i[e.charAt(p++)],h[u++]=255&(t<<3|n>>>2),h[u++]=255&(n<<6|r<<1|s>>>4)):5===m?(t=i[e.charAt(p++)],n=i[e.charAt(p++)],r=i[e.charAt(p++)],s=i[e.charAt(p++)],o=i[e.charAt(p++)],h[u++]=255&(t<<3|n>>>2),h[u++]=255&(n<<6|r<<1|s>>>4),h[u++]=255&(s<<4|o>>>1)):7===m&&(t=i[e.charAt(p++)],n=i[e.charAt(p++)],r=i[e.charAt(p++)],s=i[e.charAt(p++)],o=i[e.charAt(p++)],a=i[e.charAt(p++)],l=i[e.charAt(p++)],h[u++]=255&(t<<3|n>>>2),h[u++]=255&(n<<6|r<<1|s>>>4),h[u++]=255&(s<<4|o>>>1),h[u++]=255&(o<<7|a<<2|l>>>3)),h},l=(e,t)=>{if(!t)return(e=>{for(var t,n,r="",i=e.length,s=0,a=0;s<i;)if((t=e[s++])<=127)r+=String.fromCharCode(t);else{t>191&&t<=223?(n=31&t,a=1):t<=239?(n=15&t,a=2):t<=247?(n=7&t,a=3):o(s,r);for(var l=0;l<a;++l)((t=e[s++])<128||t>191)&&o(s,r),n<<=6,n+=63&t;n>=55296&&n<=57343&&o(s,r),n>1114111&&o(s,r),n<=65535?r+=String.fromCharCode(n):(r+=String.fromCharCode(55296+((n-=65536)>>10)),r+=String.fromCharCode(56320+(1023&n)))}return r})(a(e));if(""===e)return"";if(!/^[A-Z2-7=]+$/.test(e))throw Error("Invalid base32 characters");var n,r,s,l,c,h,u,d,p="",f=e.indexOf("=");-1===f&&(f=e.length);for(var m=0,g=f>>3<<3;m<g;)n=i[e.charAt(m++)],r=i[e.charAt(m++)],s=i[e.charAt(m++)],l=i[e.charAt(m++)],c=i[e.charAt(m++)],h=i[e.charAt(m++)],u=i[e.charAt(m++)],d=i[e.charAt(m++)],p+=String.fromCharCode(255&(n<<3|r>>>2))+String.fromCharCode(255&(r<<6|s<<1|l>>>4))+String.fromCharCode(255&(l<<4|c>>>1))+String.fromCharCode(255&(c<<7|h<<2|u>>>3))+String.fromCharCode(255&(u<<5|d));var y=f-g;return 2===y?(n=i[e.charAt(m++)],r=i[e.charAt(m++)],p+=String.fromCharCode(255&(n<<3|r>>>2))):4===y?(n=i[e.charAt(m++)],r=i[e.charAt(m++)],s=i[e.charAt(m++)],l=i[e.charAt(m++)],p+=String.fromCharCode(255&(n<<3|r>>>2))+String.fromCharCode(255&(r<<6|s<<1|l>>>4))):5===y?(n=i[e.charAt(m++)],r=i[e.charAt(m++)],s=i[e.charAt(m++)],l=i[e.charAt(m++)],c=i[e.charAt(m++)],p+=String.fromCharCode(255&(n<<3|r>>>2))+String.fromCharCode(255&(r<<6|s<<1|l>>>4))+String.fromCharCode(255&(l<<4|c>>>1))):7===y&&(n=i[e.charAt(m++)],r=i[e.charAt(m++)],s=i[e.charAt(m++)],l=i[e.charAt(m++)],c=i[e.charAt(m++)],h=i[e.charAt(m++)],u=i[e.charAt(m++)],p+=String.fromCharCode(255&(n<<3|r>>>2))+String.fromCharCode(255&(r<<6|s<<1|l>>>4))+String.fromCharCode(255&(l<<4|c>>>1))+String.fromCharCode(255&(c<<7|h<<2|u>>>3))),p},c={encode(e,t){var n="string"!=typeof e;return n&&e.constructor===ArrayBuffer&&(e=new Uint8Array(e)),n?(e=>{for(var t,n,i,s,o,a="",l=e.length,c=0,h=5*parseInt(l/5);c<h;)t=e[c++],n=e[c++],i=e[c++],s=e[c++],o=e[c++],a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[31&(i<<1|s>>>7)]+r[s>>>2&31]+r[31&(s<<3|o>>>5)]+r[31&o];var u=l-h;return 1===u?(t=e[c],a+=r[t>>>3]+r[t<<2&31]+"======"):2===u?(t=e[c++],n=e[c],a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[n<<4&31]+"===="):3===u?(t=e[c++],n=e[c++],i=e[c],a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[i<<1&31]+"==="):4===u&&(t=e[c++],n=e[c++],i=e[c++],s=e[c],a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[31&(i<<1|s>>>7)]+r[s>>>2&31]+r[s<<3&31]+"="),a})(e):t?(e=>{for(var t,n,i,s,o,a="",l=e.length,c=0,h=5*parseInt(l/5);c<h;)t=e.charCodeAt(c++),n=e.charCodeAt(c++),i=e.charCodeAt(c++),s=e.charCodeAt(c++),o=e.charCodeAt(c++),a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[31&(i<<1|s>>>7)]+r[s>>>2&31]+r[31&(s<<3|o>>>5)]+r[31&o];var u=l-h;return 1===u?(t=e.charCodeAt(c),a+=r[t>>>3]+r[t<<2&31]+"======"):2===u?(t=e.charCodeAt(c++),n=e.charCodeAt(c),a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[n<<4&31]+"===="):3===u?(t=e.charCodeAt(c++),n=e.charCodeAt(c++),i=e.charCodeAt(c),a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[i<<1&31]+"==="):4===u&&(t=e.charCodeAt(c++),n=e.charCodeAt(c++),i=e.charCodeAt(c++),s=e.charCodeAt(c),a+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[31&(i<<1|s>>>7)]+r[s>>>2&31]+r[s<<3&31]+"="),a})(e):(e=>{var t,n,i,o,a,l,c,h=!1,u="",d=0,p=0,f=e.length;if(""===e)return u;do{for(s[0]=s[5],s[1]=s[6],s[2]=s[7],c=p;d<f&&c<5;++d)(l=e.charCodeAt(d))<128?s[c++]=l:l<2048?(s[c++]=192|l>>6,s[c++]=128|63&l):l<55296||l>=57344?(s[c++]=224|l>>12,s[c++]=128|l>>6&63,s[c++]=128|63&l):(l=65536+((1023&l)<<10|1023&e.charCodeAt(++d)),s[c++]=240|l>>18,s[c++]=128|l>>12&63,s[c++]=128|l>>6&63,s[c++]=128|63&l);p=c-5,d===f&&++d,d>f&&c<6&&(h=!0),t=s[0],c>4?(n=s[1],i=s[2],o=s[3],a=s[4],u+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[31&(i<<1|o>>>7)]+r[o>>>2&31]+r[31&(o<<3|a>>>5)]+r[31&a]):1===c?u+=r[t>>>3]+r[t<<2&31]+"======":2===c?(n=s[1],u+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[n<<4&31]+"===="):3===c?(n=s[1],i=s[2],u+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[i<<1&31]+"==="):(n=s[1],i=s[2],o=s[3],u+=r[t>>>3]+r[31&(t<<2|n>>>6)]+r[n>>>1&31]+r[31&(n<<4|i>>>4)]+r[31&(i<<1|o>>>7)]+r[o>>>2&31]+r[o<<3&31]+"=")}while(!h);return u})(e)},decode:l};l.asBytes=a,n?e.exports=c:t.base32=c})()})(QE)),QE.exports),tS=$n(eS);class nS{static RECORD_PREFIX=gE.RECORD_PREFIX;static TREE_PREFIX="enrtree:";static BRANCH_PREFIX="enrtree-branch:";static ROOT_PREFIX="enrtree-root:";static parseAndVerifyRoot(e,t){if(!e.startsWith(this.ROOT_PREFIX))throw Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);const n=nS.parseRootValues(e),r=tS.decode.asBytes(t),i=e.split(" sig")[0],s=Nn(i);if(!nE(rt(n.signature,"base64url").slice(0,64),tE(s),new Uint8Array(r)))throw Error("Unable to verify ENRTree root signature");return n.eRoot}static parseRootValues(e){const t=e.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);if(!Array.isArray(t))throw Error("Could not parse ENRTree root entry");t.shift();const[n,r,i,s]=t;if(!n)throw Error("Could not parse 'e' value from ENRTree root entry");if(!r)throw Error("Could not parse 'l' value from ENRTree root entry");if(!i)throw Error("Could not parse 'seq' value from ENRTree root entry");if(!s)throw Error("Could not parse 'sig' value from ENRTree root entry");return{eRoot:n,lRoot:r,seq:Number(i),signature:s}}static parseTree(e){if(!e.startsWith(this.TREE_PREFIX))throw Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);const t=e.match(/^enrtree:\/\/([^@]+)@(.+)$/);if(!Array.isArray(t))throw Error("Could not parse ENRTree tree entry");t.shift();const[n,r]=t;if(!n)throw Error("Could not parse public key from ENRTree tree entry");if(!r)throw Error("Could not parse domain from ENRTree tree entry");return{publicKey:n,domain:r}}static parseBranch(e){if(!e.startsWith(this.BRANCH_PREFIX))throw Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);return e.split(this.BRANCH_PREFIX)[1].split(",")}}const rS=new ir("discovery:fetch_nodes");function iS(e,t){return t.relay>=e.relay&&t.store>=e.store&&t.filter>=e.filter&&t.lightPush>=e.lightPush}function sS(e,t){if(!e.nodeId)return!1;for(const n of t)if(e.nodeId===n.nodeId)return!1;return!0}function oS(e,t){e.relay&&(t.relay+=1),e.store&&(t.store+=1),e.filter&&(t.filter+=1),e.lightPush&&(t.lightPush+=1)}function aS(e,t,n){if(iS(t,n))throw"Internal Error: Waku2 wanted capabilities are already fulfilled";const r=function(e,t){return{relay:t.relay<e.relay,store:t.store<e.store,filter:t.filter<e.filter,lightPush:t.lightPush<e.lightPush}}(t,n);return r.relay&&e.relay||r.store&&e.store||r.filter&&e.filter||r.lightPush&&e.lightPush}const lS=new ir("discovery:dns");class cS{dns;_DNSTreeCache;_errorTolerance=10;static async dnsOverHttp(e){return e||(e=await ZE.create()),new cS(e)}async getPeers(e,t){const n=Math.floor(Math.random()*e.length),{publicKey:r,domain:i}=nS.parseTree(e[n]),s={domain:i,publicKey:r,visits:{}},o=await async function(e,t,n){const r={relay:e.relay??0,store:e.store??0,filter:e.filter??0,lightPush:e.lightPush??0},i=r.relay+r.store+r.filter+r.lightPush,s={relay:0,store:0,filter:0,lightPush:0};let o=0;const a=[];for(;!iS(r,s)&&o<i+t;){const e=await n();e&&sS(e,a)&&(e.waku2&&aS(e.waku2,r,s)&&(oS(e.waku2,s),a.push(e)),rS.info(`got new peer candidate from DNS address=${e.nodeId}@${e.ip}`)),o++}return a}(t,this._errorTolerance,()=>this._search(i,s));return lS.info("retrieved peers: ",o.map(e=>({id:e.peerId?.toString(),multiaddrs:e.multiaddrs?.map(e=>e.toString())}))),o}constructor(e){this._DNSTreeCache={},this.dns=e}async*getNextPeer(e,t){const n=Math.floor(Math.random()*e.length),{publicKey:r,domain:i}=nS.parseTree(e[n]),s={domain:i,publicKey:r,visits:{}};for await(const e of async function*(e,t,n){const r={relay:e.relay??0,store:e.store??0,filter:e.filter??0,lightPush:e.lightPush??0},i=r.relay+r.store+r.filter+r.lightPush,s={relay:0,store:0,filter:0,lightPush:0};let o=0;const a=new Set;for(;!iS(r,s)&&o<i+t;){const e=await n();e&&e.nodeId&&!a.has(e.nodeId)&&(a.add(e.nodeId),e.waku2&&aS(e.waku2,r,s)&&(oS(e.waku2,s),yield e),rS.info(`got new peer candidate from DNS address=${e.nodeId}@${e.ip}`)),o++}}(t,this._errorTolerance,()=>this._search(i,s)))yield e}async _search(e,t){try{const n=await this._getTXTRecord(e,t);let r,i;t.visits[e]=!0;const s=function(e){return e.startsWith(nS.ROOT_PREFIX)?nS.ROOT_PREFIX:e.startsWith(nS.BRANCH_PREFIX)?nS.BRANCH_PREFIX:e.startsWith(nS.RECORD_PREFIX)?nS.RECORD_PREFIX:""}(n);try{switch(s){case nS.ROOT_PREFIX:return r=nS.parseAndVerifyRoot(n,t.publicKey),await this._search(r,t);case nS.BRANCH_PREFIX:return i=nS.parseBranch(n),r=function(e,t){const n={};for(const[r,i]of e.entries())t.visits[i]&&(n[r]=!0);if(Object.keys(n).length===e.length)throw Error("Unresolvable circular path detected");let r;do{r=Math.floor(Math.random()*e.length)}while(n[r]);return e[r]}(i,t),await this._search(r,t);case nS.RECORD_PREFIX:return VE.fromString(n);default:return null}}catch(t){return lS.error(`Failed to search DNS tree ${s} at subdomain ${e}: ${t}`),null}}catch(t){return lS.error(`Failed to retrieve TXT record at subdomain ${e}: ${t}`),null}}async _getTXTRecord(e,t){if(this._DNSTreeCache[e])return this._DNSTreeCache[e];const n=e!==t.domain?`${e}.${t.domain}`:t.domain,r=await this.dns.resolveTXT(n);if(!r.length)throw Error("Received empty result array while fetching TXT record");if(!r[0].length)throw Error("Received empty TXT record");const i=r.join("");return this._DNSTreeCache[e]=i,i}}const hS=new ir("peer-discovery-dns");class uS extends Hi{nextPeer;_started;_components;_options;constructor(e,t){super(),this._started=!1,this._components=e,this._options=t;const{enrUrls:n}=t;hS.info("Use following EIP-1459 ENR Tree URLs: ",n)}async start(){hS.info("Starting peer discovery via dns"),this._started=!0,await this.findPeers()}async findPeers(){if(!this.nextPeer){let{enrUrls:e}=this._options;Array.isArray(e)||(e=[e]);const{wantedNodeCapabilityCount:t}=this._options,n=await cS.dnsOverHttp();this.nextPeer=n.getNextPeer.bind(n,e,t)}for await(const e of this.nextPeer()){if(!this._started)return;const{peerInfo:t,shardInfo:n}=e;if(!t)continue;const r={[qx]:{value:this._options.tagValue??50,ttl:this._options.tagTTL??1e8}};let i=!1;if(await this._components.peerStore.has(t.id)){(await this._components.peerStore.get(t.id)).tags.has(qx)||(i=!0,await this._components.peerStore.merge(t.id,{tags:r}))}else i=!0,await this._components.peerStore.save(t.id,{tags:r,...n&&{metadata:{shardInfo:Wn(n)}}});i&&this.dispatchEvent(new CustomEvent("peer",{detail:t}))}}stop(){this._started=!1}get[Ux](){return!0}get[Symbol.toStringTag](){return Cn}}function dS(e,t=Vx){return n=>new uS(n,{enrUrls:e,wantedNodeCapabilityCount:t})}function pS(e){return e.filter(e=>"open"===e.status).sort((e,t)=>t.timeline.open-e.timeline.open).at(0)}const fS="consumed";class mS{multicodec;getConnections;addEventListener;log;ongoingCreation=new Set;streamPool=new Map;constructor(e,t,n){this.multicodec=e,this.getConnections=t,this.addEventListener=n,this.log=new ir("stream-manager:"+e),this.addEventListener("peer:update",this.handlePeerUpdateStreamPool)}async getStream(e){const t=e.toString(),n=this.streamPool.get(t);n&&(this.streamPool.delete(t),await n);let r=this.getOpenStreamForCodec(e);return r?(this.log.info(`Found existing stream peerId=${t} multicodec=${this.multicodec}`),this.lockStream(t,r),r):(r=await this.createStream(e),this.lockStream(t,r),r)}async createStream(e,t=0){const n=pS(this.getConnections(e));if(!n)throw Error(`Failed to get a connection to the peer peerId=${e.toString()} multicodec=${this.multicodec}`);let r,i;for(let s=0;s<t+1;s++)try{this.log.info(`Attempting to create a stream for peerId=${e.toString()} multicodec=${this.multicodec}`),i=await n.newStream(this.multicodec),this.log.info(`Created stream for peerId=${e.toString()} multicodec=${this.multicodec}`);break}catch(e){r=e}if(!i)throw Error(`Failed to create a new stream for ${e.toString()} -- `+r);return i}async createStreamWithLock(e){const t=e.id.toString();if(this.ongoingCreation.has(t))this.log.info(`Skipping creation of a stream due to lock for peerId=${t} multicodec=${this.multicodec}`);else try{this.ongoingCreation.add(t),await this.createStream(e.id)}catch(e){this.log.error("Failed to createStreamWithLock:",e)}finally{this.ongoingCreation.delete(t)}}handlePeerUpdateStreamPool=e=>{const{peer:t}=e.detail;if(!t.protocols.includes(this.multicodec))return;this.getOpenStreamForCodec(t.id)||this.scheduleNewStream(t)};scheduleNewStream(e){this.log.info(`Scheduling creation of a stream for peerId=${e.id.toString()} multicodec=${this.multicodec}`),this.streamPool.has(e.id.toString())&&this.streamPool.delete(e.id.toString()),this.streamPool.set(e.id.toString(),this.createStreamWithLock(e))}getOpenStreamForCodec(e){const t=pS(this.getConnections(e));if(!t)return;const n=t.streams.find(e=>e.protocol===this.multicodec);if(!n)return;return["done","closed","closing"].includes(n.writeStatus||"")||this.isStreamLocked(n)?void 0:n}lockStream(e,t){this.log.info(`Locking stream for peerId:${e}\tstreamId:${t.id}`),t.metadata[fS]=!0}isStreamLocked(e){return!!e.metadata[fS]}}class gS{multicodec;components;pubsubTopics;addLibp2pEventListener;removeLibp2pEventListener;streamManager;constructor(e,t,n){this.multicodec=e,this.components=t,this.pubsubTopics=n,this.addLibp2pEventListener=t.events.addEventListener.bind(t.events),this.removeLibp2pEventListener=t.events.removeEventListener.bind(t.events),this.streamManager=new mS(e,t.connectionManager.getConnections.bind(t.connectionManager),this.addLibp2pEventListener)}async getStream(e){return this.streamManager.getStream(e)}}class yS{proto;constructor(e){this.proto=e}static createRequest(e){const{numPeers:t}=e;return new yS({query:{numPeers:t},response:void 0})}encode(){return Wt.encode(this.proto)}static decode(e){const t=Wt.decode(e);return new yS(t)}get query(){return this.proto.query}get response(){return this.proto.response}}const bS="/vac/waku/peer-exchange/2.0.0-alpha1",vS=new ir("peer-exchange");class wS extends gS{constructor(e,t){super(bS,e,t)}async query(e){const{numPeers:t,peerId:n}=e,r=yS.createRequest({numPeers:BigInt(t)});if(!await this.components.peerStore.get(n))return{peerInfos:null,error:En.NO_PEER_AVAILABLE};let i;try{i=await this.getStream(n)}catch(e){return vS.error("Failed to get stream",e),{peerInfos:null,error:En.NO_STREAM_AVAILABLE}}const s=await Ur([r.encode()],xr,i,Tr,async e=>await dr(e));try{const e=new br;s.forEach(t=>{e.append(t)});const{response:t}=yS.decode(e);if(!t)return vS.error("PeerExchangeRPC message did not contains a `response` field"),{peerInfos:null,error:En.EMPTY_PAYLOAD};return{peerInfos:await Promise.all(t.peerInfos.map(e=>e.enr).filter(tn).map(async e=>({ENR:await VE.fromRLP(e)}))),error:null}}catch(e){return vS.error("Failed to decode push reply",e),{peerInfos:null,error:En.DECODE_FAILED}}}}const xS=new ir("peer-exchange-discovery"),_S=1e4,ES=3,SS=Sn.PEER_EXCHANGE;class MS extends Hi{components;peerExchange;options;isStarted;queryingPeers=new Set;queryAttempts=new Map;handleDiscoveredPeer=e=>{const{protocols:t,peerId:n}=e.detail;t.includes(bS)&&!this.queryingPeers.has(n.toString())&&(this.queryingPeers.add(n.toString()),this.startRecurringQueries(n).catch(e=>xS.error("Error querying peer "+e)))};constructor(e,t,n={}){super(),this.components=e,this.peerExchange=new wS(e,t),this.options=n,this.isStarted=!1}start(){this.isStarted||(this.dispatchEvent(new CustomEvent("waku:peer-exchange:started",{detail:!0})),xS.info("Starting peer exchange node discovery, discovering peers"),this.components.events.addEventListener("peer:identify",this.handleDiscoveredPeer))}stop(){this.isStarted&&(xS.info("Stopping peer exchange node discovery"),this.isStarted=!1,this.queryingPeers.clear(),this.components.events.removeEventListener("peer:identify",this.handleDiscoveredPeer))}get[Ux](){return!0}get[Symbol.toStringTag](){return"@waku/peer-exchange"}startRecurringQueries=async e=>{const t=e.toString(),{queryInterval:n=_S,maxRetries:r=ES}=this.options;xS.info(`Querying peer: ${t} (attempt ${this.queryAttempts.get(t)??1})`),await this.query(e);const i=this.queryAttempts.get(t)??1;i>r?this.abortQueriesForPeer(t):setTimeout(()=>{this.queryAttempts.set(t,i+1),this.startRecurringQueries(e).catch(e=>{xS.error("Error in startRecurringQueries: "+e)})},n*i)};async query(e){const{error:t,peerInfos:n}=await this.peerExchange.query({numPeers:10,peerId:e});if(t)return xS.error("Peer exchange query failed",t),{error:t,peerInfos:null};for(const e of n){const{ENR:t}=e;if(!t){xS.warn("No ENR in peerInfo object, skipping");continue}const{peerId:n,peerInfo:r,shardInfo:i}=t;if(!n||!r)continue;if(await this.components.peerStore.has(n)){const{hasMultiaddrDiff:e,hasShardDiff:t}=await this.checkPeerInfoDiff(r,i);if(e||t){xS.info(`Peer ${n.toString()} has updated multiaddrs or shardInfo, updating`),e&&(xS.info(`Peer ${n.toString()} has updated multiaddrs, updating`),await this.components.peerStore.patch(n,{multiaddrs:r.multiaddrs})),t&&i&&(xS.info(`Peer ${n.toString()} has updated shardInfo, updating`),await this.components.peerStore.merge(n,{metadata:{shardInfo:Wn(i)}}),this.dispatchEvent(new CustomEvent("peer",{detail:{id:n,multiaddrs:r.multiaddrs}})));continue}}await this.components.peerStore.save(n,{tags:{[SS]:{value:this.options.tagValue??50,ttl:this.options.tagTTL??1e8}},...i&&{metadata:{shardInfo:Wn(i)}},...r.multiaddrs&&{multiaddrs:r.multiaddrs}}),xS.info("Discovered peer: "+n.toString()),this.dispatchEvent(new CustomEvent("peer",{detail:{id:n,multiaddrs:r.multiaddrs}}))}return{error:null,peerInfos:n}}abortQueriesForPeer(e){xS.info("Aborting queries for peer: "+e),this.queryingPeers.delete(e),this.queryAttempts.delete(e)}async checkPeerInfoDiff(e,t){const{id:n}=e,r=await this.components.peerStore.get(n),i=r.addresses.map(e=>e.multiaddr.toString()),s=e.multiaddrs.map(e=>e.toString()),o=i.some(e=>!s.includes(e));let a=!1;const l=r.metadata.get("shardInfo");if(l){const e=Gn(l);(e||t)&&(a=e.clusterId!==t?.clusterId||e.shards.some(e=>!t?.shards.includes(e)))}return{hasMultiaddrDiff:o,hasShardDiff:a}}}function AS(e){return t=>new MS(t,e)}const CS=new ir("peer-exchange-discovery"),TS=Sn.LOCAL;class IS extends Hi{components;options;isStarted;peers=[];constructor(e,t){super(),this.components=e,this.options=t,this.isStarted=!1,this.peers=this.getPeersFromLocalStorage()}get[Symbol.toStringTag](){return"@waku/local-peer-cache-discovery"}async start(){if(!this.isStarted){CS.info("Starting Local Storage Discovery"),this.components.events.addEventListener("peer:identify",this.handleNewPeers);for(const{id:e,address:t}of this.peers){const n=Uh(e);await this.components.peerStore.has(n)||(await this.components.peerStore.save(n,{multiaddrs:[Us(t)],tags:{[this.options?.tagName??TS]:{value:this.options?.tagValue??50,ttl:this.options?.tagTTL??1e8}}}),this.dispatchEvent(new CustomEvent("peer",{detail:{id:n,multiaddrs:[Us(t)]}})))}CS.info(`Discovered ${this.peers.length} peers`),this.isStarted=!0}}stop(){this.isStarted&&(CS.info("Stopping Local Storage Discovery"),this.components.events.removeEventListener("peer:identify",this.handleNewPeers),this.isStarted=!1,this.savePeersToLocalStorage())}handleNewPeers=e=>{const{peerId:t,listenAddrs:n}=e.detail,r=function(e){const t=e.find(e=>e.toString().includes("ws")||e.toString().includes("wss"));if(!t)throw Error("No ws multiaddr found in the given addresses");return t}(n),i=this.getPeersFromLocalStorage(),s=i.findIndex(e=>e.id===t.toString());s>=0?i[s].address=r.toString():i.push({id:t.toString(),address:r.toString()}),this.peers=i,this.savePeersToLocalStorage()};getPeersFromLocalStorage(){try{const e=localStorage.getItem("waku:peers");if(!e)return[];return JSON.parse(e).filter(LS)}catch(e){return CS.error("Error parsing peers from local storage:",e),[]}}savePeersToLocalStorage(){try{localStorage.setItem("waku:peers",JSON.stringify(this.peers))}catch(e){CS.error("Error saving peers to local storage:",e)}}}function LS(e){return e&&"object"==typeof e&&"string"==typeof e.id&&"string"==typeof e.address}const PS=new ir("sdk:create");async function RS(e,t,n){!t?.hideWebSocketInfo&&zx();const r=e?{metadata:Xs(e)}:{};return async function(e={}){e.privateKey??=await Sh();const t=new Bx({...await my(e),peerId:(n=e.privateKey,Hh(n.publicKey))});var n;return!1!==e.start&&await t.start(),t}({transports:[Ng({filter:!1===t?.filterMultiaddrs||zx()?Rg:Dg})],streamMuxers:[Qm()],connectionEncrypters:[Lp()],...t,services:{identify:vm({agentVersion:n??"js-waku"}),ping:og({maxInboundStreams:t?.pingMaxInboundStreams??10}),...r,...t?.services}})}async function DS(e){const{networkConfig:t}=e,n=function(e){if((e=>"clusterId"in e&&"shards"in e&&!("contentTopics"in e))(e)){if(0===e.shards.length)throw Error("Invalid shards configuration: please provide at least one shard");return On(e)}if((e=>"contentTopics"in e)(e)){if(0===e.contentTopics.length)throw Error("Invalid content topics configuration: please provide at least one content topic");return e.contentTopics.map(t=>qn(t,e.clusterId))}throw Error("Unknown shard config. Please use ShardInfo or ContentTopicInfo")}(t??Tn);PS.info("Creating Waku node with pubsub topics",n);const r=e?.libp2p??{},i=r.peerDiscovery??[];var s;e?.defaultBootstrap&&i.push(...function(e){return[dS([Hx]),(e,t)=>new IS(e,t),AS(e)]}(n)),e?.bootstrapPeers&&i.push((s={list:e.bootstrapPeers},e=>new df(e,s))),r.peerDiscovery=i;return{libp2p:await RS(n,r,e?.userAgent),pubsubTopics:n}}const{floor:kS,random:NS}=Math,FS="Trystero",OS=(e,t)=>Array(e).fill().map(t),BS="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",zS=(e=>OS(e,()=>BS[kS(62*NS())]).join(""))(20),US=Promise.all.bind(Promise),HS="undefined"!=typeof window,{entries:qS,fromEntries:VS,keys:GS}=Object,WS=()=>{},jS=e=>Error(`${FS}: ${e}`),$S=new TextEncoder,KS=new TextDecoder,XS=e=>$S.encode(e),YS=e=>KS.decode(e),ZS=(...e)=>e.join("@"),JS=JSON.stringify,QS=JSON.parse,eM="AES-GCM",tM={},nM=async e=>tM[e]||=Array.from(await(async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,XS(t))))("SHA-1",e)).map(e=>e.toString(36)).join(""),rM=async(e,t)=>{const n=crypto.getRandomValues(new Uint8Array(16));return n.join(",")+"$"+(r=await crypto.subtle.encrypt({name:eM,iv:n},await e,XS(t)),btoa(String.fromCharCode.apply(null,new Uint8Array(r))));var r},iM=async(e,t)=>{const[n,r]=t.split("$");return YS(await crypto.subtle.decrypt({name:eM,iv:new Uint8Array(n.split(","))},await e,(e=>{const t=atob(e);return new Uint8Array(t.length).map((e,n)=>t.charCodeAt(n)).buffer})(r)))},sM="icegatheringstatechange",oM="offer";var aM=(e,{rtcConfig:t,rtcPolyfill:n,turnConfig:r})=>{const i=new(n||RTCPeerConnection)({iceServers:lM.concat(r||[]),...t}),s={};let o=!1,a=!1,l=null;const c=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>s.data?.(e.data),e.onopen=()=>s.connect?.(),e.onclose=()=>s.close?.(),e.onerror=e=>s.error?.(e)},h=e=>Promise.race([new Promise(t=>{const n=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(sM,n),t())};e.addEventListener(sM,n),n()}),new Promise(e=>setTimeout(e,5e3))]).then(()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(l=i.createDataChannel("data"),c(l)):i.ondatachannel=({channel:e})=>{l=e,c(e)},i.onnegotiationneeded=async()=>{try{o=!0,await i.setLocalDescription();const e=await h(i);s.signal?.(e)}catch(e){s.error?.(e)}finally{o=!1}},i.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(i.connectionState)&&s.close?.()},i.ontrack=e=>{s.track?.(e.track,e.streams[0]),s.stream?.(e.streams[0])},i.onremovestream=e=>s.stream?.(e.stream),e&&(i.canTrickleIceCandidates||i.onnegotiationneeded()),{created:Date.now(),connection:i,get channel(){return l},get isDead(){return"closed"===i.connectionState},async signal(t){if("open"!==l?.readyState||t.sdp?.includes("a=rtpmap"))try{if(t.type===oM){if(o||"stable"!==i.signalingState&&!a){if(e)return;await US([i.setLocalDescription({type:"rollback"}),i.setRemoteDescription(t)])}else await i.setRemoteDescription(t);await i.setLocalDescription();const n=await h(i);return s.signal?.(n),n}if("answer"===t.type){a=!0;try{await i.setRemoteDescription(t)}finally{a=!1}}}catch(e){s.error?.(e)}},sendData(e){return l.send(e)},destroy(){l?.close(),i.close(),o=!1,a=!1},setHandlers(e){return Object.assign(s,e)},offerPromise:e?new Promise(e=>s.signal=t=>{t.type===oM&&e(t)}):Promise.resolve(),addStream(e){return e.getTracks().forEach(t=>i.addTrack(t,e))},removeStream(e){return i.getSenders().filter(t=>e.getTracks().includes(t.track)).forEach(e=>i.removeTrack(e))},addTrack(e,t){return i.addTrack(e,t)},removeTrack(e){const t=i.getSenders().find(t=>t.track===e);t&&i.removeTrack(t)},replaceTrack(e,t){const n=i.getSenders().find(t=>t.track===e);if(n)return n.replaceTrack(t)}}};const lM=[...OS(3,(e,t)=>`stun:stun${t||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),cM=Object.getPrototypeOf(Uint8Array),hM=16369,uM=255,dM="bufferedamountlow",pM=e=>"@_"+e;var fM=(e,t,n)=>{const r={},i={},s={},o={},a={},l={},c={},h={onPeerJoin:WS,onPeerLeave:WS,onPeerStream:WS,onPeerTrack:WS},u=(e,t)=>(e?Array.isArray(e)?e:[e]:GS(r)).flatMap(e=>{const n=r[e];return n?t(e,n):(console.warn(`${FS}: no peer with id ${e} found`),[])}),d=e=>{r[e]&&(r[e].destroy(),delete r[e],delete o[e],delete a[e],h.onPeerLeave(e),t(e))},p=e=>{if(i[e])return s[e];if(!e)throw jS("action type argument is required");const t=XS(e);if(t.byteLength>12)throw jS(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const n=new Uint8Array(12);n.set(t);let o=0;return i[e]={onComplete:WS,onProgress:WS,setOnComplete(t){return i[e]={...i[e],onComplete:t}},setOnProgress(t){return i[e]={...i[e],onProgress:t}},async send(e,t,i,s){if(i&&"object"!=typeof i)throw jS("action meta argument must be an object");const a=typeof e;if("undefined"===a)throw jS("action data cannot be undefined");const l="string"!==a,c=e instanceof Blob,h=c||e instanceof ArrayBuffer||e instanceof cM;if(i&&!h)throw jS("action meta argument can only be used with binary data");const d=h?new Uint8Array(c?await e.arrayBuffer():e):XS(l?JS(e):e),p=i?XS(JS(i)):null,f=Math.ceil(d.byteLength/hM)+(i?1:0)||1,m=OS(f,(e,t)=>{const r=t===f-1,s=i&&0===t,a=new Uint8Array(15+(s?p.byteLength:r?d.byteLength-hM*(f-(i?2:1)):hM));return a.set(n),a.set([o],12),a.set([r|s<<1|h<<2|l<<3],13),a.set([Math.round((t+1)/f*uM)],14),a.set(i?s?p:d.subarray((t-1)*hM,t*hM):d.subarray(t*hM,(t+1)*hM),15),a});return o=o+1&uM,US(u(t,async(e,t)=>{const{channel:n}=t;let o=0;for(;o<f;){const a=m[o];if(n.bufferedAmount>n.bufferedAmountLowThreshold&&await new Promise(e=>{const t=()=>{n.removeEventListener(dM,t),e()};n.addEventListener(dM,t)}),!r[e])break;t.sendData(a),o++,s?.(a[14]/uM,e,i)}}))}},s[e]||=[i[e].send,i[e].setOnComplete,i[e].setOnProgress]},f=async()=>{await M(""),await new Promise(e=>setTimeout(e,99)),qS(r).forEach(([e,t])=>{t.destroy(),delete r[e]}),n()},[m,g]=p(pM("ping")),[y,b]=p(pM("pong")),[v,w]=p(pM("signal")),[x,_]=p(pM("stream")),[E,S]=p(pM("track")),[M,A]=p(pM("leave"));return e((e,t)=>{r[t]||(r[t]=e,e.setHandlers({data(e){return((e,t)=>{const n=new Uint8Array(t),r=YS(n.subarray(0,12)).replaceAll("\0",""),[s]=n.subarray(12,13),[a]=n.subarray(13,14),[l]=n.subarray(14,15),c=n.subarray(15),h=!!(1&a),u=!!(2&a),d=!!(4&a),p=!!(8&a);if(!i[r])return void console.warn(`${FS}: received message with unregistered type (${r})`);o[e]||={},o[e][r]||={};const f=o[e][r][s]||={chunks:[]};if(u?f.meta=QS(YS(c)):f.chunks.push(c),i[r].onProgress(l/uM,e,f.meta),!h)return;const m=new Uint8Array(f.chunks.reduce((e,t)=>e+t.byteLength,0));if(f.chunks.reduce((e,t)=>(m.set(t,e),e+t.byteLength),0),delete o[e][r][s],d)i[r].onComplete(m,e,f.meta);else{const t=YS(m);i[r].onComplete(p?QS(t):t,e)}})(t,e)},stream(e){h.onPeerStream(e,t,l[t]),delete l[t]},track(e,n){h.onPeerTrack(e,n,t,c[t]),delete c[t]},signal(e){return v(e,t)},close(){return d(t)},error(e){console.error(e),d(t)}}),h.onPeerJoin(t))}),g((e,t)=>y("",t)),b((e,t)=>{a[t]?.(),delete a[t]}),w((e,t)=>r[t]?.signal(e)),_((e,t)=>l[t]=e),S((e,t)=>c[t]=e),A((e,t)=>d(t)),HS&&addEventListener("beforeunload",f),{makeAction:p,leave:f,async ping(e){if(!e)throw jS("ping() must be called with target peer ID");const t=Date.now();return m("",e),await new Promise(t=>a[e]=t),Date.now()-t},getPeers(){return VS(qS(r).map(([e,t])=>[e,t.connection]))},addStream(e,t,n){return u(t,async(t,r)=>{n&&await x(n,t),r.addStream(e)})},removeStream(e,t){return u(t,(t,n)=>n.removeStream(e))},addTrack(e,t,n,r){return u(n,async(n,i)=>{r&&await E(r,n),i.addTrack(e,t)})},removeTrack(e,t){return u(t,(t,n)=>n.removeTrack(e))},replaceTrack(e,t,n,r){return u(n,async(n,i)=>{r&&await E(r,n),i.replaceTrack(e,t)})},onPeerJoin(e){return h.onPeerJoin=e},onPeerLeave(e){return h.onPeerLeave=e},onPeerStream(e){return h.onPeerStream=e},onPeerTrack(e){return h.onPeerTrack=e}}};const mM="/waku/2/default-waku/proto",gM=e=>`/${FS}/0/${e}/json`,yM=(e,t,n)=>e.lightPush.send(cr({pubsubTopic:mM,contentTopic:gM(t),ephemeral:!0}),{payload:XS(n)}),bM=(({init:e,subscribe:t,announce:n})=>{const r={};let i,s,o,a=!1;return(l,c,h)=>{const{appId:u}=l;if(r[u]?.[c])return r[u][c];const d={},p={},f=ZS(FS,u,c),m=nM(f),g=nM(ZS(f,zS)),y=(async(e,t,n)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},XS(`${e}:${t}:${n}`)),{name:eM},!1,["encrypt","decrypt"]))(l.password||"",u,c),b=e=>async t=>({type:t.type,sdp:await e(y,t.sdp)}),v=b(iM),w=b(rM),x=()=>aM(!0,l),_=(e,t,n)=>{p[t]?p[t]!==e&&e.destroy():(p[t]=e,L(e,t),d[t]?.forEach((e,t)=>{t!==n&&e.destroy()}),delete d[t])},E=(e,t)=>{p[t]===e&&delete p[t]},S=e=>(s.push(...OS(e,x)),US(s.splice(0,e).map(e=>e.offerPromise.then(w).then(t=>({peer:e,offer:t}))))),M=(e,t)=>h?.({error:`incorrect password (${l.password}) when decrypting ${t}`,appId:u,peerId:e,roomId:c}),A=e=>async(t,n,r)=>{const[i,s]=await US([m,g]);if(t!==i&&t!==s)return;const{peerId:o,offer:a,answer:c,peer:h}="string"==typeof n?QS(n):n;if(o!==zS&&!p[o])if(!o||a||c){if(a){const t=d[o]?.[e];if(t&&zS>o)return;const n=aM(!1,l);let i;n.setHandlers({connect(){return _(n,o,e)},close(){return E(n,o)}});try{i=await v(a)}catch{return void M(o,"offer")}if(n.isDead)return;const[s,c]=await US([nM(ZS(f,o)),n.signal(i)]);r(s,JS({peerId:zS,answer:await w(c)}))}else if(c){let t;try{t=await v(c)}catch(e){return void M(o,"answer")}if(h)h.setHandlers({connect(){return _(h,o,e)},close(){return E(h,o)}}),h.signal(t);else{const n=d[o]?.[e];n&&!n.isDead&&n.signal(t)}}}else{if(d[o]?.[e])return;const[[{peer:t,offer:n}],i]=await US([S(1),nM(ZS(f,o))]);d[o]||=[],d[o][e]=t,setTimeout(()=>((e,t)=>{if(p[e])return;const n=d[e]?.[t];n&&(delete d[e][t],n.destroy())})(o,e),.9*C[e]),t.setHandlers({connect(){return _(t,o,e)},close(){return E(t,o)}}),r(i,JS({peerId:zS,offer:n}))}};if(!l)throw jS("requires a config map as the first argument");if(!u&&!l.firebaseApp)throw jS("config map is missing appId field");if(!c)throw jS("roomId argument required");if(!a){const t=e(l);s=OS(20,x),i=Array.isArray(t)?t:[t],a=!0,o=setInterval(()=>s=s.filter(e=>{const t=Date.now()-e.created<57333;return t||e.destroy(),t}),59052.99)}const C=i.map(()=>5333),T=[],I=i.map(async(e,n)=>t(await e,await m,await g,A(n),S));US([m,g]).then(([e,t])=>{const r=async(i,s)=>{const o=await n(i,e,t);"number"==typeof o&&(C[s]=o),T[s]=setTimeout(()=>r(i,s),C[s])};I.forEach(async(e,t)=>{await e,r(await i[t],t)})});let L=WS;return r[u]||={},r[u][c]=fM(e=>L=e,e=>delete p[e],()=>{delete r[u][c],T.forEach(clearTimeout),I.forEach(async e=>(await e)()),clearInterval(o)})}})({init(e){return async function(e={}){const{libp2p:t,pubsubTopics:n}=await DS(e),r=new Uo(n,e,t,{store:!0,lightpush:!0,filter:!0});return!1!==e?.autoStart&&await r.start(),r}({defaultBootstrap:!1,pubsubTopics:[mM],bootstrapPeers:["/dns4/waku.myrandomdemos.online/tcp/8000/wss/p2p/16Uiu2HAmKfC2QUvMVyBsVjuEzdo1hVhRddZxo69YkBuXYvuZ83sc","/dns4/node-01.do-ams3.wakuv2.prod.status.im/tcp/8000/wss/p2p/16Uiu2HAmL5okWopX7NqZWBUKVqW8iUxCEmd5GMHLVPwCgzYzQv3e","/dns4/node-01.gc-us-central1-a.wakuv2.prod.statusim.net/tcp/8000/wss/p2p/16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA","/dns4/node-01.ac-cn-hongkong-c.wakuv2.prod.status.im/tcp/8000/wss/p2p/16Uiu2HAm4v86W3bmT1BiH6oSPzcsSr24iDQpSN5Qa992BCjjwgrD","/dns4/node-01.do-ams3.wakuv2.test.status.im/tcp/8000/wss/p2p/16Uiu2HAmPLe7Mzm8TsYUubgCAW1aJoeFScxrLj8ppHFivPo97bUZ"],libp2p:{peerDiscovery:[AS([mM])],hideWebSocketInfo:!0,...e.libp2pConfig}}).then(async e=>(await e.start(),await e.waitForPeers([_n.LightPush,_n.Filter]),e))},async subscribe(e,t,n,r){const i=await US([t,n].map(t=>e.filter.subscribe(ur(gM(t),mM),(t=>n=>{n.payload&&r(t,YS(n.payload),(t,n)=>yM(e,t,n))})(t))));return()=>i.forEach(e=>e())},announce(e,t){return yM(e,t,JS({peerId:zS}))}}),vM=document.querySelector("#canvas"),wM=document.querySelector("#roll-history"),xM=document.querySelector("#peer-count"),_M={},EM={},SM={},MM={};let AM=null,CM=null,TM=null,IM=null,LM=null,PM=null,RM=null;const DM={appId:"steel-sorcery-diceroom"};function kM(e,t,n){const r=void 0!==t&&void 0!==n?{x:t,y:n}:{x:.8*Math.random()+.1,y:.5*Math.random()+.4};confetti({particleCount:3,spread:100,startVelocity:45,scalar:3,gravity:.5,ticks:200,flat:!0,origin:r,shapes:["emoji"],shapeOptions:{emoji:{value:[e]}}})}function NM(e){IM&&IM(e)}function FM(e){RM&&RM(e)}function OM(e,t=!1){const n=document.createElement("div"),r=document.createElement("img"),i=document.createElement("p");return n.className="absolute -ml-[10px] -mt-[2px]",n.style.left=n.style.top="-99px",r.src="assets/images/hand.png",r.className="w-[34px] h-[46px]",r.style.imageRendering="pixelated",i.className="text-center text-sm font-bold px-2 py-1 rounded-lg shadow-lg "+(t?"bg-white/90 text-black":"bg-black/90 text-white"),i.innerText=_M[e]||e.slice(0,4),t||(i.style.borderLeft="3px solid "+(EM[e]||"#ffffff")),n.appendChild(r),n.appendChild(i),n.id="cursor-"+e,vM.appendChild(n),MM[e]=n,n}function BM([e,t],n){const r=MM[n];r&&"number"==typeof e&&"number"==typeof t&&(r.style.left=e*window.innerWidth+"px",r.style.top=t*window.innerHeight+"px")}function zM(){const e=Object.keys(AM.getPeers()).length;xM.textContent=0===e?"No peers connected":1===e?"1 peer connected":e+" peers connected"}function UM(e,t){const{results:n,total:r,timestamp:i}=e,s=_M[t]||t.slice(0,8),o=t===zS,a=document.createElement("div");a.className="bg-black/40 rounded-xl p-4 sm:p-6 lg:p-8 animate-[slideIn_0.3s_ease-out] "+(o?"ring-1 sm:ring-2 ring-white/30":"");const l=document.createElement("div");l.className="flex justify-between mb-4 sm:mb-6 text-xs sm:text-sm lg:text-base items-start";const c=document.createElement("div");c.className="flex items-center gap-2";const h=document.createElement("div");h.className="w-3 h-3 rounded-full flex-shrink-0",h.style.backgroundColor=EM[t]||"#ffffff";const u=document.createElement("span");u.className="font-bold text-base sm:text-lg lg:text-xl "+(o?"text-orange-400":"text-white"),u.textContent=s,c.appendChild(h),c.appendChild(u);const d=document.createElement("div");d.className="flex flex-col items-end gap-1 sm:gap-2";const p=document.createElement("span");p.className="text-gray-500 text-xs sm:text-sm lg:text-base",p.textContent=new Date(i).toLocaleTimeString();const f=document.createElement("div");f.className="text-lg sm:text-xl lg:text-2xl font-bold text-white",f.textContent="Total: "+r,d.appendChild(p),d.appendChild(f),l.appendChild(c),l.appendChild(d);const m=document.createElement("div");m.className="flex gap-1 sm:gap-1.5 flex-wrap",n.forEach(e=>{const t=document.createElement("span");t.className="min-w-[50px] sm:min-w-[55px] lg:min-w-[60px] h-[50px] sm:h-[55px] lg:h-[60px] px-3 sm:px-4 flex items-center justify-center text-xl sm:text-2xl font-bold rounded-lg shadow-[0_4px_6px_rgb(0_0_0/0.3)] relative border-2 sm:border-[3px] "+{4:"bg-dice-4 text-black border-black",6:"bg-dice-6 text-white border-black",8:"bg-dice-8 text-white border-black",10:"bg-dice-10 text-white border-black",12:"bg-dice-12 text-black border-black",20:"bg-dice-20 text-black border-black"}[e.sides],t.textContent=e.value;const n=document.createElement("span");n.className="absolute bottom-[2px] right-1 text-xs sm:text-sm lg:text-base text-black/40 font-normal",n.textContent="d"+e.sides,t.appendChild(n),m.appendChild(t)}),a.appendChild(l),a.appendChild(m),wM.insertBefore(a,wM.firstChild);for(;wM.children.length>20;)wM.removeChild(wM.lastChild)}class HM extends HTMLElement{connectedCallback(){this.attachEventListeners()}attachEventListeners(){this.querySelectorAll("button").forEach(e=>{e.addEventListener("click",()=>{const t=e.dataset.emoji;this.triggerEmojiConfetti(t),function(e){PM&&PM(e)}(t)})})}triggerEmojiConfetti(e){const t=this.querySelector(`[data-emoji="${e}"]`);if(t){const n=t.getBoundingClientRect();kM(e,(n.left+n.width/2)/window.innerWidth,(n.top+n.height/2)/window.innerHeight)}}}customElements.define("emoji-buttons",HM);const qM=[],VM={2:"bg-dice-2 text-white",4:"bg-dice-4 text-black",6:"bg-dice-6 text-white",8:"bg-dice-8 text-white",10:"bg-dice-10 text-white",12:"bg-dice-12 text-black",20:"bg-dice-20 text-black"};class GM extends HTMLElement{connectedCallback(){this.dicePoolEl=this.querySelector("#dice-pool"),this.rollPoolBtn=this.querySelector("#roll-pool-btn"),this.attachEventListeners()}modifyPool(e,...t){e(...t),this.renderPool(),this.updateRollButton()}addDieToPool(e){this.modifyPool(()=>qM.push({id:Date.now()+Math.random(),sides:e}))}removeDieFromPool(e){this.modifyPool(()=>{const t=qM.findIndex(t=>t.id===e);-1!==t&&qM.splice(t,1)})}clearPool(){this.modifyPool(()=>qM.length=0)}createDieElement(e){const t=document.createElement("button");return t.className="w-[50px] h-[50px] sm:w-[60px] sm:h-[60px] lg:w-[70px] lg:h-[70px] text-base sm:text-lg font-bold border-2 sm:border-[3px] border-black rounded-lg sm:rounded-xl cursor-pointer transition-all shadow-[0_3px_6px_rgb(0_0_0/0.3)] hover:scale-110 hover:shadow-[0_5px_10px_rgb(255_255_255/0.3)] hover:border-white "+VM[e.sides],t.textContent="d"+e.sides,t.addEventListener("click",()=>this.removeDieFromPool(e.id)),t}renderPool(){if(0===qM.length)return this.dicePoolEl.innerHTML='<div class="w-full text-center text-gray-500 text-lg p-4 italic">Pool is empty. Click dice above to add them.</div>',void this.updatePoolSummary();this.dicePoolEl.innerHTML="",qM.forEach(e=>this.dicePoolEl.appendChild(this.createDieElement(e))),this.updatePoolSummary()}updatePoolSummary(){const e=document.querySelector("#pool-summary");if(0===qM.length)return void(e.textContent="");const t=qM.reduce((e,t)=>(e[t.sides]=(e[t.sides]||0)+1,e),{});e.textContent=Object.keys(t).sort((e,t)=>e-t).map(e=>`${t[e]}d${e}`).join(", ")}updateRollButton(){this.rollPoolBtn.disabled=0===qM.length,this.rollPoolBtn.textContent=0===qM.length?"Roll Pool":`Roll ${qM.length} ${1===qM.length?"Die":"Dice"}`}attachEventListeners(){this.querySelectorAll(".dice-type-btn").forEach(e=>{e.addEventListener("click",()=>this.addDieToPool(parseInt(e.dataset.sides,10))),e.addEventListener("contextmenu",t=>{t.preventDefault(),this.clearPool(),this.addDieToPool(parseInt(e.dataset.sides,10)),setTimeout(()=>qM.length>0&&this.handleRollPool(),50)})}),this.rollPoolBtn&&this.rollPoolBtn.addEventListener("click",()=>this.handleRollPool())}rollDie(e){return Math.floor(Math.random()*e.sides)+1}async handleRollPool(){if(0===qM.length)return;this.rollPoolBtn.disabled=!0,this.rollPoolBtn.textContent="Rolling...";const e=[...qM];this.clearPool();const t=e.map(e=>({sides:e.sides,value:this.rollDie(e)})),n=t.reduce((e,t)=>e+t.value,0),r={peerId:zS,dice:e.map(e=>e.sides),results:t,total:n,timestamp:Date.now()};!function(e){CM&&CM(e)}(r);const i=document.querySelector("dice-box");await i.roll(r,EM[zS]),UM(r,zS),this.rollPoolBtn.disabled=!1,this.updateRollButton()}}customElements.define("dice-pool",GM);class WM extends HTMLElement{constructor(){super(),this.myColor=localStorage.getItem("playerColor")||"#89CFF0",this.myLabelColor=localStorage.getItem("labelColor")||"#ffffff",this.myMaterial=localStorage.getItem("material")||"glass",this.myTexture=localStorage.getItem("texture")||"astral"}async connectedCallback(){await this.loadTextures(),this.attachEventListeners(),this.updateUIValues()}async loadTextures(){try{const e=await fetch("./textures.json"),t=await e.json(),n=this.querySelector("#texture-select");n.innerHTML='<option value="">None (Solid)</option>',t.forEach(e=>{const t=document.createElement("option");t.value=e,t.textContent=e.charAt(0).toUpperCase()+e.slice(1).replace(/[.-]/g," "),n.appendChild(t)}),n.value=this.myTexture}catch(e){console.error("Failed to load textures:",e)}}updateUIValues(){this.querySelector("#color-picker").value=this.myColor,this.querySelector("#label-color-picker").value=this.myLabelColor,this.querySelector("#material-select").value=this.myMaterial}attachEventListeners(){const e=this.querySelector("dialog"),t=document.querySelector("#dice-settings-btn"),n=this.querySelector("#close-dialog-btn");t&&t.addEventListener("click",()=>e.showModal()),n&&n.addEventListener("click",()=>e.close()),this.querySelector("#color-picker").addEventListener("input",e=>{this.myColor=e.target.value,localStorage.setItem("playerColor",this.myColor),this.dispatchEvent(new CustomEvent("color-change",{detail:{color:this.myColor},bubbles:!0}))}),this.querySelector("#label-color-picker").addEventListener("change",e=>{this.myLabelColor=e.target.value,localStorage.setItem("labelColor",this.myLabelColor),this.dispatchEvent(new CustomEvent("label-color-change",{detail:{labelColor:this.myLabelColor},bubbles:!0}))}),this.querySelector("#material-select").addEventListener("change",e=>{this.myMaterial=e.target.value,localStorage.setItem("material",this.myMaterial),this.dispatchEvent(new CustomEvent("material-change",{detail:{material:this.myMaterial},bubbles:!0}))}),this.querySelector("#texture-select").addEventListener("change",e=>{this.myTexture=e.target.value,localStorage.setItem("texture",this.myTexture),this.dispatchEvent(new CustomEvent("texture-change",{detail:{texture:this.myTexture},bubbles:!0}))})}getSettings(){return{color:this.myColor,labelColor:this.myLabelColor,material:this.myMaterial,texture:this.myTexture}}}customElements.define("dice-settings",WM);var jM=Object.defineProperty;const $M="143",KM="srgb",XM="srgb-linear",YM="300 es";class ZM{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;const n=this._listeners[e];if(void 0!==n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const n=t.slice(0);for(let t=0,r=n.length;t<r;t++)n[t].call(this,e);e.target=null}}}const JM=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],QM=Math.PI/180,eA=180/Math.PI;function tA(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(JM[255&e]+JM[e>>8&255]+JM[e>>16&255]+JM[e>>24&255]+"-"+JM[255&t]+JM[t>>8&255]+"-"+JM[t>>16&15|64]+JM[t>>24&255]+"-"+JM[63&n|128]+JM[n>>8&255]+"-"+JM[n>>16&255]+JM[n>>24&255]+JM[255&r]+JM[r>>8&255]+JM[r>>16&255]+JM[r>>24&255]).toLowerCase()}function nA(e,t,n){return Math.max(t,Math.min(n,e))}function rA(e,t,n){return(1-n)*e+n*t}function iA(e){return!(e&e-1)&&0!==e}function sA(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}class oA{constructor(e=0,t=0){oA.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x-e.x,s=this.y-e.y;return this.x=i*n-s*r+e.x,this.y=i*r+s*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class aA{constructor(){aA.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(e,t,n,r,i,s,o,a,l){const c=this.elements;return c[0]=e,c[1]=r,c[2]=o,c[3]=t,c[4]=i,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],y=r[1],b=r[4],v=r[7],w=r[2],x=r[5],_=r[8];return i[0]=s*f+o*y+a*w,i[3]=s*m+o*b+a*x,i[6]=s*g+o*v+a*_,i[1]=l*f+c*y+h*w,i[4]=l*m+c*b+h*x,i[7]=l*g+c*v+h*_,i[2]=u*f+d*y+p*w,i[5]=u*m+d*b+p*x,i[8]=u*g+d*v+p*_,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],a=e[6],l=e[7],c=e[8];return t*s*c-t*o*l-n*i*c+n*o*a+r*i*l-r*s*a}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],a=e[6],l=e[7],c=e[8],h=c*s-o*l,u=o*a-c*i,d=l*i-s*a,p=t*h+n*u+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return e[0]=h*f,e[1]=(r*l-c*n)*f,e[2]=(o*n-r*s)*f,e[3]=u*f,e[4]=(c*t-r*a)*f,e[5]=(r*i-o*t)*f,e[6]=d*f,e[7]=(n*a-l*t)*f,e[8]=(s*t-n*i)*f,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,i,s,o){const a=Math.cos(i),l=Math.sin(i);return this.set(n*a,n*l,-n*(a*s+l*o)+s+e,-r*l,r*a,-r*(-l*s+a*o)+o+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,i=r[0],s=r[3],o=r[6],a=r[1],l=r[4],c=r[7];return r[0]=t*i+n*a,r[3]=t*s+n*l,r[6]=t*o+n*c,r[1]=-n*i+t*a,r[4]=-n*s+t*l,r[7]=-n*o+t*c,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}function lA(e){for(let t=e.length-1;t>=0;--t)if(e[t]>65535)return!0;return!1}function cA(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function hA(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function uA(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}const dA={[KM]:{[XM]:hA},[XM]:{[KM]:uA}},pA={legacyMode:!0,get workingColorSpace(){return XM},set workingColorSpace(e){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert(e,t,n){if(this.legacyMode||t===n||!t||!n)return e;if(dA[t]&&void 0!==dA[t][n]){const r=dA[t][n];return e.r=r(e.r),e.g=r(e.g),e.b=r(e.b),e}throw Error("Unsupported color space conversion.")},fromWorkingColorSpace(e,t){return this.convert(e,this.workingColorSpace,t)},toWorkingColorSpace(e,t){return this.convert(e,t,this.workingColorSpace)}},fA={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},mA={r:0,g:0,b:0},gA={h:0,s:0,l:0},yA={h:0,s:0,l:0};function bA(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function vA(e,t){return t.r=e.r,t.g=e.g,t.b=e.b,t}class wA{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=KM){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,pA.toWorkingColorSpace(this,t),this}setRGB(e,t,n,r=XM){return this.r=e,this.g=t,this.b=n,pA.toWorkingColorSpace(this,r),this}setHSL(e,t,n,r=XM){if(e=function(e,t){return(e%t+t)%t}(e,1),t=nA(t,0,1),n=nA(n,0,1),0===t)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,i=2*n-r;this.r=bA(i,r,e+1/3),this.g=bA(i,r,e),this.b=bA(i,r,e-1/3)}return pA.toWorkingColorSpace(this,r),this}setStyle(e,t=KM){function n(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const i=r[1],s=r[2];switch(i){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,pA.toWorkingColorSpace(this,t),n(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,pA.toWorkingColorSpace(this,t),n(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const r=parseFloat(e[1])/360,i=parseInt(e[2],10)/100,s=parseInt(e[3],10)/100;return n(e[4]),this.setHSL(r,i,s,t)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=r[1],n=e.length;if(3===n)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,pA.toWorkingColorSpace(this,t),this;if(6===n)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,pA.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=KM){const n=fA[e.toLowerCase()];return void 0!==n?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=hA(e.r),this.g=hA(e.g),this.b=hA(e.b),this}copyLinearToSRGB(e){return this.r=uA(e.r),this.g=uA(e.g),this.b=uA(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=KM){return pA.fromWorkingColorSpace(vA(this,mA),e),nA(255*mA.r,0,255)<<16^nA(255*mA.g,0,255)<<8^nA(255*mA.b,0,255)}getHexString(e=KM){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=XM){pA.fromWorkingColorSpace(vA(this,mA),t);const n=mA.r,r=mA.g,i=mA.b,s=Math.max(n,r,i),o=Math.min(n,r,i);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const e=s-o;switch(l=c<=.5?e/(s+o):e/(2-s-o),s){case n:a=(r-i)/e+(r<i?6:0);break;case r:a=(i-n)/e+2;break;case i:a=(n-r)/e+4}a/=6}return e.h=a,e.s=l,e.l=c,e}getRGB(e,t=XM){return pA.fromWorkingColorSpace(vA(this,mA),t),e.r=mA.r,e.g=mA.g,e.b=mA.b,e}getStyle(e=KM){return pA.fromWorkingColorSpace(vA(this,mA),e),e!==KM?`color(${e} ${mA.r} ${mA.g} ${mA.b})`:`rgb(${255*mA.r|0},${255*mA.g|0},${255*mA.b|0})`}offsetHSL(e,t,n){return this.getHSL(gA),gA.h+=e,gA.s+=t,gA.l+=n,this.setHSL(gA.h,gA.s,gA.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(gA),e.getHSL(yA);const n=rA(gA.h,yA.h,t),r=rA(gA.s,yA.s,t),i=rA(gA.l,yA.l,t);return this.setHSL(n,r,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let xA;wA.NAMES=fA;class _A{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===xA&&(xA=cA("canvas")),xA.width=e.width,xA.height=e.height;const n=xA.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=xA}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=cA("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const r=n.getImageData(0,0,e.width,e.height),i=r.data;for(let e=0;e<i.length;e++)i[e]=255*hA(i[e]/255);return n.putImageData(r,0,0),t}if(e.data){const t=e.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(255*hA(t[e]/255)):t[e]=hA(t[e]);return{data:t,width:e.width,height:e.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class EA{constructor(e=null){this.isSource=!0,this.uuid=tA(),this.data=e,this.version=0}set needsUpdate(e){!0===e&&this.version++}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.images[this.uuid])return e.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let e;if(Array.isArray(r)){e=[];for(let t=0,n=r.length;t<n;t++)r[t].isDataTexture?e.push(SA(r[t].image)):e.push(SA(r[t]))}else e=SA(r);n.url=e}return t||(e.images[this.uuid]=n),n}}function SA(e){return typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap?_A.getDataURL(e):e.data?{data:Array.from(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let MA=0;class AA extends ZM{constructor(e=AA.DEFAULT_IMAGE,t=AA.DEFAULT_MAPPING,n=1001,r=1001,i=1006,s=1008,o=1023,a=1009,l=1,c=3e3){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:MA++}),this.uuid=tA(),this.name="",this.source=new EA(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new oA(0,0),this.repeat=new oA(1,1),this.center=new oA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new aA,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}}AA.DEFAULT_IMAGE=null,AA.DEFAULT_MAPPING=300;class CA{constructor(e=0,t=0,n=0,r=1){CA.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=this.w,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*r+s[12]*i,this.y=s[1]*t+s[5]*n+s[9]*r+s[13]*i,this.z=s[2]*t+s[6]*n+s[10]*r+s[14]*i,this.w=s[3]*t+s[7]*n+s[11]*r+s[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,i;const s=e.elements,o=s[0],a=s[4],l=s[8],c=s[1],h=s[5],u=s[9],d=s[2],p=s[6],f=s[10];if(Math.abs(a-c)<.01&&Math.abs(l-d)<.01&&Math.abs(u-p)<.01){if(Math.abs(a+c)<.1&&Math.abs(l+d)<.1&&Math.abs(u+p)<.1&&Math.abs(o+h+f-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const e=(o+1)/2,s=(h+1)/2,m=(f+1)/2,g=(a+c)/4,y=(l+d)/4,b=(u+p)/4;return e>s&&e>m?e<.01?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(e),r=g/n,i=y/n):s>m?s<.01?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(s),n=g/r,i=b/r):m<.01?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(m),n=y/i,r=b/i),this.set(n,r,i,t),this}let m=Math.sqrt((p-u)*(p-u)+(l-d)*(l-d)+(c-a)*(c-a));return Math.abs(m)<.001&&(m=1),this.x=(p-u)/m,this.y=(l-d)/m,this.z=(c-a)/m,this.w=Math.acos((o+h+f-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class TA extends ZM{constructor(e,t,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new CA(0,0,e,t),this.scissorTest=!1,this.viewport=new CA(0,0,e,t);const r={width:e,height:t,depth:1};this.texture=new AA(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:1006,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new EA(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class IA extends AA{constructor(e=null,t=1,n=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:r},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class LA extends AA{constructor(e=null,t=1,n=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:r},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class PA{constructor(e=0,t=0,n=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=r}static slerpFlat(e,t,n,r,i,s,o){let a=n[r+0],l=n[r+1],c=n[r+2],h=n[r+3];const u=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(0===o)return e[t+0]=a,e[t+1]=l,e[t+2]=c,void(e[t+3]=h);if(1===o)return e[t+0]=u,e[t+1]=d,e[t+2]=p,void(e[t+3]=f);if(h!==f||a!==u||l!==d||c!==p){let e=1-o;const t=a*u+l*d+c*p+h*f,n=t>=0?1:-1,r=1-t*t;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,t*n);e=Math.sin(e*s)/i,o=Math.sin(o*s)/i}const i=o*n;if(a=a*e+u*i,l=l*e+d*i,c=c*e+p*i,h=h*e+f*i,e===1-o){const e=1/Math.sqrt(a*a+l*l+c*c+h*h);a*=e,l*=e,c*=e,h*=e}}e[t]=a,e[t+1]=l,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,r,i,s){const o=n[r],a=n[r+1],l=n[r+2],c=n[r+3],h=i[s],u=i[s+1],d=i[s+2],p=i[s+3];return e[t]=o*p+c*h+a*d-l*u,e[t+1]=a*p+c*u+l*h-o*d,e[t+2]=l*p+c*d+o*u-a*h,e[t+3]=c*p-o*h-a*u-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,i=e._z,s=e._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(r/2),h=o(i/2),u=a(n/2),d=a(r/2),p=a(i/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],i=t[8],s=t[1],o=t[5],a=t[9],l=t[2],c=t[6],h=t[10],u=n+o+h;if(u>0){const e=.5/Math.sqrt(u+1);this._w=.25/e,this._x=(c-a)*e,this._y=(i-l)*e,this._z=(s-r)*e}else if(n>o&&n>h){const e=2*Math.sqrt(1+n-o-h);this._w=(c-a)/e,this._x=.25*e,this._y=(r+s)/e,this._z=(i+l)/e}else if(o>h){const e=2*Math.sqrt(1+o-n-h);this._w=(i-l)/e,this._x=(r+s)/e,this._y=.25*e,this._z=(a+c)/e}else{const e=2*Math.sqrt(1+h-n-o);this._w=(s-r)/e,this._x=(i+l)/e,this._y=(a+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(nA(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,i=e._z,s=e._w,o=t._x,a=t._y,l=t._z,c=t._w;return this._x=n*c+s*o+r*l-i*a,this._y=r*c+s*a+i*o-n*l,this._z=i*c+s*l+n*a-r*o,this._w=s*c-n*o-r*a-i*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,r=this._y,i=this._z,s=this._w;let o=s*e._w+n*e._x+r*e._y+i*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=s,this._x=n,this._y=r,this._z=i,this;const a=1-o*o;if(a<=Number.EPSILON){const e=1-t;return this._w=e*s+t*this._w,this._x=e*n+t*this._x,this._y=e*r+t*this._y,this._z=e*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),h=Math.sin((1-t)*c)/l,u=Math.sin(t*c)/l;return this._w=s*h+this._w*u,this._x=n*h+this._x*u,this._y=r*h+this._y*u,this._z=i*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(r),n*Math.sin(i),n*Math.cos(i),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class RA{constructor(e=0,t=0,n=0){RA.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(kA.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(kA.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6]*r,this.y=i[1]*t+i[4]*n+i[7]*r,this.z=i[2]*t+i[5]*n+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=e.elements,s=1/(i[3]*t+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*n+i[8]*r+i[12])*s,this.y=(i[1]*t+i[5]*n+i[9]*r+i[13])*s,this.z=(i[2]*t+i[6]*n+i[10]*r+i[14])*s,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z,a=e.w,l=a*t+s*r-o*n,c=a*n+o*t-i*r,h=a*r+i*n-s*t,u=-i*t-s*n-o*r;return this.x=l*a+u*-i+c*-o-h*-s,this.y=c*a+u*-s+h*-i-l*-o,this.z=h*a+u*-o+l*-s-c*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*r,this.y=i[1]*t+i[5]*n+i[9]*r,this.z=i[2]*t+i[6]*n+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,i=e.z,s=t.x,o=t.y,a=t.z;return this.x=r*a-i*o,this.y=i*s-n*a,this.z=n*o-r*s,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return DA.copy(this).projectOnVector(e),this.sub(DA)}reflect(e){return this.sub(DA.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(nA(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=2*(Math.random()-.5),t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const DA=new RA,kA=new PA;class NA{constructor(e=new RA(1/0,1/0,1/0),t=new RA(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,o=-1/0;for(let a=0,l=e.length;a<l;a+=3){const l=e[a],c=e[a+1],h=e[a+2];l<t&&(t=l),c<n&&(n=c),h<r&&(r=h),l>i&&(i=l),c>s&&(s=c),h>o&&(o=h)}return this.min.set(t,n,r),this.max.set(i,s,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,o=-1/0;for(let a=0,l=e.count;a<l;a++){const l=e.getX(a),c=e.getY(a),h=e.getZ(a);l<t&&(t=l),c<n&&(n=c),h<r&&(r=h),l>i&&(i=l),c>s&&(s=c),h>o&&(o=h)}return this.min.set(t,n,r),this.max.set(i,s,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=OA.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(void 0!==n)if(t&&null!=n.attributes&&void 0!==n.attributes.position){const t=n.attributes.position;for(let n=0,r=t.count;n<r;n++)OA.fromBufferAttribute(t,n).applyMatrix4(e.matrixWorld),this.expandByPoint(OA)}else null===n.boundingBox&&n.computeBoundingBox(),BA.copy(n.boundingBox),BA.applyMatrix4(e.matrixWorld),this.union(BA);const r=e.children;for(let e=0,n=r.length;e<n;e++)this.expandByObject(r[e],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,OA),OA.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(WA),jA.subVectors(this.max,WA),zA.subVectors(e.a,WA),UA.subVectors(e.b,WA),HA.subVectors(e.c,WA),qA.subVectors(UA,zA),VA.subVectors(HA,UA),GA.subVectors(zA,HA);let t=[0,-qA.z,qA.y,0,-VA.z,VA.y,0,-GA.z,GA.y,qA.z,0,-qA.x,VA.z,0,-VA.x,GA.z,0,-GA.x,-qA.y,qA.x,0,-VA.y,VA.x,0,-GA.y,GA.x,0];return!(!XA(t,zA,UA,HA,jA)||(t=[1,0,0,0,1,0,0,0,1],!XA(t,zA,UA,HA,jA)))&&($A.crossVectors(qA,VA),t=[$A.x,$A.y,$A.z],XA(t,zA,UA,HA,jA))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return OA.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(OA).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(FA[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),FA[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),FA[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),FA[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),FA[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),FA[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),FA[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),FA[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(FA)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const FA=[new RA,new RA,new RA,new RA,new RA,new RA,new RA,new RA],OA=new RA,BA=new NA,zA=new RA,UA=new RA,HA=new RA,qA=new RA,VA=new RA,GA=new RA,WA=new RA,jA=new RA,$A=new RA,KA=new RA;function XA(e,t,n,r,i){for(let s=0,o=e.length-3;s<=o;s+=3){KA.fromArray(e,s);const o=i.x*Math.abs(KA.x)+i.y*Math.abs(KA.y)+i.z*Math.abs(KA.z),a=t.dot(KA),l=n.dot(KA),c=r.dot(KA);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const YA=new NA,ZA=new RA,JA=new RA,QA=new RA;class eC{constructor(e=new RA,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):YA.setFromPoints(e).getCenter(n);let r=0;for(let t=0,i=e.length;t<i;t++)r=Math.max(r,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){QA.subVectors(e,this.center);const t=QA.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=.5*(e-this.radius);this.center.add(QA.multiplyScalar(n/e)),this.radius+=n}return this}union(e){return!0===this.center.equals(e.center)?JA.set(0,0,1).multiplyScalar(e.radius):JA.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(ZA.copy(e.center).add(JA)),this.expandByPoint(ZA.copy(e.center).sub(JA)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const tC=new RA,nC=new RA,rC=new RA,iC=new RA,sC=new RA,oC=new RA,aC=new RA;class lC{constructor(e=new RA,t=new RA(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,tC)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=tC.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(tC.copy(this.direction).multiplyScalar(t).add(this.origin),tC.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){nC.copy(e).add(t).multiplyScalar(.5),rC.copy(t).sub(e).normalize(),iC.copy(this.origin).sub(nC);const i=.5*e.distanceTo(t),s=-this.direction.dot(rC),o=iC.dot(this.direction),a=-iC.dot(rC),l=iC.lengthSq(),c=Math.abs(1-s*s);let h,u,d,p;if(c>0)if(h=s*a-o,u=s*o-a,p=i*c,h>=0)if(u>=-p)if(u<=p){const e=1/c;h*=e,u*=e,d=h*(h+s*u+2*o)+u*(s*h+u+2*a)+l}else u=i,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;else u=-i,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;else u<=-p?(h=Math.max(0,-(-s*i+o)),u=h>0?-i:Math.min(Math.max(-i,-a),i),d=-h*h+u*(u+2*a)+l):u<=p?(h=0,u=Math.min(Math.max(-i,-a),i),d=u*(u+2*a)+l):(h=Math.max(0,-(s*i+o)),u=h>0?i:Math.min(Math.max(-i,-a),i),d=-h*h+u*(u+2*a)+l);else u=s>0?-i:i,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(rC).multiplyScalar(u).add(nC),d}intersectSphere(e,t){tC.subVectors(e.center,this.origin);const n=tC.dot(this.direction),r=tC.dot(tC)-n*n,i=e.radius*e.radius;if(r>i)return null;const s=Math.sqrt(i-r),o=n-s,a=n+s;return o<0&&a<0?null:o<0?this.at(a,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,i,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(e.min.x-u.x)*l,r=(e.max.x-u.x)*l):(n=(e.max.x-u.x)*l,r=(e.min.x-u.x)*l),c>=0?(i=(e.min.y-u.y)*c,s=(e.max.y-u.y)*c):(i=(e.max.y-u.y)*c,s=(e.min.y-u.y)*c),n>s||i>r||((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),h>=0?(o=(e.min.z-u.z)*h,a=(e.max.z-u.z)*h):(o=(e.max.z-u.z)*h,a=(e.min.z-u.z)*h),n>a||o>r)||((o>n||n!=n)&&(n=o),(a<r||r!=r)&&(r=a),r<0)?null:this.at(n>=0?n:r,t)}intersectsBox(e){return null!==this.intersectBox(e,tC)}intersectTriangle(e,t,n,r,i){sC.subVectors(t,e),oC.subVectors(n,e),aC.crossVectors(sC,oC);let s,o=this.direction.dot(aC);if(o>0){if(r)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}iC.subVectors(this.origin,e);const a=s*this.direction.dot(oC.crossVectors(iC,oC));if(a<0)return null;const l=s*this.direction.dot(sC.cross(iC));if(l<0||a+l>o)return null;const c=-s*iC.dot(aC);return c<0?null:this.at(c/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class cC{constructor(){cC.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(e,t,n,r,i,s,o,a,l,c,h,u,d,p,f,m){const g=this.elements;return g[0]=e,g[4]=t,g[8]=n,g[12]=r,g[1]=i,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new cC).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/hC.setFromMatrixColumn(e,0).length(),i=1/hC.setFromMatrixColumn(e,1).length(),s=1/hC.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=0,t[8]=n[8]*s,t[9]=n[9]*s,t[10]=n[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,r=e.y,i=e.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(r),l=Math.sin(r),c=Math.cos(i),h=Math.sin(i);if("XYZ"===e.order){const e=s*c,n=s*h,r=o*c,i=o*h;t[0]=a*c,t[4]=-a*h,t[8]=l,t[1]=n+r*l,t[5]=e-i*l,t[9]=-o*a,t[2]=i-e*l,t[6]=r+n*l,t[10]=s*a}else if("YXZ"===e.order){const e=a*c,n=a*h,r=l*c,i=l*h;t[0]=e+i*o,t[4]=r*o-n,t[8]=s*l,t[1]=s*h,t[5]=s*c,t[9]=-o,t[2]=n*o-r,t[6]=i+e*o,t[10]=s*a}else if("ZXY"===e.order){const e=a*c,n=a*h,r=l*c,i=l*h;t[0]=e-i*o,t[4]=-s*h,t[8]=r+n*o,t[1]=n+r*o,t[5]=s*c,t[9]=i-e*o,t[2]=-s*l,t[6]=o,t[10]=s*a}else if("ZYX"===e.order){const e=s*c,n=s*h,r=o*c,i=o*h;t[0]=a*c,t[4]=r*l-n,t[8]=e*l+i,t[1]=a*h,t[5]=i*l+e,t[9]=n*l-r,t[2]=-l,t[6]=o*a,t[10]=s*a}else if("YZX"===e.order){const e=s*a,n=s*l,r=o*a,i=o*l;t[0]=a*c,t[4]=i-e*h,t[8]=r*h+n,t[1]=h,t[5]=s*c,t[9]=-o*c,t[2]=-l*c,t[6]=n*h+r,t[10]=e-i*h}else if("XZY"===e.order){const e=s*a,n=s*l,r=o*a,i=o*l;t[0]=a*c,t[4]=-h,t[8]=l*c,t[1]=e*h+i,t[5]=s*c,t[9]=n*h-r,t[2]=r*h-n,t[6]=o*c,t[10]=i*h+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(dC,e,pC)}lookAt(e,t,n){const r=this.elements;return gC.subVectors(e,t),0===gC.lengthSq()&&(gC.z=1),gC.normalize(),fC.crossVectors(n,gC),0===fC.lengthSq()&&(1===Math.abs(n.z)?gC.x+=1e-4:gC.z+=1e-4,gC.normalize(),fC.crossVectors(n,gC)),fC.normalize(),mC.crossVectors(gC,fC),r[0]=fC.x,r[4]=mC.x,r[8]=gC.x,r[1]=fC.y,r[5]=mC.y,r[9]=gC.y,r[2]=fC.z,r[6]=mC.z,r[10]=gC.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],b=n[7],v=n[11],w=n[15],x=r[0],_=r[4],E=r[8],S=r[12],M=r[1],A=r[5],C=r[9],T=r[13],I=r[2],L=r[6],P=r[10],R=r[14],D=r[3],k=r[7],N=r[11],F=r[15];return i[0]=s*x+o*M+a*I+l*D,i[4]=s*_+o*A+a*L+l*k,i[8]=s*E+o*C+a*P+l*N,i[12]=s*S+o*T+a*R+l*F,i[1]=c*x+h*M+u*I+d*D,i[5]=c*_+h*A+u*L+d*k,i[9]=c*E+h*C+u*P+d*N,i[13]=c*S+h*T+u*R+d*F,i[2]=p*x+f*M+m*I+g*D,i[6]=p*_+f*A+m*L+g*k,i[10]=p*E+f*C+m*P+g*N,i[14]=p*S+f*T+m*R+g*F,i[3]=y*x+b*M+v*I+w*D,i[7]=y*_+b*A+v*L+w*k,i[11]=y*E+b*C+v*P+w*N,i[15]=y*S+b*T+v*R+w*F,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],i=e[12],s=e[1],o=e[5],a=e[9],l=e[13],c=e[2],h=e[6],u=e[10],d=e[14];return e[3]*(+i*a*h-r*l*h-i*o*u+n*l*u+r*o*d-n*a*d)+e[7]*(+t*a*d-t*l*u+i*s*u-r*s*d+r*l*c-i*a*c)+e[11]*(+t*l*h-t*o*d-i*s*h+n*s*d+i*o*c-n*l*c)+e[15]*(-r*o*c-t*a*h+t*o*u+r*s*h-n*s*u+n*a*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],a=e[6],l=e[7],c=e[8],h=e[9],u=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],y=h*m*l-f*u*l+f*a*d-o*m*d-h*a*g+o*u*g,b=p*u*l-c*m*l-p*a*d+s*m*d+c*a*g-s*u*g,v=c*f*l-p*h*l+p*o*d-s*f*d-c*o*g+s*h*g,w=p*h*a-c*f*a-p*o*u+s*f*u+c*o*m-s*h*m,x=t*y+n*b+r*v+i*w;if(0===x)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/x;return e[0]=y*_,e[1]=(f*u*i-h*m*i-f*r*d+n*m*d+h*r*g-n*u*g)*_,e[2]=(o*m*i-f*a*i+f*r*l-n*m*l-o*r*g+n*a*g)*_,e[3]=(h*a*i-o*u*i-h*r*l+n*u*l+o*r*d-n*a*d)*_,e[4]=b*_,e[5]=(c*m*i-p*u*i+p*r*d-t*m*d-c*r*g+t*u*g)*_,e[6]=(p*a*i-s*m*i-p*r*l+t*m*l+s*r*g-t*a*g)*_,e[7]=(s*u*i-c*a*i+c*r*l-t*u*l-s*r*d+t*a*d)*_,e[8]=v*_,e[9]=(p*h*i-c*f*i-p*n*d+t*f*d+c*n*g-t*h*g)*_,e[10]=(s*f*i-p*o*i+p*n*l-t*f*l-s*n*g+t*o*g)*_,e[11]=(c*o*i-s*h*i-c*n*l+t*h*l+s*n*d-t*o*d)*_,e[12]=w*_,e[13]=(c*f*r-p*h*r+p*n*u-t*f*u-c*n*m+t*h*m)*_,e[14]=(p*o*r-s*f*r-p*n*a+t*f*a+s*n*m-t*o*m)*_,e[15]=(s*h*r-c*o*r+c*n*a-t*h*a-s*n*u+t*o*u)*_,this}scale(e){const t=this.elements,n=e.x,r=e.y,i=e.z;return t[0]*=n,t[4]*=r,t[8]*=i,t[1]*=n,t[5]*=r,t[9]*=i,t[2]*=n,t[6]*=r,t[10]*=i,t[3]*=n,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=1-n,s=e.x,o=e.y,a=e.z,l=i*s,c=i*o;return this.set(l*s+n,l*o-r*a,l*a+r*o,0,l*o+r*a,c*o+n,c*a-r*s,0,l*a-r*o,c*a+r*s,i*a*a+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,r,i,s){return this.set(1,n,i,0,e,1,s,0,t,r,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,i=t._x,s=t._y,o=t._z,a=t._w,l=i+i,c=s+s,h=o+o,u=i*l,d=i*c,p=i*h,f=s*c,m=s*h,g=o*h,y=a*l,b=a*c,v=a*h,w=n.x,x=n.y,_=n.z;return r[0]=(1-(f+g))*w,r[1]=(d+v)*w,r[2]=(p-b)*w,r[3]=0,r[4]=(d-v)*x,r[5]=(1-(u+g))*x,r[6]=(m+y)*x,r[7]=0,r[8]=(p+b)*_,r[9]=(m-y)*_,r[10]=(1-(u+f))*_,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let i=hC.set(r[0],r[1],r[2]).length();const s=hC.set(r[4],r[5],r[6]).length(),o=hC.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],uC.copy(this);const a=1/i,l=1/s,c=1/o;return uC.elements[0]*=a,uC.elements[1]*=a,uC.elements[2]*=a,uC.elements[4]*=l,uC.elements[5]*=l,uC.elements[6]*=l,uC.elements[8]*=c,uC.elements[9]*=c,uC.elements[10]*=c,t.setFromRotationMatrix(uC),n.x=i,n.y=s,n.z=o,this}makePerspective(e,t,n,r,i,s){const o=this.elements,a=2*i/(t-e),l=2*i/(n-r),c=(t+e)/(t-e),h=(n+r)/(n-r),u=-(s+i)/(s-i),d=-2*s*i/(s-i);return o[0]=a,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=l,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,r,i,s){const o=this.elements,a=1/(t-e),l=1/(n-r),c=1/(s-i),h=(t+e)*a,u=(n+r)*l,d=(s+i)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-u,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const hC=new RA,uC=new cC,dC=new RA(0,0,0),pC=new RA(1,1,1),fC=new RA,mC=new RA,gC=new RA,yC=new cC,bC=new PA;class vC{constructor(e=0,t=0,n=0,r=vC.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r=this._order){return this._x=e,this._y=t,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const r=e.elements,i=r[0],s=r[4],o=r[8],a=r[1],l=r[5],c=r[9],h=r[2],u=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(nA(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-nA(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(nA(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(a,i));break;case"ZYX":this._y=Math.asin(-nA(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(a,i)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(nA(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-nA(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(o,i)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!0===n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return yC.makeRotationFromQuaternion(e),this.setFromRotationMatrix(yC,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return bC.setFromEuler(this),this.setFromQuaternion(bC,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}vC.DefaultOrder="XYZ",vC.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class wC{constructor(){this.mask=1}set(e){this.mask=1<<e>>>0}enable(e){this.mask|=1<<e}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e}disable(e){this.mask&=~(1<<e)}disableAll(){this.mask=0}test(e){return 0!==(this.mask&e.mask)}isEnabled(e){return!!(this.mask&1<<e)}}let xC=0;const _C=new RA,EC=new PA,SC=new cC,MC=new RA,AC=new RA,CC=new RA,TC=new PA,IC=new RA(1,0,0),LC=new RA(0,1,0),PC=new RA(0,0,1),RC={type:"added"},DC={type:"removed"};class kC extends ZM{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:xC++}),this.uuid=tA(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=kC.DefaultUp.clone();const e=new RA,t=new vC,n=new PA,r=new RA(1,1,1);t._onChange(function(){n.setFromEuler(t,!1)}),n._onChange(function(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new cC},normalMatrix:{value:new aA}}),this.matrix=new cC,this.matrixWorld=new cC,this.matrixAutoUpdate=kC.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new wC,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return EC.setFromAxisAngle(e,t),this.quaternion.multiply(EC),this}rotateOnWorldAxis(e,t){return EC.setFromAxisAngle(e,t),this.quaternion.premultiply(EC),this}rotateX(e){return this.rotateOnAxis(IC,e)}rotateY(e){return this.rotateOnAxis(LC,e)}rotateZ(e){return this.rotateOnAxis(PC,e)}translateOnAxis(e,t){return _C.copy(e).applyQuaternion(this.quaternion),this.position.add(_C.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(IC,e)}translateY(e){return this.translateOnAxis(LC,e)}translateZ(e){return this.translateOnAxis(PC,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(SC.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?MC.copy(e):MC.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),AC.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?SC.lookAt(AC,MC,this.up):SC.lookAt(MC,AC,this.up),this.quaternion.setFromRotationMatrix(SC),r&&(SC.extractRotation(r.matrixWorld),EC.setFromRotationMatrix(SC),this.quaternion.premultiply(EC.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(RC)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(DC)),this}removeFromParent(){const e=this.parent;return null!==e&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(DC)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),SC.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),SC.multiply(e.parent.matrixWorld)),e.applyMatrix4(SC),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(e,t);if(void 0!==r)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(AC,e,CC),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(AC,TC,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const r=n[t];i(e.shapes,r)}else i(e.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,r=this.material.length;n<r;n++)t.push(i(e.materials,this.material[n]));r.material=t}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let t=0;t<this.children.length;t++)r.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];r.animations.push(i(e.animations,n))}}if(t){const t=s(e.geometries),r=s(e.materials),i=s(e.textures),o=s(e.images),a=s(e.shapes),l=s(e.skeletons),c=s(e.animations),h=s(e.nodes);t.length>0&&(n.geometries=t),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),h.length>0&&(n.nodes=h)}return n.object=r,n;function s(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}}kC.DefaultUp=new RA(0,1,0),kC.DefaultMatrixAutoUpdate=!0;const NC=new RA,FC=new RA,OC=new RA,BC=new RA,zC=new RA,UC=new RA,HC=new RA,qC=new RA,VC=new RA,GC=new RA;class WC{constructor(e=new RA,t=new RA,n=new RA){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,r){r.subVectors(n,t),NC.subVectors(e,t),r.cross(NC);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,n,r,i){NC.subVectors(r,t),FC.subVectors(n,t),OC.subVectors(e,t);const s=NC.dot(NC),o=NC.dot(FC),a=NC.dot(OC),l=FC.dot(FC),c=FC.dot(OC),h=s*l-o*o;if(0===h)return i.set(-2,-1,-1);const u=1/h,d=(l*a-o*c)*u,p=(s*c-o*a)*u;return i.set(1-d-p,p,d)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,BC),BC.x>=0&&BC.y>=0&&BC.x+BC.y<=1}static getUV(e,t,n,r,i,s,o,a){return this.getBarycoord(e,t,n,r,BC),a.set(0,0),a.addScaledVector(i,BC.x),a.addScaledVector(s,BC.y),a.addScaledVector(o,BC.z),a}static isFrontFacing(e,t,n,r){return NC.subVectors(n,t),FC.subVectors(e,t),NC.cross(FC).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,n,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,r),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return NC.subVectors(this.c,this.b),FC.subVectors(this.a,this.b),.5*NC.cross(FC).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return WC.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return WC.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,i){return WC.getUV(e,this.a,this.b,this.c,t,n,r,i)}containsPoint(e){return WC.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return WC.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,r=this.b,i=this.c;let s,o;zC.subVectors(r,n),UC.subVectors(i,n),qC.subVectors(e,n);const a=zC.dot(qC),l=UC.dot(qC);if(a<=0&&l<=0)return t.copy(n);VC.subVectors(e,r);const c=zC.dot(VC),h=UC.dot(VC);if(c>=0&&h<=c)return t.copy(r);const u=a*h-c*l;if(u<=0&&a>=0&&c<=0)return s=a/(a-c),t.copy(n).addScaledVector(zC,s);GC.subVectors(e,i);const d=zC.dot(GC),p=UC.dot(GC);if(p>=0&&d<=p)return t.copy(i);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),t.copy(n).addScaledVector(UC,o);const m=c*p-d*h;if(m<=0&&h-c>=0&&d-p>=0)return HC.subVectors(i,r),o=(h-c)/(h-c+(d-p)),t.copy(r).addScaledVector(HC,o);const g=1/(m+f+u);return s=f*g,o=u*g,t.copy(n).addScaledVector(zC,s).addScaledVector(UC,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let jC=0;class $C extends ZM{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:jC++}),this.uuid=tA(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const r=this[t];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=r(e.textures),i=r(e.images);t.length>0&&(n.textures=t),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=Array(e);for(let r=0;r!==e;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}}class KC extends $C{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new wA(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const XC=new RA,YC=new oA;class ZC{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new wA),t[n++]=i.r,t[n++]=i.g,t[n++]=i.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new oA),t[n++]=i.x,t[n++]=i.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new RA),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new CA),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z,t[n++]=i.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)YC.fromBufferAttribute(this,t),YC.applyMatrix3(e),this.setXY(t,YC.x,YC.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)XC.fromBufferAttribute(this,t),XC.applyMatrix3(e),this.setXYZ(t,XC.x,XC.y,XC.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)XC.fromBufferAttribute(this,t),XC.applyMatrix4(e),this.setXYZ(t,XC.x,XC.y,XC.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)XC.fromBufferAttribute(this,t),XC.applyNormalMatrix(e),this.setXYZ(t,XC.x,XC.y,XC.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)XC.fromBufferAttribute(this,t),XC.transformDirection(e),this.setXYZ(t,XC.x,XC.y,XC.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this}setXYZW(e,t,n,r,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),35044!==this.usage&&(e.usage=this.usage),(0!==this.updateRange.offset||-1!==this.updateRange.count)&&(e.updateRange=this.updateRange),e}}class JC extends ZC{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class QC extends ZC{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class eT extends ZC{constructor(e,t,n){super(new Float32Array(e),t,n)}}let tT=0;const nT=new cC,rT=new kC,iT=new RA,sT=new NA,oT=new NA,aT=new RA;class lT extends ZM{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:tT++}),this.uuid=tA(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return this.index=Array.isArray(e)?new(lA(e)?QC:JC)(e,1):e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new aA).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(e),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return nT.makeRotationFromQuaternion(e),this.applyMatrix4(nT),this}rotateX(e){return nT.makeRotationX(e),this.applyMatrix4(nT),this}rotateY(e){return nT.makeRotationY(e),this.applyMatrix4(nT),this}rotateZ(e){return nT.makeRotationZ(e),this.applyMatrix4(nT),this}translate(e,t,n){return nT.makeTranslation(e,t,n),this.applyMatrix4(nT),this}scale(e,t,n){return nT.makeScale(e,t,n),this.applyMatrix4(nT),this}lookAt(e){return rT.lookAt(e),rT.updateMatrix(),this.applyMatrix4(rT.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(iT).negate(),this.translate(iT.x,iT.y,iT.z),this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new eT(t,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new NA);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new RA(-1/0,-1/0,-1/0),new RA(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];sT.setFromBufferAttribute(n),this.morphTargetsRelative?(aT.addVectors(this.boundingBox.min,sT.min),this.boundingBox.expandByPoint(aT),aT.addVectors(this.boundingBox.max,sT.max),this.boundingBox.expandByPoint(aT)):(this.boundingBox.expandByPoint(sT.min),this.boundingBox.expandByPoint(sT.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new eC);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new RA,1/0);if(e){const n=this.boundingSphere.center;if(sT.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];oT.setFromBufferAttribute(n),this.morphTargetsRelative?(aT.addVectors(sT.min,oT.min),sT.expandByPoint(aT),aT.addVectors(sT.max,oT.max),sT.expandByPoint(aT)):(sT.expandByPoint(oT.min),sT.expandByPoint(oT.max))}sT.getCenter(n);let r=0;for(let t=0,i=e.count;t<i;t++)aT.fromBufferAttribute(e,t),r=Math.max(r,n.distanceToSquared(aT));if(t)for(let i=0,s=t.length;i<s;i++){const s=t[i],o=this.morphTargetsRelative;for(let t=0,i=s.count;t<i;t++)aT.fromBufferAttribute(s,t),o&&(iT.fromBufferAttribute(e,t),aT.add(iT)),r=Math.max(r,n.distanceToSquared(aT))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,r=t.position.array,i=t.normal.array,s=t.uv.array,o=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new ZC(new Float32Array(4*o),4));const a=this.getAttribute("tangent").array,l=[],c=[];for(let e=0;e<o;e++)l[e]=new RA,c[e]=new RA;const h=new RA,u=new RA,d=new RA,p=new oA,f=new oA,m=new oA,g=new RA,y=new RA;function b(e,t,n){h.fromArray(r,3*e),u.fromArray(r,3*t),d.fromArray(r,3*n),p.fromArray(s,2*e),f.fromArray(s,2*t),m.fromArray(s,2*n),u.sub(h),d.sub(h),f.sub(p),m.sub(p);const i=1/(f.x*m.y-m.x*f.y);!isFinite(i)||(g.copy(u).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i),y.copy(d).multiplyScalar(f.x).addScaledVector(u,-m.x).multiplyScalar(i),l[e].add(g),l[t].add(g),l[n].add(g),c[e].add(y),c[t].add(y),c[n].add(y))}let v=this.groups;0===v.length&&(v=[{start:0,count:n.length}]);for(let e=0,t=v.length;e<t;++e){const t=v[e],r=t.start;for(let e=r,i=r+t.count;e<i;e+=3)b(n[e+0],n[e+1],n[e+2])}const w=new RA,x=new RA,_=new RA,E=new RA;function S(e){_.fromArray(i,3*e),E.copy(_);const t=l[e];w.copy(t),w.sub(_.multiplyScalar(_.dot(t))).normalize(),x.crossVectors(E,t);const n=x.dot(c[e])<0?-1:1;a[4*e]=w.x,a[4*e+1]=w.y,a[4*e+2]=w.z,a[4*e+3]=n}for(let e=0,t=v.length;e<t;++e){const t=v[e],r=t.start;for(let e=r,i=r+t.count;e<i;e+=3)S(n[e+0]),S(n[e+1]),S(n[e+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new ZC(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const r=new RA,i=new RA,s=new RA,o=new RA,a=new RA,l=new RA,c=new RA,h=new RA;if(e)for(let u=0,d=e.count;u<d;u+=3){const d=e.getX(u+0),p=e.getX(u+1),f=e.getX(u+2);r.fromBufferAttribute(t,d),i.fromBufferAttribute(t,p),s.fromBufferAttribute(t,f),c.subVectors(s,i),h.subVectors(r,i),c.cross(h),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let e=0,o=t.count;e<o;e+=3)r.fromBufferAttribute(t,e+0),i.fromBufferAttribute(t,e+1),s.fromBufferAttribute(t,e+2),c.subVectors(s,i),h.subVectors(r,i),c.cross(h),n.setXYZ(e+0,c.x,c.y,c.z),n.setXYZ(e+1,c.x,c.y,c.z),n.setXYZ(e+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===e.attributes[r])continue;const i=n[r].array,s=e.attributes[r],o=s.array,a=s.itemSize*t,l=Math.min(o.length,i.length-a);for(let e=0,t=a;e<l;e++,t++)i[t]=o[e]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)aT.fromBufferAttribute(e,t),aT.normalize(),e.setXYZ(t,aT.x,aT.y,aT.z)}toNonIndexed(){function e(e,t){const n=e.array,r=e.itemSize,i=e.normalized,s=new n.constructor(t.length*r);let o=0,a=0;for(let i=0,l=t.length;i<l;i++){o=e.isInterleavedBufferAttribute?t[i]*e.data.stride+e.offset:t[i]*r;for(let e=0;e<r;e++)s[a++]=n[o++]}return new ZC(s,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new lT,n=this.index.array,r=this.attributes;for(const i in r){const s=e(r[i],n);t.setAttribute(i,s)}const i=this.morphAttributes;for(const r in i){const s=[],o=i[r];for(let t=0,r=o.length;t<r;t++){const r=e(o[t],n);s.push(r)}t.morphAttributes[r]=s}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let e=0,n=s.length;e<n;e++){const n=s[e];t.addGroup(n.start,n.count,n.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:[].slice.call(t.array)});const n=this.attributes;for(const t in n){const r=n[t];e.data.attributes[t]=r.toJSON(e.data)}const r={};let i=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],s=[];for(let t=0,r=n.length;t<r;t++){const r=n[t];s.push(r.toJSON(e.data))}s.length>0&&(r[t]=s,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const r=e.attributes;for(const e in r){const n=r[e];this.setAttribute(e,n.clone(t))}const i=e.morphAttributes;for(const e in i){const n=[],r=i[e];for(let e=0,i=r.length;e<i;e++)n.push(r[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let e=0,t=s.length;e<t;e++){const t=s[e];this.addGroup(t.start,t.count,t.materialIndex)}const o=e.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=e.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,void 0!==e.parameters&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const cT=new cC,hT=new lC,uT=new eC,dT=new RA,pT=new RA,fT=new RA,mT=new RA,gT=new RA,yT=new RA,bT=new RA,vT=new RA,wT=new RA,xT=new oA,_T=new oA,ET=new oA,ST=new RA,MT=new RA;class AT extends kC{constructor(e=new lT,t=new KC){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||e+"";this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}raycast(e,t){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0===r||(null===n.boundingSphere&&n.computeBoundingSphere(),uT.copy(n.boundingSphere),uT.applyMatrix4(i),!1===e.ray.intersectsSphere(uT))||(cT.copy(i).invert(),hT.copy(e.ray).applyMatrix4(cT),null!==n.boundingBox&&!1===hT.intersectsBox(n.boundingBox)))return;let s;const o=n.index,a=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,h=n.attributes.uv,u=n.attributes.uv2,d=n.groups,p=n.drawRange;if(null!==o)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],f=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(o.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3){const r=o.getX(n),d=o.getX(n+1),p=o.getX(n+2);s=CT(this,f,e,hT,a,l,c,h,u,r,d,p),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,t.push(s))}}else{for(let n=Math.max(0,p.start),i=Math.min(o.count,p.start+p.count);n<i;n+=3){const i=o.getX(n),d=o.getX(n+1),p=o.getX(n+2);s=CT(this,r,e,hT,a,l,c,h,u,i,d,p),s&&(s.faceIndex=Math.floor(n/3),t.push(s))}}else if(void 0!==a)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],o=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(a.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3){s=CT(this,o,e,hT,a,l,c,h,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,t.push(s))}}else{for(let n=Math.max(0,p.start),i=Math.min(a.count,p.start+p.count);n<i;n+=3){s=CT(this,r,e,hT,a,l,c,h,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),t.push(s))}}}}function CT(e,t,n,r,i,s,o,a,l,c,h,u){dT.fromBufferAttribute(i,c),pT.fromBufferAttribute(i,h),fT.fromBufferAttribute(i,u);const d=e.morphTargetInfluences;if(s&&d){bT.set(0,0,0),vT.set(0,0,0),wT.set(0,0,0);for(let e=0,t=s.length;e<t;e++){const t=d[e],n=s[e];0!==t&&(mT.fromBufferAttribute(n,c),gT.fromBufferAttribute(n,h),yT.fromBufferAttribute(n,u),o?(bT.addScaledVector(mT,t),vT.addScaledVector(gT,t),wT.addScaledVector(yT,t)):(bT.addScaledVector(mT.sub(dT),t),vT.addScaledVector(gT.sub(pT),t),wT.addScaledVector(yT.sub(fT),t)))}dT.add(bT),pT.add(vT),fT.add(wT)}e.isSkinnedMesh&&(e.boneTransform(c,dT),e.boneTransform(h,pT),e.boneTransform(u,fT));const p=function(e,t,n,r,i,s,o,a){let l;if(l=1===t.side?r.intersectTriangle(o,s,i,!0,a):r.intersectTriangle(i,s,o,2!==t.side,a),null===l)return null;MT.copy(a),MT.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(MT);return c<n.near||c>n.far?null:{distance:c,point:MT.clone(),object:e}}(e,t,n,r,dT,pT,fT,ST);if(p){a&&(xT.fromBufferAttribute(a,c),_T.fromBufferAttribute(a,h),ET.fromBufferAttribute(a,u),p.uv=WC.getUV(ST,dT,pT,fT,xT,_T,ET,new oA)),l&&(xT.fromBufferAttribute(l,c),_T.fromBufferAttribute(l,h),ET.fromBufferAttribute(l,u),p.uv2=WC.getUV(ST,dT,pT,fT,xT,_T,ET,new oA));const e={a:c,b:h,c:u,normal:new RA,materialIndex:0};WC.getNormal(dT,pT,fT,e.normal),p.face=e}return p}class TT extends lT{constructor(e=1,t=1,n=1,r=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const o=this;r=Math.floor(r),i=Math.floor(i);const a=[],l=[],c=[],h=[];let u=0,d=0;function p(e,t,n,r,i,s,p,f,m,g,y){const b=s/m,v=p/g,w=s/2,x=p/2,_=f/2,E=m+1,S=g+1;let M=0,A=0;const C=new RA;for(let s=0;s<S;s++){const o=s*v-x;for(let a=0;a<E;a++){const u=a*b-w;C[e]=u*r,C[t]=o*i,C[n]=_,l.push(C.x,C.y,C.z),C[e]=0,C[t]=0,C[n]=f>0?1:-1,c.push(C.x,C.y,C.z),h.push(a/m),h.push(1-s/g),M+=1}}for(let e=0;e<g;e++)for(let t=0;t<m;t++){const n=u+t+E*e,r=u+t+E*(e+1),i=u+(t+1)+E*(e+1),s=u+(t+1)+E*e;a.push(n,r,s),a.push(r,i,s),A+=6}o.addGroup(d,A,y),d+=A,u+=M}p("z","y","x",-1,-1,n,t,e,s=Math.floor(s),i,0),p("z","y","x",1,-1,n,t,-e,s,i,1),p("x","z","y",1,1,e,n,t,r,s,2),p("x","z","y",1,-1,e,n,-t,r,s,3),p("x","y","z",1,-1,e,t,n,r,i,4),p("x","y","z",-1,-1,e,t,-n,r,i,5),this.setIndex(a),this.setAttribute("position",new eT(l,3)),this.setAttribute("normal",new eT(c,3)),this.setAttribute("uv",new eT(h,2))}static fromJSON(e){return new TT(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function IT(e){const t={};for(const n in e){t[n]={};for(const r in e[n]){const i=e[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[n][r]=i.clone():t[n][r]=Array.isArray(i)?i.slice():i}}return t}function LT(e){const t={};for(let n=0;n<e.length;n++){const r=IT(e[n]);for(const e in r)t[e]=r[e]}return t}const PT={clone:IT,merge:LT};class RT extends $C{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=IT(e.uniforms),this.uniformsGroups=function(e){const t=[];for(let n=0;n<e.length;n++)t.push(e[n].clone());return t}(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?t.uniforms[n]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[n]={type:"m4",value:r.toArray()}:t.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class DT extends kC{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new cC,this.projectionMatrix=new cC,this.projectionMatrixInverse=new cC}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class kT extends DT{constructor(e=50,t=1,n=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*eA*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*QM*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*eA*Math.atan(Math.tan(.5*QM*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,i,s){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*QM*this.fov)/this.zoom,n=2*t,r=this.aspect*n,i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const e=s.fullWidth,o=s.fullHeight;i+=s.offsetX*r/e,t-=s.offsetY*n/o,r*=s.width/e,n*=s.height/o}const o=this.filmOffset;0!==o&&(i+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const NT=90;class FT extends kC{constructor(e,t,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new kT(NT,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new RA(1,0,0)),this.add(r);const i=new kT(NT,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new RA(-1,0,0)),this.add(i);const s=new kT(NT,1,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new RA(0,1,0)),this.add(s);const o=new kT(NT,1,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new RA(0,-1,0)),this.add(o);const a=new kT(NT,1,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new RA(0,0,1)),this.add(a);const l=new kT(NT,1,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new RA(0,0,-1)),this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,i,s,o,a,l]=this.children,c=e.getRenderTarget(),h=e.toneMapping,u=e.xr.enabled;e.toneMapping=0,e.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,r),e.setRenderTarget(n,1),e.render(t,i),e.setRenderTarget(n,2),e.render(t,s),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,a),n.texture.generateMipmaps=d,e.setRenderTarget(n,5),e.render(t,l),e.setRenderTarget(c),e.toneMapping=h,e.xr.enabled=u,n.texture.needsPMREMUpdate=!0}}class OT extends AA{constructor(e,t,n,r,i,s,o,a,l,c){super(e=void 0!==e?e:[],t=void 0!==t?t:301,n,r,i,s,o,a,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class BT extends TA{constructor(e,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},r=[n,n,n,n,n,n];this.texture=new OT(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:1006}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},r=new TT(5,5,5),i=new RT({name:"CubemapFromEquirect",uniforms:IT(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});i.uniforms.tEquirect.value=t;const s=new AT(r,i),o=t.minFilter;return 1008===t.minFilter&&(t.minFilter=1006),new FT(1,10,this).update(e,s),t.minFilter=o,s.geometry.dispose(),s.material.dispose(),this}clear(e,t,n,r){const i=e.getRenderTarget();for(let i=0;i<6;i++)e.setRenderTarget(this,i),e.clear(t,n,r);e.setRenderTarget(i)}}const zT=new RA,UT=new RA,HT=new aA;class qT{constructor(e=new RA(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=zT.subVectors(n,t).cross(UT.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(zT),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(n).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||HT.getNormalMatrix(e),r=this.coplanarPoint(zT).applyMatrix4(e),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const VT=new eC,GT=new RA;class WT{constructor(e=new qT,t=new qT,n=new qT,r=new qT,i=new qT,s=new qT){this.planes=[e,t,n,r,i,s]}set(e,t,n,r,i,s){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(r),o[4].copy(i),o[5].copy(s),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],h=n[7],u=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],b=n[15];return t[0].setComponents(o-r,h-a,f-u,b-m).normalize(),t[1].setComponents(o+r,h+a,f+u,b+m).normalize(),t[2].setComponents(o+i,h+l,f+d,b+g).normalize(),t[3].setComponents(o-i,h-l,f-d,b-g).normalize(),t[4].setComponents(o-s,h-c,f-p,b-y).normalize(),t[5].setComponents(o+s,h+c,f+p,b+y).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),VT.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(VT)}intersectsSprite(e){return VT.center.set(0,0,0),VT.radius=.7071067811865476,VT.applyMatrix4(e.matrixWorld),this.intersectsSphere(VT)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(GT.x=r.normal.x>0?e.max.x:e.min.x,GT.y=r.normal.y>0?e.max.y:e.min.y,GT.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(GT)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function jT(){let e=null,t=!1,n=null,r=null;function i(t,s){n(t,s),r=e.requestAnimationFrame(i)}return{start(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(i),t=!0)},stop(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop(e){n=e},setContext(t){e=t}}}function $T(e,t){const n=t.isWebGL2,r=new WeakMap;return{get(e){return e.isInterleavedBufferAttribute&&(e=e.data),r.get(e)},remove(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=r.get(t);n&&(e.deleteBuffer(n.buffer),r.delete(t))},update(t,i){if(t.isGLBufferAttribute){const e=r.get(t);return void((!e||e.version<t.version)&&r.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version}))}t.isInterleavedBufferAttribute&&(t=t.data);const s=r.get(t);void 0===s?r.set(t,function(t,r){const i=t.array,s=t.usage,o=e.createBuffer();let a;if(e.bindBuffer(r,o),e.bufferData(r,i,s),t.onUploadCallback(),i instanceof Float32Array)a=5126;else if(i instanceof Uint16Array)if(t.isFloat16BufferAttribute){if(!n)throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");a=5131}else a=5123;else if(i instanceof Int16Array)a=5122;else if(i instanceof Uint32Array)a=5125;else if(i instanceof Int32Array)a=5124;else if(i instanceof Int8Array)a=5120;else if(i instanceof Uint8Array)a=5121;else{if(!(i instanceof Uint8ClampedArray))throw Error("THREE.WebGLAttributes: Unsupported buffer data format: "+i);a=5121}return{buffer:o,type:a,bytesPerElement:i.BYTES_PER_ELEMENT,version:t.version}}(t,i)):s.version<t.version&&(function(t,r,i){const s=r.array,o=r.updateRange;e.bindBuffer(i,t),-1===o.count?e.bufferSubData(i,0,s):(n?e.bufferSubData(i,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):e.bufferSubData(i,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1)}(s.buffer,t,i),s.version=t.version)}}}class KT extends lT{constructor(e=1,t=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const i=e/2,s=t/2,o=Math.floor(n),a=Math.floor(r),l=o+1,c=a+1,h=e/o,u=t/a,d=[],p=[],f=[],m=[];for(let e=0;e<c;e++){const t=e*u-s;for(let n=0;n<l;n++){const r=n*h-i;p.push(r,-t,0),f.push(0,0,1),m.push(n/o),m.push(1-e/a)}}for(let e=0;e<a;e++)for(let t=0;t<o;t++){const n=t+l*e,r=t+l*(e+1),i=t+1+l*(e+1),s=t+1+l*e;d.push(n,r,s),d.push(r,i,s)}this.setIndex(d),this.setAttribute("position",new eT(p,3)),this.setAttribute("normal",new eT(f,3)),this.setAttribute("uv",new eT(m,2))}static fromJSON(e){return new KT(e.width,e.height,e.widthSegments,e.heightSegments)}}const XT={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},YT={common:{diffuse:{value:new wA(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new aA},uv2Transform:{value:new aA},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new oA(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wA(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wA(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new aA}},sprite:{diffuse:{value:new wA(16777215)},opacity:{value:1},center:{value:new oA(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new aA}}},ZT={basic:{uniforms:LT([YT.common,YT.specularmap,YT.envmap,YT.aomap,YT.lightmap,YT.fog]),vertexShader:XT.meshbasic_vert,fragmentShader:XT.meshbasic_frag},lambert:{uniforms:LT([YT.common,YT.specularmap,YT.envmap,YT.aomap,YT.lightmap,YT.emissivemap,YT.fog,YT.lights,{emissive:{value:new wA(0)}}]),vertexShader:XT.meshlambert_vert,fragmentShader:XT.meshlambert_frag},phong:{uniforms:LT([YT.common,YT.specularmap,YT.envmap,YT.aomap,YT.lightmap,YT.emissivemap,YT.bumpmap,YT.normalmap,YT.displacementmap,YT.fog,YT.lights,{emissive:{value:new wA(0)},specular:{value:new wA(1118481)},shininess:{value:30}}]),vertexShader:XT.meshphong_vert,fragmentShader:XT.meshphong_frag},standard:{uniforms:LT([YT.common,YT.envmap,YT.aomap,YT.lightmap,YT.emissivemap,YT.bumpmap,YT.normalmap,YT.displacementmap,YT.roughnessmap,YT.metalnessmap,YT.fog,YT.lights,{emissive:{value:new wA(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:XT.meshphysical_vert,fragmentShader:XT.meshphysical_frag},toon:{uniforms:LT([YT.common,YT.aomap,YT.lightmap,YT.emissivemap,YT.bumpmap,YT.normalmap,YT.displacementmap,YT.gradientmap,YT.fog,YT.lights,{emissive:{value:new wA(0)}}]),vertexShader:XT.meshtoon_vert,fragmentShader:XT.meshtoon_frag},matcap:{uniforms:LT([YT.common,YT.bumpmap,YT.normalmap,YT.displacementmap,YT.fog,{matcap:{value:null}}]),vertexShader:XT.meshmatcap_vert,fragmentShader:XT.meshmatcap_frag},points:{uniforms:LT([YT.points,YT.fog]),vertexShader:XT.points_vert,fragmentShader:XT.points_frag},dashed:{uniforms:LT([YT.common,YT.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:XT.linedashed_vert,fragmentShader:XT.linedashed_frag},depth:{uniforms:LT([YT.common,YT.displacementmap]),vertexShader:XT.depth_vert,fragmentShader:XT.depth_frag},normal:{uniforms:LT([YT.common,YT.bumpmap,YT.normalmap,YT.displacementmap,{opacity:{value:1}}]),vertexShader:XT.meshnormal_vert,fragmentShader:XT.meshnormal_frag},sprite:{uniforms:LT([YT.sprite,YT.fog]),vertexShader:XT.sprite_vert,fragmentShader:XT.sprite_frag},background:{uniforms:{uvTransform:{value:new aA},t2D:{value:null}},vertexShader:XT.background_vert,fragmentShader:XT.background_frag},cube:{uniforms:LT([YT.envmap,{opacity:{value:1}}]),vertexShader:XT.cube_vert,fragmentShader:XT.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:XT.equirect_vert,fragmentShader:XT.equirect_frag},distanceRGBA:{uniforms:LT([YT.common,YT.displacementmap,{referencePosition:{value:new RA},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:XT.distanceRGBA_vert,fragmentShader:XT.distanceRGBA_frag},shadow:{uniforms:LT([YT.lights,YT.fog,{color:{value:new wA(0)},opacity:{value:1}}]),vertexShader:XT.shadow_vert,fragmentShader:XT.shadow_frag}};function JT(e,t,n,r,i,s){const o=new wA(0);let a,l,c=!0===i?0:1,h=null,u=0,d=null;function p(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,s)}return{getClearColor(){return o},setClearColor(e,t=1){o.set(e),c=t,p(o,c)},getClearAlpha(){return c},setClearAlpha(e){c=e,p(o,c)},render(n,i){let s=!1,f=!0===i.isScene?i.background:null;f&&f.isTexture&&(f=t.get(f));const m=e.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?p(o,c):f&&f.isColor&&(p(f,1),s=!0),(e.autoClear||s)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),f&&(f.isCubeTexture||306===f.mapping)?(void 0===l&&(l=new AT(new TT(1,1,1),new RT({name:"BackgroundCubeMaterial",uniforms:IT(ZT.cube.uniforms),vertexShader:ZT.cube.vertexShader,fragmentShader:ZT.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(l.material,"envMap",{get(){return this.uniforms.envMap.value}}),r.update(l)),l.material.uniforms.envMap.value=f,l.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,(h!==f||u!==f.version||d!==e.toneMapping)&&(l.material.needsUpdate=!0,h=f,u=f.version,d=e.toneMapping),l.layers.enableAll(),n.unshift(l,l.geometry,l.material,0,0,null)):f&&f.isTexture&&(void 0===a&&(a=new AT(new KT(2,2),new RT({name:"BackgroundMaterial",uniforms:IT(ZT.background.uniforms),vertexShader:ZT.background.vertexShader,fragmentShader:ZT.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),a.material.uniforms.uvTransform.value.copy(f.matrix),(h!==f||u!==f.version||d!==e.toneMapping)&&(a.material.needsUpdate=!0,h=f,u=f.version,d=e.toneMapping),a.layers.enableAll(),n.unshift(a,a.geometry,a.material,0,0,null))}}}function QT(e,t,n,r){const i=e.getParameter(34921),s=r.isWebGL2?null:t.get("OES_vertex_array_object"),o=r.isWebGL2||null!==s,a={},l=p(null);let c=l,h=!1;function u(t){return r.isWebGL2?e.bindVertexArray(t):s.bindVertexArrayOES(t)}function d(t){return r.isWebGL2?e.deleteVertexArray(t):s.deleteVertexArrayOES(t)}function p(e){const t=[],n=[],r=[];for(let e=0;e<i;e++)t[e]=0,n[e]=0,r[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:r,object:e,attributes:{},index:null}}function f(){const e=c.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function m(e){g(e,0)}function g(n,i){const s=c.newAttributes,o=c.enabledAttributes,a=c.attributeDivisors;s[n]=1,0===o[n]&&(e.enableVertexAttribArray(n),o[n]=1),a[n]!==i&&((r.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),a[n]=i)}function y(){const t=c.newAttributes,n=c.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==t[r]&&(e.disableVertexAttribArray(r),n[r]=0)}function b(t,n,i,s,o,a){!0!==r.isWebGL2||5124!==i&&5125!==i?e.vertexAttribPointer(t,n,i,s,o,a):e.vertexAttribIPointer(t,n,i,o,a)}function v(){w(),h=!0,c!==l&&(c=l,u(c.object))}function w(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup(i,l,d,v,w){let x=!1;if(o){const t=function(t,n,i){const o=!0===i.wireframe;let l=a[t.id];void 0===l&&(l={},a[t.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let h=c[o];return void 0===h&&(h=p(r.isWebGL2?e.createVertexArray():s.createVertexArrayOES()),c[o]=h),h}(v,d,l);c!==t&&(c=t,u(c.object)),x=function(e,t,n,r){const i=c.attributes,s=t.attributes;let o=0;const a=n.getAttributes();for(const t in a)if(a[t].location>=0){const n=i[t];let r=s[t];if(void 0===r&&("instanceMatrix"===t&&e.instanceMatrix&&(r=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(r=e.instanceColor)),void 0===n||n.attribute!==r||r&&n.data!==r.data)return!0;o++}return c.attributesNum!==o||c.index!==r}(i,v,d,w),x&&function(e,t,n,r){const i={},s=t.attributes;let o=0;const a=n.getAttributes();for(const t in a)if(a[t].location>=0){let n=s[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[t]=r,o++}c.attributes=i,c.attributesNum=o,c.index=r}(i,v,d,w)}else{const e=!0===l.wireframe;(c.geometry!==v.id||c.program!==d.id||c.wireframe!==e)&&(c.geometry=v.id,c.program=d.id,c.wireframe=e,x=!0)}null!==w&&n.update(w,34963),(x||h)&&(h=!1,function(i,s,o,a){if(!1===r.isWebGL2&&(i.isInstancedMesh||a.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;f();const l=a.attributes,c=o.getAttributes(),h=s.defaultAttributeValues;for(const t in c){const r=c[t];if(r.location>=0){let s=l[t];if(void 0===s&&("instanceMatrix"===t&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===t&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const t=s.normalized,o=s.itemSize,l=n.get(s);if(void 0===l)continue;const c=l.buffer,h=l.type,u=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n.isInstancedInterleavedBuffer){for(let e=0;e<r.locationSize;e++)g(r.location+e,n.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let e=0;e<r.locationSize;e++)m(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)b(r.location+e,o/r.locationSize,h,t,l*u,(d+o/r.locationSize*e)*u)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<r.locationSize;e++)g(r.location+e,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<r.locationSize;e++)m(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)b(r.location+e,o/r.locationSize,h,t,o*u,o/r.locationSize*e*u)}}else if(void 0!==h){const n=h[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(r.location,n);break;case 3:e.vertexAttrib3fv(r.location,n);break;case 4:e.vertexAttrib4fv(r.location,n);break;default:e.vertexAttrib1fv(r.location,n)}}}}y()}(i,l,d,v),null!==w&&e.bindBuffer(34963,n.get(w).buffer))},reset:v,resetDefaultState:w,dispose(){v();for(const e in a){const t=a[e];for(const e in t){const n=t[e];for(const e in n)d(n[e].object),delete n[e];delete t[e]}delete a[e]}},releaseStatesOfGeometry(e){if(void 0===a[e.id])return;const t=a[e.id];for(const e in t){const n=t[e];for(const e in n)d(n[e].object),delete n[e];delete t[e]}delete a[e.id]},releaseStatesOfProgram(e){for(const t in a){const n=a[t];if(void 0===n[e.id])continue;const r=n[e.id];for(const e in r)d(r[e].object),delete r[e];delete n[e.id]}},initAttributes:f,enableAttribute:m,disableUnusedAttributes:y}}function eI(e,t,n,r){const i=r.isWebGL2;let s;this.setMode=function(e){s=e},this.render=function(t,r){e.drawArrays(s,t,r),n.update(r,s,1)},this.renderInstances=function(r,o,a){if(0===a)return;let l,c;if(i)l=e,c="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,r,o,a),n.update(o,s,a)}}function tI(e,t,n){let r;function i(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s=typeof WebGL2RenderingContext<"u"&&e instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&e instanceof WebGL2ComputeRenderingContext;let o=void 0!==n.precision?n.precision:"highp";const a=i(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=s||t.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,h=e.getParameter(34930),u=e.getParameter(35660),d=e.getParameter(3379),p=e.getParameter(34076),f=e.getParameter(34921),m=e.getParameter(36347),g=e.getParameter(36348),y=e.getParameter(36349),b=u>0,v=s||t.has("OES_texture_float"),w=b&&v,x=s?e.getParameter(36183):0;return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy(){if(void 0!==r)return r;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");r=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:i,precision:o,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:b,floatFragmentTextures:v,floatVertexTextures:w,maxSamples:x}}function nI(e){const t=this;let n=null,r=0,i=!1,s=!1;const o=new qT,a=new aA,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),t.numPlanes=r,t.numIntersection=0}function h(e,n,r,i){const s=null!==e?e.length:0;let c=null;if(0!==s){if(c=l.value,!0!==i||null===c){const t=r+4*s,i=n.matrixWorldInverse;a.getNormalMatrix(i),(null===c||c.length<t)&&(c=new Float32Array(t));for(let t=0,n=r;t!==s;++t,n+=4)o.copy(e[t]).applyMatrix4(i,a),o.normal.toArray(c,n),c[n+3]=o.constant}l.value=c,l.needsUpdate=!0}return t.numPlanes=s,t.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=(e,t,s)=>{const o=0!==e.length||t||0!==r||i;return i=t,n=h(e,s,0),r=e.length,o},this.beginShadows=()=>{s=!0,h(null)},this.endShadows=()=>{s=!1,c()},this.setState=function(t,o,a){const u=t.clippingPlanes,d=t.clipIntersection,p=t.clipShadows,f=e.get(t);if(!i||null===u||0===u.length||s&&!p)s?h(null):c();else{const e=s?0:r,t=4*e;let i=f.clippingState||null;l.value=i,i=h(u,o,t,a);for(let e=0;e!==t;++e)i[e]=n[e];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=e}}}function rI(e){let t=new WeakMap;function n(e,t){return 303===t?e.mapping=301:304===t&&(e.mapping=302),e}function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const s=i.mapping;if(303===s||304===s){if(t.has(i)){return n(t.get(i).texture,i.mapping)}{const s=i.image;if(s&&s.height>0){const o=new BT(s.height/2);return o.fromEquirectangularTexture(e,i),t.set(i,o),i.addEventListener("dispose",r),n(o.texture,i.mapping)}return null}}}return i},dispose(){t=new WeakMap}}}ZT.physical={uniforms:LT([ZT.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new oA(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new wA(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new oA},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new wA(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new wA(1,1,1)},specularColorMap:{value:null}}]),vertexShader:XT.meshphysical_vert,fragmentShader:XT.meshphysical_frag};class iI extends DT{constructor(e=-1,t=1,n=1,r=-1,i=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,n,r,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-e,s=n+e,o=r+t,a=r-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=e*this.view.offsetX,s=i+e*this.view.width,o-=t*this.view.offsetY,a=o-t*this.view.height}this.projectionMatrix.makeOrthographic(i,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}const sI=[.125,.215,.35,.446,.526,.582],oI=20,aI=new iI,lI=new wA;let cI=null;const hI=1.618033988749895,uI=1/hI,dI=[new RA(1,1,1),new RA(-1,1,1),new RA(1,1,-1),new RA(-1,1,-1),new RA(0,hI,uI),new RA(0,hI,-uI),new RA(uI,0,hI),new RA(-uI,0,hI),new RA(hI,uI,0),new RA(-hI,uI,0)];class pI{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){cI=this._renderer.getRenderTarget(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(e,n,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=yI(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=gI(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(cI),e.scissorTest=!1,mI(e,0,0,e.width,e.height)}_fromTexture(e,t){301===e.mapping||302===e.mapping?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),cI=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:1006,minFilter:1006,generateMipmaps:!1,type:1016,format:1023,encoding:3e3,depthBuffer:!1},r=fI(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=fI(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){const t=[],n=[],r=[];let i=e;const s=e-4+1+sI.length;for(let o=0;o<s;o++){const s=Math.pow(2,i);n.push(s);let a=1/s;o>e-4?a=sI[o-e+4-1]:0===o&&(a=0),r.push(a);const l=1/(s-2),c=-l,h=1+l,u=[c,c,h,c,h,h,c,c,h,h,c,h],d=6,p=6,f=3,m=2,g=1,y=new Float32Array(f*p*d),b=new Float32Array(m*p*d),v=new Float32Array(g*p*d);for(let e=0;e<d;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];y.set(r,f*p*e),b.set(u,m*p*e);const i=[e,e,e,e,e,e];v.set(i,g*p*e)}const w=new lT;w.setAttribute("position",new ZC(y,f)),w.setAttribute("uv",new ZC(b,m)),w.setAttribute("faceIndex",new ZC(v,g)),t.push(w),i>4&&i--}return{lodPlanes:t,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(e,t,n){const r=new Float32Array(oI),i=new RA(0,1,0);return new RT({name:"SphericalGaussianBlur",defines:{n:oI,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:e+".0"},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:bI(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(r,e,t)}return r}_compileMaterial(e){const t=new AT(this._lodPlanes[0],e);this._renderer.compile(t,aI)}_sceneToCubeUV(e,t,n,r){const i=new kT(90,1,t,n),s=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,l=a.autoClear,c=a.toneMapping;a.getClearColor(lI),a.toneMapping=0,a.autoClear=!1;const h=new KC({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),u=new AT(new TT,h);let d=!1;const p=e.background;p?p.isColor&&(h.color.copy(p),e.background=null,d=!0):(h.color.copy(lI),d=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(i.up.set(0,s[t],0),i.lookAt(o[t],0,0)):1===n?(i.up.set(0,0,s[t]),i.lookAt(0,o[t],0)):(i.up.set(0,s[t],0),i.lookAt(0,0,o[t]));const l=this._cubeSize;mI(r,n*l,t>2?l:0,l,l),a.setRenderTarget(r),d&&a.render(u,i),a.render(e,i)}u.geometry.dispose(),u.material.dispose(),a.toneMapping=c,a.autoClear=l,e.background=p}_textureToCubeUV(e,t){const n=this._renderer,r=301===e.mapping||302===e.mapping;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=yI()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=gI());const i=r?this._cubemapMaterial:this._equirectMaterial,s=new AT(this._lodPlanes[0],i);i.uniforms.envMap.value=e;const o=this._cubeSize;mI(t,0,0,3*o,2*o),n.setRenderTarget(t),n.render(s,aI)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let t=1;t<this._lodPlanes.length;t++){const n=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),r=dI[(t-1)%dI.length];this._blur(e,t-1,t,n,r)}t.autoClear=n}_blur(e,t,n,r,i){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,n,r,"latitudinal",i),this._halfBlur(s,e,n,n,r,"longitudinal",i)}_halfBlur(e,t,n,r,i,s,o){const a=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new AT(this._lodPlanes[r],l),h=l.uniforms,u=this._sizeLods[n]-1,d=isFinite(i)?Math.PI/(2*u):2*Math.PI/39,p=i/d,f=isFinite(i)?1+Math.floor(3*p):oI;f>oI&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let e=0;e<oI;++e){const t=e/p,n=Math.exp(-t*t/2);m.push(n),0===e?g+=n:e<f&&(g+=2*n)}for(let e=0;e<m.length;e++)m[e]=m[e]/g;h.envMap.value=e.texture,h.samples.value=f,h.weights.value=m,h.latitudinal.value="latitudinal"===s,o&&(h.poleAxis.value=o);const{_lodMax:y}=this;h.dTheta.value=d,h.mipInt.value=y-n;const b=this._sizeLods[r];mI(t,3*b*(r>y-4?r-y+4:0),4*(this._cubeSize-b),3*b,2*b),a.setRenderTarget(t),a.render(c,aI)}}function fI(e,t,n){const r=new TA(e,t,n);return r.texture.mapping=306,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function mI(e,t,n,r,i){e.viewport.set(t,n,r,i),e.scissor.set(t,n,r,i)}function gI(){return new RT({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:bI(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function yI(){return new RT({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:bI(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function bI(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function vI(e){let t=new WeakMap,n=null;function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get(i){if(i&&i.isTexture){const s=i.mapping,o=303===s||304===s,a=301===s||302===s;if(o||a){if(i.isRenderTargetTexture&&!0===i.needsPMREMUpdate){i.needsPMREMUpdate=!1;let r=t.get(i);return null===n&&(n=new pI(e)),r=o?n.fromEquirectangular(i,r):n.fromCubemap(i,r),t.set(i,r),r.texture}if(t.has(i))return t.get(i).texture;{const s=i.image;if(o&&s&&s.height>0||a&&s&&function(e){let t=0;const n=6;for(let r=0;r<n;r++)void 0!==e[r]&&t++;return t===n}(s)){null===n&&(n=new pI(e));const s=o?n.fromEquirectangular(i):n.fromCubemap(i);return t.set(i,s),i.addEventListener("dispose",r),s.texture}return null}}}return i},dispose(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function wI(e){const t={};function n(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r}return{has(e){return null!==n(e)},init(e){e.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function xI(e,t,n,r){const i={},s=new WeakMap;function o(e){const a=e.target;null!==a.index&&t.remove(a.index);for(const e in a.attributes)t.remove(a.attributes[e]);a.removeEventListener("dispose",o),delete i[a.id];const l=s.get(a);l&&(t.remove(l),s.delete(a)),r.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(e){const n=[],r=e.index,i=e.attributes.position;let o=0;if(null!==r){const e=r.array;o=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],i=e[t+1],s=e[t+2];n.push(r,i,i,s,s,r)}}else{const e=i.array;o=i.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,i=t+2;n.push(e,r,r,i,i,e)}}const a=new(lA(n)?QC:JC)(n,1);a.version=o;const l=s.get(e);l&&t.remove(l),s.set(e,a)}return{get(e,t){return!0===i[t.id]||(t.addEventListener("dispose",o),i[t.id]=!0,n.memory.geometries++),t},update(e){const n=e.attributes;for(const e in n)t.update(n[e],34962);const r=e.morphAttributes;for(const e in r){const n=r[e];for(let e=0,r=n.length;e<r;e++)t.update(n[e],34962)}},getWireframeAttribute(e){const t=s.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&a(e)}else a(e);return s.get(e)}}}function _I(e,t,n,r){const i=r.isWebGL2;let s,o,a;this.setMode=function(e){s=e},this.setIndex=function(e){o=e.type,a=e.bytesPerElement},this.render=function(t,r){e.drawElements(s,r,o,t*a),n.update(r,s,1)},this.renderInstances=function(r,l,c){if(0===c)return;let h,u;if(i)h=e,u="drawElementsInstanced";else if(h=t.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===h)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[u](s,l,o,r*a,c),n.update(l,s,c)}}function EI(){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update(t,n,r){switch(e.calls++,n){case 4:e.triangles+=r*(t/3);break;case 1:e.lines+=r*(t/2);break;case 3:e.lines+=r*(t-1);break;case 2:e.lines+=r*t;break;case 0:e.points+=r*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function SI(e,t){return e[0]-t[0]}function MI(e,t){return Math.abs(t[1])-Math.abs(e[1])}function AI(e,t){let n=1;const r=t.isInterleavedBufferAttribute?t.data.array:t.array;r instanceof Int8Array?n=127:r instanceof Uint8Array?n=255:r instanceof Uint16Array?n=65535:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),e.divideScalar(n)}function CI(e,t,n){const r={},i=new Float32Array(8),s=new WeakMap,o=new CA,a=[];for(let e=0;e<8;e++)a[e]=[e,0];return{update(l,c,h,u){const d=l.morphTargetInfluences;if(!0===t.isWebGL2){const r=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,i=void 0!==r?r.length:0;let a=s.get(c);if(void 0===a||a.count!==i){let e=()=>{y.dispose(),s.delete(c),c.removeEventListener("dispose",e)};void 0!==a&&a.texture.dispose();const n=void 0!==c.morphAttributes.position,r=void 0!==c.morphAttributes.normal,l=void 0!==c.morphAttributes.color,h=c.morphAttributes.position||[],u=c.morphAttributes.normal||[],d=c.morphAttributes.color||[];let p=0;!0===n&&(p=1),!0===r&&(p=2),!0===l&&(p=3);let f=c.attributes.position.count*p,m=1;f>t.maxTextureSize&&(m=Math.ceil(f/t.maxTextureSize),f=t.maxTextureSize);const g=new Float32Array(f*m*4*i),y=new IA(g,f,m,i);y.type=1015,y.needsUpdate=!0;const b=4*p;for(let e=0;e<i;e++){const t=h[e],i=u[e],s=d[e],a=f*m*4*e;for(let e=0;e<t.count;e++){const c=e*b;!0===n&&(o.fromBufferAttribute(t,e),!0===t.normalized&&AI(o,t),g[a+c+0]=o.x,g[a+c+1]=o.y,g[a+c+2]=o.z,g[a+c+3]=0),!0===r&&(o.fromBufferAttribute(i,e),!0===i.normalized&&AI(o,i),g[a+c+4]=o.x,g[a+c+5]=o.y,g[a+c+6]=o.z,g[a+c+7]=0),!0===l&&(o.fromBufferAttribute(s,e),!0===s.normalized&&AI(o,s),g[a+c+8]=o.x,g[a+c+9]=o.y,g[a+c+10]=o.z,g[a+c+11]=4===s.itemSize?o.w:1)}}a={count:i,texture:y,size:new oA(f,m)},s.set(c,a),c.addEventListener("dispose",e)}let l=0;for(let e=0;e<d.length;e++)l+=d[e];const h=c.morphTargetsRelative?1:1-l;u.getUniforms().setValue(e,"morphTargetBaseInfluence",h),u.getUniforms().setValue(e,"morphTargetInfluences",d),u.getUniforms().setValue(e,"morphTargetsTexture",a.texture,n),u.getUniforms().setValue(e,"morphTargetsTextureSize",a.size)}else{const t=void 0===d?0:d.length;let n=r[c.id];if(void 0===n||n.length!==t){n=[];for(let e=0;e<t;e++)n[e]=[e,0];r[c.id]=n}for(let e=0;e<t;e++){const t=n[e];t[0]=e,t[1]=d[e]}n.sort(MI);for(let e=0;e<8;e++)e<t&&n[e][1]?(a[e][0]=n[e][0],a[e][1]=n[e][1]):(a[e][0]=Number.MAX_SAFE_INTEGER,a[e][1]=0);a.sort(SI);const s=c.morphAttributes.position,o=c.morphAttributes.normal;let l=0;for(let e=0;e<8;e++){const t=a[e],n=t[0],r=t[1];n!==Number.MAX_SAFE_INTEGER&&r?(s&&c.getAttribute("morphTarget"+e)!==s[n]&&c.setAttribute("morphTarget"+e,s[n]),o&&c.getAttribute("morphNormal"+e)!==o[n]&&c.setAttribute("morphNormal"+e,o[n]),i[e]=r,l+=r):(s&&!0===c.hasAttribute("morphTarget"+e)&&c.deleteAttribute("morphTarget"+e),o&&!0===c.hasAttribute("morphNormal"+e)&&c.deleteAttribute("morphNormal"+e),i[e]=0)}const h=c.morphTargetsRelative?1:1-l;u.getUniforms().setValue(e,"morphTargetBaseInfluence",h),u.getUniforms().setValue(e,"morphTargetInfluences",i)}}}}function TI(e,t,n,r){let i=new WeakMap;function s(e){const t=e.target;t.removeEventListener("dispose",s),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update(e){const o=r.render.frame,a=e.geometry,l=t.get(e,a);return i.get(l)!==o&&(t.update(l),i.set(l,o)),e.isInstancedMesh&&(!1===e.hasEventListener("dispose",s)&&e.addEventListener("dispose",s),n.update(e.instanceMatrix,34962),null!==e.instanceColor&&n.update(e.instanceColor,34962)),l},dispose(){i=new WeakMap}}}const II=new AA,LI=new IA,PI=new LA,RI=new OT,DI=[],kI=[],NI=new Float32Array(16),FI=new Float32Array(9),OI=new Float32Array(4);function BI(e,t,n){const r=e[0];if(r<=0||r>0)return e;const i=t*n;let s=DI[i];if(void 0===s&&(s=new Float32Array(i),DI[i]=s),0!==t){r.toArray(s,0);for(let r=1,i=0;r!==t;++r)i+=n,e[r].toArray(s,i)}return s}function zI(e,t){if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0}function UI(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}function HI(e,t){let n=kI[t];void 0===n&&(n=new Int32Array(t),kI[t]=n);for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}function qI(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function VI(e,t){const n=this.cache;if(void 0!==t.x)(n[0]!==t.x||n[1]!==t.y)&&(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(zI(n,t))return;e.uniform2fv(this.addr,t),UI(n,t)}}function GI(e,t){const n=this.cache;if(void 0!==t.x)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z)&&(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)(n[0]!==t.r||n[1]!==t.g||n[2]!==t.b)&&(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(zI(n,t))return;e.uniform3fv(this.addr,t),UI(n,t)}}function WI(e,t){const n=this.cache;if(void 0!==t.x)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z||n[3]!==t.w)&&(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(zI(n,t))return;e.uniform4fv(this.addr,t),UI(n,t)}}function jI(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(zI(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),UI(n,t)}else{if(zI(n,r))return;OI.set(r),e.uniformMatrix2fv(this.addr,!1,OI),UI(n,r)}}function $I(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(zI(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),UI(n,t)}else{if(zI(n,r))return;FI.set(r),e.uniformMatrix3fv(this.addr,!1,FI),UI(n,r)}}function KI(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(zI(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),UI(n,t)}else{if(zI(n,r))return;NI.set(r),e.uniformMatrix4fv(this.addr,!1,NI),UI(n,r)}}function XI(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function YI(e,t){const n=this.cache;zI(n,t)||(e.uniform2iv(this.addr,t),UI(n,t))}function ZI(e,t){const n=this.cache;zI(n,t)||(e.uniform3iv(this.addr,t),UI(n,t))}function JI(e,t){const n=this.cache;zI(n,t)||(e.uniform4iv(this.addr,t),UI(n,t))}function QI(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function eL(e,t){const n=this.cache;zI(n,t)||(e.uniform2uiv(this.addr,t),UI(n,t))}function tL(e,t){const n=this.cache;zI(n,t)||(e.uniform3uiv(this.addr,t),UI(n,t))}function nL(e,t){const n=this.cache;zI(n,t)||(e.uniform4uiv(this.addr,t),UI(n,t))}function rL(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2D(t||II,i)}function iL(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(t||PI,i)}function sL(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(t||RI,i)}function oL(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(t||LI,i)}function aL(e,t){e.uniform1fv(this.addr,t)}function lL(e,t){const n=BI(t,this.size,2);e.uniform2fv(this.addr,n)}function cL(e,t){const n=BI(t,this.size,3);e.uniform3fv(this.addr,n)}function hL(e,t){const n=BI(t,this.size,4);e.uniform4fv(this.addr,n)}function uL(e,t){const n=BI(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function dL(e,t){const n=BI(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function pL(e,t){const n=BI(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function fL(e,t){e.uniform1iv(this.addr,t)}function mL(e,t){e.uniform2iv(this.addr,t)}function gL(e,t){e.uniform3iv(this.addr,t)}function yL(e,t){e.uniform4iv(this.addr,t)}function bL(e,t){e.uniform1uiv(this.addr,t)}function vL(e,t){e.uniform2uiv(this.addr,t)}function wL(e,t){e.uniform3uiv(this.addr,t)}function xL(e,t){e.uniform4uiv(this.addr,t)}function _L(e,t,n){const r=t.length,i=HI(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2D(t[e]||II,i[e])}function EL(e,t,n){const r=t.length,i=HI(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture3D(t[e]||PI,i[e])}function SL(e,t,n){const r=t.length,i=HI(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTextureCube(t[e]||RI,i[e])}function ML(e,t,n){const r=t.length,i=HI(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2DArray(t[e]||LI,i[e])}class AL{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function(e){switch(e){case 5126:return qI;case 35664:return VI;case 35665:return GI;case 35666:return WI;case 35674:return jI;case 35675:return $I;case 35676:return KI;case 5124:case 35670:return XI;case 35667:case 35671:return YI;case 35668:case 35672:return ZI;case 35669:case 35673:return JI;case 5125:return QI;case 36294:return eL;case 36295:return tL;case 36296:return nL;case 35678:case 36198:case 36298:case 36306:case 35682:return rL;case 35679:case 36299:case 36307:return iL;case 35680:case 36300:case 36308:case 36293:return sL;case 36289:case 36303:case 36311:case 36292:return oL}}(t.type)}}class CL{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function(e){switch(e){case 5126:return aL;case 35664:return lL;case 35665:return cL;case 35666:return hL;case 35674:return uL;case 35675:return dL;case 35676:return pL;case 5124:case 35670:return fL;case 35667:case 35671:return mL;case 35668:case 35672:return gL;case 35669:case 35673:return yL;case 5125:return bL;case 36294:return vL;case 36295:return wL;case 36296:return xL;case 35678:case 36198:case 36298:case 36306:case 35682:return _L;case 35679:case 36299:case 36307:return EL;case 35680:case 36300:case 36308:case 36293:return SL;case 36289:case 36303:case 36311:case 36292:return ML}}(t.type)}}class TL{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(e,t[s.id],n)}}}const IL=/(\w+)(\])?(\[|\.)?/g;function LL(e,t){e.seq.push(t),e.map[t.id]=t}function PL(e,t,n){const r=e.name,i=r.length;for(IL.lastIndex=0;;){const s=IL.exec(r),o=IL.lastIndex;let a=s[1];const l="]"===s[2],c=s[3];if(l&&(a|=0),void 0===c||"["===c&&o+2===i){LL(n,void 0===c?new AL(a,e,t):new CL(a,e,t));break}{let e=n.map[a];void 0===e&&(e=new TL(a),LL(n,e)),n=e}}}class RL{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let r=0;r<n;++r){const n=e.getActiveUniform(t,r);PL(n,e.getUniformLocation(t,n.name),this)}}setValue(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)}setOptional(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)}static upload(e,t,n,r){for(let i=0,s=t.length;i!==s;++i){const s=t[i],o=n[s.id];!1!==o.needsUpdate&&s.setValue(e,o.value,r)}}static seqWithValue(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n}}function DL(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}let kL=0;function NL(e,t,n){const r=e.getShaderParameter(t,35713),i=e.getShaderInfoLog(t).trim();if(r&&""===i)return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const r=parseInt(s[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(e,t){const n=e.split("\n"),r=[],i=Math.max(t-6,0),s=Math.min(t+6,n.length);for(let e=i;e<s;e++){const i=e+1;r.push(`${i===t?">":" "} ${i}: ${n[e]}`)}return r.join("\n")}(e.getShaderSource(t),r)}return i}function FL(e,t){const n=function(e){switch(e){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function OL(e,t){let n;switch(t){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function BL(e){return""!==e}function zL(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function UL(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const HL=/^[ \t]*#include +<([\w\d./]+)>/gm;function qL(e){return e.replace(HL,VL)}function VL(e,t){const n=XT[t];if(void 0===n)throw Error("Can not resolve #include <"+t+">");return qL(n)}const GL=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,WL=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function jL(e){return e.replace(WL,KL).replace(GL,$L)}function $L(e,t,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),KL(e,t,n,r)}function KL(e,t,n,r){let i="";for(let e=parseInt(t);e<parseInt(n);e++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return i}function XL(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function YL(e,t,n,r){const i=e.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(e){let t="SHADOWMAP_TYPE_BASIC";return 1===e.shadowMapType?t="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?t="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(t="SHADOWMAP_TYPE_VSM"),t}(n),c=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case 301:case 302:t="ENVMAP_TYPE_CUBE";break;case 306:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),h=function(e){let t="ENVMAP_MODE_REFLECTION";e.envMap&&302===e.envMapMode&&(t="ENVMAP_MODE_REFRACTION");return t}(n),u=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(n),d=function(e){const t=e.envMapCubeUVHeight;if(null===t)return null;const n=Math.log2(t)-2,r=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),p=n.isWebGL2?"":function(e){return[e.extensionDerivatives||e.envMapCubeUVHeight||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(BL).join("\n")}(n),f=function(e){const t=[];for(const n in e){const r=e[n];!1!==r&&t.push("#define "+n+" "+r)}return t.join("\n")}(s),m=i.createProgram();let g,y,b=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(BL).join("\n"),g.length>0&&(g+="\n"),y=[p,f].filter(BL).join("\n"),y.length>0&&(y+="\n")):(g=[XL(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(BL).join("\n"),y=[p,XL(n),"#define SHADER_NAME "+n.shaderName,f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?XT.tonemapping_pars_fragment:"",0!==n.toneMapping?OL("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",XT.encodings_pars_fragment,FL("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(BL).join("\n")),o=qL(o),o=zL(o,n),o=UL(o,n),a=qL(a),a=zL(a,n),a=UL(a,n),o=jL(o),a=jL(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(b="#version 300 es\n",g="precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n"+g,y=["#define varying in",n.glslVersion===YM?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===YM?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const v=b+y+a,w=DL(i,35633,b+g+o),x=DL(i,35632,v);if(i.attachShader(m,w),i.attachShader(m,x),void 0!==n.index0AttributeName?i.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m),e.debug.checkShaderErrors){const e=i.getProgramInfoLog(m).trim(),t=i.getShaderInfoLog(w).trim(),n=i.getShaderInfoLog(x).trim();let r=!0,s=!0;if(!1===i.getProgramParameter(m,35714)){r=!1;const t=NL(i,w,"vertex"),n=NL(i,x,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(m,35715)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+n)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):(""===t||""===n)&&(s=!1);s&&(this.diagnostics={runnable:r,programLog:e,vertexShader:{log:t,prefix:g},fragmentShader:{log:n,prefix:y}})}let _,E;return i.deleteShader(w),i.deleteShader(x),this.getUniforms=()=>(void 0===_&&(_=new RL(i,m)),_),this.getAttributes=()=>(void 0===E&&(E=function(e,t){const n={},r=e.getProgramParameter(t,35721);for(let i=0;i<r;i++){const r=e.getActiveAttrib(t,i),s=r.name;let o=1;35674===r.type&&(o=2),35675===r.type&&(o=3),35676===r.type&&(o=4),n[s]={type:r.type,location:e.getAttribLocation(t,s),locationSize:o}}return n}(i,m)),E),this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=kL++,this.cacheKey=t,this.usedTimes=1,this.program=m,this.vertexShader=w,this.fragmentShader=x,this}let ZL=0;class JL{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(n),s=this._getShaderCacheForMaterial(e);return!1===s.has(r)&&(s.add(r),r.usedTimes++),!1===s.has(i)&&(s.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return!1===t.has(e)&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(!1===t.has(e)){const n=new QL(e);t.set(e,n)}return t.get(e)}}class QL{constructor(e){this.id=ZL++,this.code=e,this.usedTimes=0}}function eP(e,t,n,r,i,s,o){const a=new wC,l=new JL,c=[],h=i.isWebGL2,u=i.logarithmicDepthBuffer,d=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters(s,a,c,m,g){const y=m.fog,b=g.geometry,v=s.isMeshStandardMaterial?m.environment:null,w=(s.isMeshStandardMaterial?n:t).get(s.envMap||v),x=w&&306===w.mapping?w.image.height:null,_=f[s.type];null!==s.precision&&(p=i.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead."));const E=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,S=void 0!==E?E.length:0;let M,A,C,T,I=0;if(void 0!==b.morphAttributes.position&&(I=1),void 0!==b.morphAttributes.normal&&(I=2),void 0!==b.morphAttributes.color&&(I=3),_){const e=ZT[_];M=e.vertexShader,A=e.fragmentShader}else M=s.vertexShader,A=s.fragmentShader,l.update(s),C=l.getVertexShaderID(s),T=l.getFragmentShaderID(s);const L=e.getRenderTarget(),P=s.alphaTest>0,R=s.clearcoat>0,D=s.iridescence>0;return{isWebGL2:h,shaderID:_,shaderName:s.type,vertexShader:M,fragmentShader:A,defines:s.defines,customVertexShaderID:C,customFragmentShaderID:T,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:!0===g.isInstancedMesh,instancingColor:!0===g.isInstancedMesh&&null!==g.instanceColor,supportsVertexTextures:d,outputEncoding:null===L?e.outputEncoding:!0===L.isXRRenderTarget?L.texture.encoding:3e3,map:!!s.map,matcap:!!s.matcap,envMap:!!w,envMapMode:w&&w.mapping,envMapCubeUVHeight:x,lightMap:!!s.lightMap,aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,decodeVideoTexture:!!s.map&&!0===s.map.isVideoTexture&&3001===s.map.encoding,clearcoat:R,clearcoatMap:R&&!!s.clearcoatMap,clearcoatRoughnessMap:R&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:R&&!!s.clearcoatNormalMap,iridescence:D,iridescenceMap:D&&!!s.iridescenceMap,iridescenceThicknessMap:D&&!!s.iridescenceThicknessMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,opaque:!1===s.transparent&&1===s.blending,alphaMap:!!s.alphaMap,alphaTest:P,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!b.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheenColorMap||s.sheenRoughnessMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap||!s.displacementMap),fog:!!y,useFog:!0===s.fog,fogExp2:y&&y.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===g.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:S,morphTextureStride:I,numDirLights:a.directional.length,numPointLights:a.point.length,numSpotLights:a.spot.length,numRectAreaLights:a.rectArea.length,numHemiLights:a.hemi.length,numDirLightShadows:a.directionalShadowMap.length,numPointLightShadows:a.pointShadowMap.length,numSpotLightShadows:a.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:s.dithering,shadowMapEnabled:e.shadowMap.enabled&&c.length>0,shadowMapType:e.shadowMap.type,toneMapping:s.toneMapped?e.toneMapping:0,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,useDepthPacking:!!s.depthPacking,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(function(e,t){e.push(t.precision),e.push(t.outputEncoding),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.combine),e.push(t.vertexUvs),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){a.disableAll(),t.isWebGL2&&a.enable(0),t.supportsVertexTextures&&a.enable(1),t.instancing&&a.enable(2),t.instancingColor&&a.enable(3),t.map&&a.enable(4),t.matcap&&a.enable(5),t.envMap&&a.enable(6),t.lightMap&&a.enable(7),t.aoMap&&a.enable(8),t.emissiveMap&&a.enable(9),t.bumpMap&&a.enable(10),t.normalMap&&a.enable(11),t.objectSpaceNormalMap&&a.enable(12),t.tangentSpaceNormalMap&&a.enable(13),t.clearcoat&&a.enable(14),t.clearcoatMap&&a.enable(15),t.clearcoatRoughnessMap&&a.enable(16),t.clearcoatNormalMap&&a.enable(17),t.iridescence&&a.enable(18),t.iridescenceMap&&a.enable(19),t.iridescenceThicknessMap&&a.enable(20),t.displacementMap&&a.enable(21),t.specularMap&&a.enable(22),t.roughnessMap&&a.enable(23),t.metalnessMap&&a.enable(24),t.gradientMap&&a.enable(25),t.alphaMap&&a.enable(26),t.alphaTest&&a.enable(27),t.vertexColors&&a.enable(28),t.vertexAlphas&&a.enable(29),t.vertexUvs&&a.enable(30),t.vertexTangents&&a.enable(31),t.uvsVertexOnly&&a.enable(32),t.fog&&a.enable(33),e.push(a.mask),a.disableAll(),t.useFog&&a.enable(0),t.flatShading&&a.enable(1),t.logarithmicDepthBuffer&&a.enable(2),t.skinning&&a.enable(3),t.morphTargets&&a.enable(4),t.morphNormals&&a.enable(5),t.morphColors&&a.enable(6),t.premultipliedAlpha&&a.enable(7),t.shadowMapEnabled&&a.enable(8),t.physicallyCorrectLights&&a.enable(9),t.doubleSided&&a.enable(10),t.flipSided&&a.enable(11),t.useDepthPacking&&a.enable(12),t.dithering&&a.enable(13),t.specularIntensityMap&&a.enable(14),t.specularColorMap&&a.enable(15),t.transmission&&a.enable(16),t.transmissionMap&&a.enable(17),t.thicknessMap&&a.enable(18),t.sheen&&a.enable(19),t.sheenColorMap&&a.enable(20),t.sheenRoughnessMap&&a.enable(21),t.decodeVideoTexture&&a.enable(22),t.opaque&&a.enable(23),e.push(a.mask)}(n,t),n.push(e.outputEncoding)),n.push(t.customProgramCacheKey),n.join()},getUniforms(e){const t=f[e.type];let n;if(t){const e=ZT[t];n=PT.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram(t,n){let r;for(let e=0,t=c.length;e<t;e++){const t=c[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new YL(e,n,t,s),c.push(r)),r},releaseProgram(e){if(0===--e.usedTimes){const t=c.indexOf(e);c[t]=c[c.length-1],c.pop(),e.destroy()}},releaseShaderCache(e){l.remove(e)},programs:c,dispose(){l.dispose()}}}function tP(){let e=new WeakMap;return{get(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove(t){e.delete(t)},update(t,n,r){e.get(t)[n]=r},dispose(){e=new WeakMap}}}function nP(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function rP(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function iP(){const e=[];let t=0;const n=[],r=[],i=[];function s(n,r,i,s,o,a){let l=e[t];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:s,renderOrder:n.renderOrder,z:o,group:a},e[t]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=o,l.group=a),t++,l}return{opaque:n,transmissive:r,transparent:i,init(){t=0,n.length=0,r.length=0,i.length=0},push(e,t,o,a,l,c){const h=s(e,t,o,a,l,c);o.transmission>0?r.push(h):!0===o.transparent?i.push(h):n.push(h)},unshift(e,t,o,a,l,c){const h=s(e,t,o,a,l,c);o.transmission>0?r.unshift(h):!0===o.transparent?i.unshift(h):n.unshift(h)},finish(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort(e,t){n.length>1&&n.sort(e||nP),r.length>1&&r.sort(t||rP),i.length>1&&i.sort(t||rP)}}}function sP(){let e=new WeakMap;return{get(t,n){let r;return!1===e.has(t)?(r=new iP,e.set(t,[r])):n>=e.get(t).length?(r=new iP,e.get(t).push(r)):r=e.get(t)[n],r},dispose(){e=new WeakMap}}}function oP(){const e={};return{get(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new RA,color:new wA};break;case"SpotLight":n={position:new RA,direction:new RA,color:new wA,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new RA,color:new wA,distance:0,decay:0};break;case"HemisphereLight":n={direction:new RA,skyColor:new wA,groundColor:new wA};break;case"RectAreaLight":n={color:new wA,position:new RA,halfWidth:new RA,halfHeight:new RA}}return e[t.id]=n,n}}}let aP=0;function lP(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function cP(e,t){const n=new oP,r=function(){const e={};return{get(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new oA};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new oA,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)i.probe.push(new RA);const s=new RA,o=new cC,a=new cC;return{setup(s,o){let a=0,l=0,c=0;for(let e=0;e<9;e++)i.probe[e].set(0,0,0);let h=0,u=0,d=0,p=0,f=0,m=0,g=0,y=0;s.sort(lP);const b=!0!==o?Math.PI:1;for(let e=0,t=s.length;e<t;e++){const t=s[e],o=t.color,v=t.intensity,w=t.distance,x=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)a+=o.r*v*b,l+=o.g*v*b,c+=o.b*v*b;else if(t.isLightProbe)for(let e=0;e<9;e++)i.probe[e].addScaledVector(t.sh.coefficients[e],v);else if(t.isDirectionalLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*b),t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,i.directionalShadow[h]=n,i.directionalShadowMap[h]=x,i.directionalShadowMatrix[h]=t.shadow.matrix,m++}i.directional[h]=e,h++}else if(t.isSpotLight){const e=n.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(o).multiplyScalar(v*b),e.distance=w,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,i.spotShadow[d]=n,i.spotShadowMap[d]=x,i.spotShadowMatrix[d]=t.shadow.matrix,y++}i.spot[d]=e,d++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(o).multiplyScalar(v),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),i.rectArea[p]=e,p++}else if(t.isPointLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*b),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,n.shadowCameraNear=e.camera.near,n.shadowCameraFar=e.camera.far,i.pointShadow[u]=n,i.pointShadowMap[u]=x,i.pointShadowMatrix[u]=t.shadow.matrix,g++}i.point[u]=e,u++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(v*b),e.groundColor.copy(t.groundColor).multiplyScalar(v*b),i.hemi[f]=e,f++}}p>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(i.rectAreaLTC1=YT.LTC_FLOAT_1,i.rectAreaLTC2=YT.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=YT.LTC_HALF_1,i.rectAreaLTC2=YT.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=a,i.ambient[1]=l,i.ambient[2]=c;const v=i.hash;(v.directionalLength!==h||v.pointLength!==u||v.spotLength!==d||v.rectAreaLength!==p||v.hemiLength!==f||v.numDirectionalShadows!==m||v.numPointShadows!==g||v.numSpotShadows!==y)&&(i.directional.length=h,i.spot.length=d,i.rectArea.length=p,i.point.length=u,i.hemi.length=f,i.directionalShadow.length=m,i.directionalShadowMap.length=m,i.pointShadow.length=g,i.pointShadowMap.length=g,i.spotShadow.length=y,i.spotShadowMap.length=y,i.directionalShadowMatrix.length=m,i.pointShadowMatrix.length=g,i.spotShadowMatrix.length=y,v.directionalLength=h,v.pointLength=u,v.spotLength=d,v.rectAreaLength=p,v.hemiLength=f,v.numDirectionalShadows=m,v.numPointShadows=g,v.numSpotShadows=y,i.version=aP++)},setupView(e,t){let n=0,r=0,l=0,c=0,h=0;const u=t.matrixWorldInverse;for(let t=0,d=e.length;t<d;t++){const d=e[t];if(d.isDirectionalLight){const e=i.directional[n];e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(u),n++}else if(d.isSpotLight){const e=i.spot[l];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(u),e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const e=i.rectArea[c];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(u),a.identity(),o.copy(d.matrixWorld),o.premultiply(u),a.extractRotation(o),e.halfWidth.set(.5*d.width,0,0),e.halfHeight.set(0,.5*d.height,0),e.halfWidth.applyMatrix4(a),e.halfHeight.applyMatrix4(a),c++}else if(d.isPointLight){const e=i.point[r];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(u),r++}else if(d.isHemisphereLight){const e=i.hemi[h];e.direction.setFromMatrixPosition(d.matrixWorld),e.direction.transformDirection(u),h++}}},state:i}}function hP(e,t){const n=new cP(e,t),r=[],i=[];return{init(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights(e){n.setup(r,e)},setupLightsView(e){n.setupView(r,e)},pushLight(e){r.push(e)},pushShadow(e){i.push(e)}}}function uP(e,t){let n=new WeakMap;return{get(r,i=0){let s;return!1===n.has(r)?(s=new hP(e,t),n.set(r,[s])):i>=n.get(r).length?(s=new hP(e,t),n.get(r).push(s)):s=n.get(r)[i],s},dispose(){n=new WeakMap}}}class dP extends $C{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class pP extends $C{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new RA,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function fP(e,t,n){let r=new WT;const i=new oA,s=new oA,o=new CA,a=new dP({depthPacking:3201}),l=new pP,c={},h=n.maxTextureSize,u={0:1,1:0,2:2},d=new RT({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new oA},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new lT;f.setAttribute("position",new ZC(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new AT(f,d),g=this;function y(n,r){const s=t.update(m);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,p.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new TA(i.x,i.y)),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(r,null,s,d,m,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(r,null,s,p,m,null)}function b(t,n,r,i,s,o){let h=null;const d=!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(h=void 0!==d?d:!0===r.isPointLight?l:a,e.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0){const e=h.uuid,t=n.uuid;let r=c[e];void 0===r&&(r={},c[e]=r);let i=r[t];void 0===i&&(i=h.clone(),r[t]=i),h=i}return h.visible=n.visible,h.wireframe=n.wireframe,h.side=3===o?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:u[n.side],h.alphaMap=n.alphaMap,h.alphaTest=n.alphaTest,h.clipShadows=n.clipShadows,h.clippingPlanes=n.clippingPlanes,h.clipIntersection=n.clipIntersection,h.displacementMap=n.displacementMap,h.displacementScale=n.displacementScale,h.displacementBias=n.displacementBias,h.wireframeLinewidth=n.wireframeLinewidth,h.linewidth=n.linewidth,!0===r.isPointLight&&!0===h.isMeshDistanceMaterial&&(h.referencePosition.setFromMatrixPosition(r.matrixWorld),h.nearDistance=i,h.farDistance=s),h}function v(n,i,s,o,a){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===a)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=t.update(n),i=n.material;if(Array.isArray(i)){const t=r.groups;for(let l=0,c=t.length;l<c;l++){const c=t[l],h=i[c.materialIndex];if(h&&h.visible){const t=b(n,h,o,s.near,s.far,a);e.renderBufferDirect(s,null,r,t,n,c)}}}else if(i.visible){const t=b(n,i,o,s.near,s.far,a);e.renderBufferDirect(s,null,r,t,n,null)}}const l=n.children;for(let e=0,t=l.length;e<t;e++)v(l[e],i,s,o,a)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(t,n,a){if(!1===g.enabled||!1===g.autoUpdate&&!1===g.needsUpdate||0===t.length)return;const l=e.getRenderTarget(),c=e.getActiveCubeFace(),u=e.getActiveMipmapLevel(),d=e.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,c=t.length;l<c;l++){const c=t[l],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;i.copy(u.mapSize);const p=u.getFrameExtents();if(i.multiply(p),s.copy(u.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(s.x=Math.floor(h/p.x),i.x=s.x*p.x,u.mapSize.x=s.x),i.y>h&&(s.y=Math.floor(h/p.y),i.y=s.y*p.y,u.mapSize.y=s.y)),null===u.map){const e=3!==this.type?{minFilter:1003,magFilter:1003}:{};u.map=new TA(i.x,i.y,e),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()}e.setRenderTarget(u.map),e.clear();const f=u.getViewportCount();for(let e=0;e<f;e++){const t=u.getViewport(e);o.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w),d.viewport(o),u.updateMatrices(c,e),r=u.getFrustum(),v(n,a,u.camera,c,this.type)}!0!==u.isPointLightShadow&&3===this.type&&y(u,a),u.needsUpdate=!1}g.needsUpdate=!1,e.setRenderTarget(l,c,u)}}function mP(e,t,n){const r=n.isWebGL2;const i=new function(){let t=!1;const n=new CA;let r=null;const i=new CA(0,0,0,0);return{setMask(n){r!==n&&!t&&(e.colorMask(n,n,n,n),r=n)},setLocked(e){t=e},setClear(t,r,s,o,a){!0===a&&(t*=o,r*=o,s*=o),n.set(t,r,s,o),!1===i.equals(n)&&(e.clearColor(t,r,s,o),i.copy(n))},reset(){t=!1,r=null,i.set(-1,0,0,0)}}},s=new function(){let t=!1,n=null,r=null,i=null;return{setTest(e){e?U(2929):H(2929)},setMask(r){n!==r&&!t&&(e.depthMask(r),n=r)},setFunc(t){if(r!==t){if(t)switch(t){case 0:e.depthFunc(512);break;case 1:e.depthFunc(519);break;case 2:e.depthFunc(513);break;case 3:default:e.depthFunc(515);break;case 4:e.depthFunc(514);break;case 5:e.depthFunc(518);break;case 6:e.depthFunc(516);break;case 7:e.depthFunc(517)}else e.depthFunc(515);r=t}},setLocked(e){t=e},setClear(t){i!==t&&(e.clearDepth(t),i=t)},reset(){t=!1,n=null,r=null,i=null}}},o=new function(){let t=!1,n=null,r=null,i=null,s=null,o=null,a=null,l=null,c=null;return{setTest(e){t||(e?U(2960):H(2960))},setMask(r){n!==r&&!t&&(e.stencilMask(r),n=r)},setFunc(t,n,o){(r!==t||i!==n||s!==o)&&(e.stencilFunc(t,n,o),r=t,i=n,s=o)},setOp(t,n,r){(o!==t||a!==n||l!==r)&&(e.stencilOp(t,n,r),o=t,a=n,l=r)},setLocked(e){t=e},setClear(t){c!==t&&(e.clearStencil(t),c=t)},reset(){t=!1,n=null,r=null,i=null,s=null,o=null,a=null,l=null,c=null}}},a=new WeakMap,l=new WeakMap;let c={},h={},u=new WeakMap,d=[],p=null,f=!1,m=null,g=null,y=null,b=null,v=null,w=null,x=null,_=!1,E=null,S=null,M=null,A=null,C=null;const T=e.getParameter(35661);let I=!1,L=0;const P=e.getParameter(7938);-1!==P.indexOf("WebGL")?(L=parseFloat(/^WebGL (\d)/.exec(P)[1]),I=L>=1):-1!==P.indexOf("OpenGL ES")&&(L=parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),I=L>=2);let R=null,D={};const k=e.getParameter(3088),N=e.getParameter(2978),F=(new CA).fromArray(k),O=(new CA).fromArray(N);function B(t,n,r){const i=new Uint8Array(4),s=e.createTexture();e.bindTexture(t,s),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let t=0;t<r;t++)e.texImage2D(n+t,0,6408,1,1,0,6408,5121,i);return s}const z={};function U(t){!0!==c[t]&&(e.enable(t),c[t]=!0)}function H(t){!1!==c[t]&&(e.disable(t),c[t]=!1)}z[3553]=B(3553,3553,1),z[34067]=B(34067,34069,6),i.setClear(0,0,0,1),s.setClear(1),o.setClear(0),U(2929),s.setFunc(3),W(!1),j(1),U(2884),G(0);const q={100:32774,101:32778,102:32779};if(r)q[103]=32775,q[104]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&(q[103]=e.MIN_EXT,q[104]=e.MAX_EXT)}const V={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function G(t,n,r,i,s,o,a,l){if(0!==t){if(!1===f&&(U(3042),f=!0),5===t)s=s||n,o=o||r,a=a||i,(n!==g||s!==v)&&(e.blendEquationSeparate(q[n],q[s]),g=n,v=s),(r!==y||i!==b||o!==w||a!==x)&&(e.blendFuncSeparate(V[r],V[i],V[o],V[a]),y=r,b=i,w=o,x=a),m=t,_=null;else if(t!==m||l!==_){if((100!==g||100!==v)&&(e.blendEquation(32774),g=100,v=100),l)switch(t){case 1:e.blendFuncSeparate(1,771,1,771);break;case 2:e.blendFunc(1,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(770,771,1,771);break;case 2:e.blendFunc(770,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}y=null,b=null,w=null,x=null,m=t,_=l}}else!0===f&&(H(3042),f=!1)}function W(t){E!==t&&(t?e.frontFace(2304):e.frontFace(2305),E=t)}function j(t){0!==t?(U(2884),t!==S&&(1===t?e.cullFace(1029):2===t?e.cullFace(1028):e.cullFace(1032))):H(2884),S=t}function $(t,n,r){t?(U(32823),(A!==n||C!==r)&&(e.polygonOffset(n,r),A=n,C=r)):H(32823)}function K(t){void 0===t&&(t=33984+T-1),R!==t&&(e.activeTexture(t),R=t)}return{buffers:{color:i,depth:s,stencil:o},enable:U,disable:H,bindFramebuffer(t,n){return h[t]!==n&&(e.bindFramebuffer(t,n),h[t]=n,r&&(36009===t&&(h[36160]=n),36160===t&&(h[36009]=n)),!0)},drawBuffers(r,i){let s=d,o=!1;if(r)if(s=u.get(i),void 0===s&&(s=[],u.set(i,s)),r.isWebGLMultipleRenderTargets){const e=r.texture;if(s.length!==e.length||36064!==s[0]){for(let t=0,n=e.length;t<n;t++)s[t]=36064+t;s.length=e.length,o=!0}}else 36064!==s[0]&&(s[0]=36064,o=!0);else 1029!==s[0]&&(s[0]=1029,o=!0);o&&(n.isWebGL2?e.drawBuffers(s):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram(t){return p!==t&&(e.useProgram(t),p=t,!0)},setBlending:G,setMaterial(e,t){2===e.side?H(2884):U(2884);let n=1===e.side;t&&(n=!n),W(n),1===e.blending&&!1===e.transparent?G(0):G(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),s.setFunc(e.depthFunc),s.setTest(e.depthTest),s.setMask(e.depthWrite),i.setMask(e.colorWrite);const r=e.stencilWrite;o.setTest(r),r&&(o.setMask(e.stencilWriteMask),o.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),o.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),$(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?U(32926):H(32926)},setFlipSided:W,setCullFace:j,setLineWidth(t){t!==M&&(I&&e.lineWidth(t),M=t)},setPolygonOffset:$,setScissorTest(e){e?U(3089):H(3089)},activeTexture:K,bindTexture(t,n){null===R&&K();let r=D[R];void 0===r&&(r={type:void 0,texture:void 0},D[R]=r),(r.type!==t||r.texture!==n)&&(e.bindTexture(t,n||z[t]),r.type=t,r.texture=n)},unbindTexture(){const t=D[R];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},updateUBOMapping(t,n){let r=l.get(n);void 0===r&&(r=new WeakMap,l.set(n,r));let i=r.get(t);void 0===i&&(i=e.getUniformBlockIndex(n,t.name),r.set(t,i))},uniformBlockBinding(t,n){const r=l.get(n).get(t);a.get(t)!==r&&(e.uniformBlockBinding(n,r,t.__bindingPointIndex),a.set(t,r))},texStorage2D(){try{e.texStorage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D(){try{e.texStorage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D(){try{e.texSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D(){try{e.texSubImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor(t){!1===F.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),F.copy(t))},viewport(t){!1===O.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),O.copy(t))},reset(){e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.disable(32926),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.bindFramebuffer(36160,null),!0===r&&(e.bindFramebuffer(36009,null),e.bindFramebuffer(36008,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),c={},R=null,D={},h={},u=new WeakMap,d=[],p=null,f=!1,m=null,g=null,y=null,b=null,v=null,w=null,x=null,_=!1,E=null,S=null,M=null,A=null,C=null,F.set(0,0,e.canvas.width,e.canvas.height),O.set(0,0,e.canvas.width,e.canvas.height),i.reset(),s.reset(),o.reset()}}}function gP(e,t,n,r,i,s,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,h=i.maxTextureSize,u=i.maxSamples,d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let m;const g=new WeakMap;let y=!1;try{y=typeof OffscreenCanvas<"u"&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch{}function b(e,t){return y?new OffscreenCanvas(e,t):cA("canvas")}function v(e,t,n,r){let i=1;if((e.width>r||e.height>r)&&(i=r/Math.max(e.width,e.height)),i<1||!0===t){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const r=t?sA:Math.floor,s=r(i*e.width),o=r(i*e.height);void 0===m&&(m=b(s,o));const a=n?b(s,o):m;return a.width=s,a.height=o,a.getContext("2d").drawImage(e,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+o+")."),a}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function w(e){return iA(e.width)&&iA(e.height)}function x(e,t){return e.generateMipmaps&&t&&1003!==e.minFilter&&1006!==e.minFilter}function _(t){e.generateMipmap(t)}function E(n,r,i,s,o=!1){if(!1===a)return r;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=r;return 6403===r&&(5126===i&&(l=33326),5131===i&&(l=33325),5121===i&&(l=33321)),33319===r&&(5126===i&&(l=33328),5131===i&&(l=33327),5121===i&&(l=33323)),6408===r&&(5126===i&&(l=34836),5131===i&&(l=34842),5121===i&&(l=3001===s&&!1===o?35907:32856),32819===i&&(l=32854),32820===i&&(l=32855)),(33325===l||33326===l||33327===l||33328===l||34842===l||34836===l)&&t.get("EXT_color_buffer_float"),l}function S(e,t,n){return!0===x(e,n)||e.isFramebufferTexture&&1003!==e.minFilter&&1006!==e.minFilter?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function M(e){return 1003===e||1004===e||1005===e?9728:9729}function A(e){const t=e.target;t.removeEventListener("dispose",A),function(e){const t=r.get(e);if(void 0===t.__webglInit)return;const n=e.source,i=g.get(n);if(i){const r=i[t.__cacheKey];r.usedTimes--,0===r.usedTimes&&T(e),0===Object.keys(i).length&&g.delete(n)}r.remove(e)}(t),t.isVideoTexture&&f.delete(t)}function C(t){const n=t.target;n.removeEventListener("dispose",C),function(t){const n=t.texture,i=r.get(t),s=r.get(n);if(void 0!==s.__webglTexture&&(e.deleteTexture(s.__webglTexture),o.memory.textures--),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(i.__webglFramebuffer[t]),i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer[t]);else{if(e.deleteFramebuffer(i.__webglFramebuffer),i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&e.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer)for(let t=0;t<i.__webglColorRenderbuffer.length;t++)i.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);i.__webglDepthRenderbuffer&&e.deleteRenderbuffer(i.__webglDepthRenderbuffer)}if(t.isWebGLMultipleRenderTargets)for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);i.__webglTexture&&(e.deleteTexture(i.__webglTexture),o.memory.textures--),r.remove(n[t])}r.remove(n),r.remove(t)}(n)}function T(t){const n=r.get(t);e.deleteTexture(n.__webglTexture);const i=t.source;delete g.get(i)[n.__cacheKey],o.memory.textures--}let I=0;function L(e,t){const i=r.get(e);if(e.isVideoTexture&&function(e){const t=o.render.frame;f.get(e)!==t&&(f.set(e,t),e.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&i.__version!==e.version){const n=e.image;if(null===n)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==n.complete)return void N(i,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t),n.bindTexture(3553,i.__webglTexture)}const P={1e3:10497,1001:33071,1002:33648},R={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function D(n,s,o){if(o?(e.texParameteri(n,10242,P[s.wrapS]),e.texParameteri(n,10243,P[s.wrapT]),(32879===n||35866===n)&&e.texParameteri(n,32882,P[s.wrapR]),e.texParameteri(n,10240,R[s.magFilter]),e.texParameteri(n,10241,R[s.minFilter])):(e.texParameteri(n,10242,33071),e.texParameteri(n,10243,33071),(32879===n||35866===n)&&e.texParameteri(n,32882,33071),(1001!==s.wrapS||1001!==s.wrapT)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,10240,M(s.magFilter)),e.texParameteri(n,10241,M(s.minFilter)),1003!==s.minFilter&&1006!==s.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){const o=t.get("EXT_texture_filter_anisotropic");if(1015===s.type&&!1===t.has("OES_texture_float_linear")||!1===a&&1016===s.type&&!1===t.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(e.texParameterf(n,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function k(t,n){let r=!1;void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",A));const i=n.source;let s=g.get(i);void 0===s&&(s={},g.set(i,s));const a=function(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.encoding),t.join()}(n);if(a!==t.__cacheKey){void 0===s[a]&&(s[a]={texture:e.createTexture(),usedTimes:0},o.memory.textures++,r=!0),s[a].usedTimes++;const i=s[t.__cacheKey];void 0!==i&&(s[t.__cacheKey].usedTimes--,0===i.usedTimes&&T(n)),t.__cacheKey=a,t.__webglTexture=s[a].texture}return r}function N(t,r,i){let o=3553;r.isDataArrayTexture&&(o=35866),r.isData3DTexture&&(o=32879);const l=k(t,r),c=r.source;if(n.activeTexture(33984+i),n.bindTexture(o,t.__webglTexture),c.version!==c.__currentVersion||!0===l){e.pixelStorei(37440,r.flipY),e.pixelStorei(37441,r.premultiplyAlpha),e.pixelStorei(3317,r.unpackAlignment),e.pixelStorei(37443,0);const t=function(e){return!a&&(1001!==e.wrapS||1001!==e.wrapT||1003!==e.minFilter&&1006!==e.minFilter)}(r)&&!1===w(r.image);let i=v(r.image,t,!1,h);i=H(r,i);const u=w(i)||a,d=s.convert(r.format,r.encoding);let p,f=s.convert(r.type),m=E(r.internalFormat,d,f,r.encoding,r.isVideoTexture);D(o,r,u);const g=r.mipmaps,y=a&&!0!==r.isVideoTexture,b=void 0===c.__currentVersion||!0===l,M=S(r,i,u);if(r.isDepthTexture)m=6402,a?m=1015===r.type?36012:1014===r.type?33190:1020===r.type?35056:33189:1015===r.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===r.format&&6402===m&&1012!==r.type&&1014!==r.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=1014,f=s.convert(r.type)),1027===r.format&&6402===m&&(m=34041,1020!==r.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=1020,f=s.convert(r.type))),b&&(y?n.texStorage2D(3553,1,m,i.width,i.height):n.texImage2D(3553,0,m,i.width,i.height,0,d,f,null));else if(r.isDataTexture)if(g.length>0&&u){y&&b&&n.texStorage2D(3553,M,m,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)p=g[e],y?n.texSubImage2D(3553,e,0,0,p.width,p.height,d,f,p.data):n.texImage2D(3553,e,m,p.width,p.height,0,d,f,p.data);r.generateMipmaps=!1}else y?(b&&n.texStorage2D(3553,M,m,i.width,i.height),n.texSubImage2D(3553,0,0,0,i.width,i.height,d,f,i.data)):n.texImage2D(3553,0,m,i.width,i.height,0,d,f,i.data);else if(r.isCompressedTexture){y&&b&&n.texStorage2D(3553,M,m,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)p=g[e],1023!==r.format?null!==d?y?n.compressedTexSubImage2D(3553,e,0,0,p.width,p.height,d,p.data):n.compressedTexImage2D(3553,e,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):y?n.texSubImage2D(3553,e,0,0,p.width,p.height,d,f,p.data):n.texImage2D(3553,e,m,p.width,p.height,0,d,f,p.data)}else if(r.isDataArrayTexture)y?(b&&n.texStorage3D(35866,M,m,i.width,i.height,i.depth),n.texSubImage3D(35866,0,0,0,0,i.width,i.height,i.depth,d,f,i.data)):n.texImage3D(35866,0,m,i.width,i.height,i.depth,0,d,f,i.data);else if(r.isData3DTexture)y?(b&&n.texStorage3D(32879,M,m,i.width,i.height,i.depth),n.texSubImage3D(32879,0,0,0,0,i.width,i.height,i.depth,d,f,i.data)):n.texImage3D(32879,0,m,i.width,i.height,i.depth,0,d,f,i.data);else if(r.isFramebufferTexture){if(b)if(y)n.texStorage2D(3553,M,m,i.width,i.height);else{let e=i.width,t=i.height;for(let r=0;r<M;r++)n.texImage2D(3553,r,m,e,t,0,d,f,null),e>>=1,t>>=1}}else if(g.length>0&&u){y&&b&&n.texStorage2D(3553,M,m,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)p=g[e],y?n.texSubImage2D(3553,e,0,0,d,f,p):n.texImage2D(3553,e,m,d,f,p);r.generateMipmaps=!1}else y?(b&&n.texStorage2D(3553,M,m,i.width,i.height),n.texSubImage2D(3553,0,0,0,d,f,i)):n.texImage2D(3553,0,m,d,f,i);x(r,u)&&_(o),c.__currentVersion=c.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}function F(t,i,o,a,l){const c=s.convert(o.format,o.encoding),h=s.convert(o.type),u=E(o.internalFormat,c,h,o.encoding);r.get(i).__hasExternalTextures||(32879===l||35866===l?n.texImage3D(l,0,u,i.width,i.height,i.depth,0,c,h,null):n.texImage2D(l,0,u,i.width,i.height,0,c,h,null)),n.bindFramebuffer(36160,t),U(i)?d.framebufferTexture2DMultisampleEXT(36160,a,l,r.get(o).__webglTexture,0,z(i)):e.framebufferTexture2D(36160,a,l,r.get(o).__webglTexture,0),n.bindFramebuffer(36160,null)}function O(t,n,r){if(e.bindRenderbuffer(36161,t),n.depthBuffer&&!n.stencilBuffer){let i=33189;if(r||U(n)){const t=n.depthTexture;t&&t.isDepthTexture&&(1015===t.type?i=36012:1014===t.type&&(i=33190));const r=z(n);U(n)?d.renderbufferStorageMultisampleEXT(36161,r,i,n.width,n.height):e.renderbufferStorageMultisample(36161,r,i,n.width,n.height)}else e.renderbufferStorage(36161,i,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){const i=z(n);r&&!1===U(n)?e.renderbufferStorageMultisample(36161,i,35056,n.width,n.height):U(n)?d.renderbufferStorageMultisampleEXT(36161,i,35056,n.width,n.height):e.renderbufferStorage(36161,34041,n.width,n.height),e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let i=0;i<t.length;i++){const o=t[i],a=s.convert(o.format,o.encoding),l=s.convert(o.type),c=E(o.internalFormat,a,l,o.encoding),h=z(n);r&&!1===U(n)?e.renderbufferStorageMultisample(36161,h,c,n.width,n.height):U(n)?d.renderbufferStorageMultisampleEXT(36161,h,c,n.width,n.height):e.renderbufferStorage(36161,c,n.width,n.height)}}e.bindRenderbuffer(36161,null)}function B(t){const i=r.get(t),s=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture&&!i.__autoAllocateDepthBuffer){if(s)throw Error("target.depthTexture not supported in Cube render targets");!function(t,i){if(i&&i.isWebGLCubeRenderTarget)throw Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,t),!i.depthTexture||!i.depthTexture.isDepthTexture)throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(i.depthTexture).__webglTexture||i.depthTexture.image.width!==i.width||i.depthTexture.image.height!==i.height)&&(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),L(i.depthTexture,0);const s=r.get(i.depthTexture).__webglTexture,o=z(i);if(1026===i.depthTexture.format)U(i)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,s,0,o):e.framebufferTexture2D(36160,36096,3553,s,0);else{if(1027!==i.depthTexture.format)throw Error("Unknown depthTexture format");U(i)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,s,0,o):e.framebufferTexture2D(36160,33306,3553,s,0)}}(i.__webglFramebuffer,t)}else if(s){i.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(36160,i.__webglFramebuffer[r]),i.__webglDepthbuffer[r]=e.createRenderbuffer(),O(i.__webglDepthbuffer[r],t,!1)}else n.bindFramebuffer(36160,i.__webglFramebuffer),i.__webglDepthbuffer=e.createRenderbuffer(),O(i.__webglDepthbuffer,t,!1);n.bindFramebuffer(36160,null)}function z(e){return Math.min(u,e.samples)}function U(e){const n=r.get(e);return a&&e.samples>0&&!0===t.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function H(e,n){const r=e.encoding,i=e.format,s=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||1035===e.format||3e3!==r&&(3001===r?!1===a?!0===t.has("EXT_sRGB")&&1023===i?(e.format=1035,e.minFilter=1006,e.generateMipmaps=!1):n=_A.sRGBToLinear(n):(1023!==i||1009!==s)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),n}this.allocateTextureUnit=function(){const e=I;return e>=l&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+l),I+=1,e},this.resetTextureUnits=function(){I=0},this.setTexture2D=L,this.setTexture2DArray=function(e,t){const i=r.get(e);e.version>0&&i.__version!==e.version?N(i,e,t):(n.activeTexture(33984+t),n.bindTexture(35866,i.__webglTexture))},this.setTexture3D=function(e,t){const i=r.get(e);e.version>0&&i.__version!==e.version?N(i,e,t):(n.activeTexture(33984+t),n.bindTexture(32879,i.__webglTexture))},this.setTextureCube=function(t,i){const o=r.get(t);t.version>0&&o.__version!==t.version?function(t,r,i){if(6!==r.image.length)return;const o=k(t,r),l=r.source;if(n.activeTexture(33984+i),n.bindTexture(34067,t.__webglTexture),l.version!==l.__currentVersion||!0===o){e.pixelStorei(37440,r.flipY),e.pixelStorei(37441,r.premultiplyAlpha),e.pixelStorei(3317,r.unpackAlignment),e.pixelStorei(37443,0);const t=r.isCompressedTexture||r.image[0].isCompressedTexture,i=r.image[0]&&r.image[0].isDataTexture,h=[];for(let e=0;e<6;e++)h[e]=t||i?i?r.image[e].image:r.image[e]:v(r.image[e],!1,!0,c),h[e]=H(r,h[e]);const u=h[0],d=w(u)||a,p=s.convert(r.format,r.encoding),f=s.convert(r.type),m=E(r.internalFormat,p,f,r.encoding),g=a&&!0!==r.isVideoTexture,y=void 0===l.__currentVersion||!0===o;let b,M=S(r,u,d);if(D(34067,r,d),t){g&&y&&n.texStorage2D(34067,M,m,u.width,u.height);for(let e=0;e<6;e++){b=h[e].mipmaps;for(let t=0;t<b.length;t++){const i=b[t];1023!==r.format?null!==p?g?n.compressedTexSubImage2D(34069+e,t,0,0,i.width,i.height,p,i.data):n.compressedTexImage2D(34069+e,t,m,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(34069+e,t,0,0,i.width,i.height,p,f,i.data):n.texImage2D(34069+e,t,m,i.width,i.height,0,p,f,i.data)}}}else{b=r.mipmaps,g&&y&&(b.length>0&&M++,n.texStorage2D(34067,M,m,h[0].width,h[0].height));for(let e=0;e<6;e++)if(i){g?n.texSubImage2D(34069+e,0,0,0,h[e].width,h[e].height,p,f,h[e].data):n.texImage2D(34069+e,0,m,h[e].width,h[e].height,0,p,f,h[e].data);for(let t=0;t<b.length;t++){const r=b[t].image[e].image;g?n.texSubImage2D(34069+e,t+1,0,0,r.width,r.height,p,f,r.data):n.texImage2D(34069+e,t+1,m,r.width,r.height,0,p,f,r.data)}}else{g?n.texSubImage2D(34069+e,0,0,0,p,f,h[e]):n.texImage2D(34069+e,0,m,p,f,h[e]);for(let t=0;t<b.length;t++){const r=b[t];g?n.texSubImage2D(34069+e,t+1,0,0,p,f,r.image[e]):n.texImage2D(34069+e,t+1,m,p,f,r.image[e])}}}x(r,d)&&_(34067),l.__currentVersion=l.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}(o,t,i):(n.activeTexture(33984+i),n.bindTexture(34067,o.__webglTexture))},this.rebindTextures=function(e,t,n){const i=r.get(e);void 0!==t&&F(i.__webglFramebuffer,e,e.texture,36064,3553),void 0!==n&&B(e)},this.setupRenderTarget=function(t){const l=t.texture,c=r.get(t),h=r.get(l);t.addEventListener("dispose",C),!0!==t.isWebGLMultipleRenderTargets&&(void 0===h.__webglTexture&&(h.__webglTexture=e.createTexture()),h.__version=l.version,o.memory.textures++);const u=!0===t.isWebGLCubeRenderTarget,d=!0===t.isWebGLMultipleRenderTargets,p=w(t)||a;if(u){c.__webglFramebuffer=[];for(let t=0;t<6;t++)c.__webglFramebuffer[t]=e.createFramebuffer()}else{if(c.__webglFramebuffer=e.createFramebuffer(),d)if(i.drawBuffers){const n=t.texture;for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);void 0===i.__webglTexture&&(i.__webglTexture=e.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&t.samples>0&&!1===U(t)){const r=d?l:[l];c.__webglMultisampledFramebuffer=e.createFramebuffer(),c.__webglColorRenderbuffer=[],n.bindFramebuffer(36160,c.__webglMultisampledFramebuffer);for(let n=0;n<r.length;n++){const i=r[n];c.__webglColorRenderbuffer[n]=e.createRenderbuffer(),e.bindRenderbuffer(36161,c.__webglColorRenderbuffer[n]);const o=s.convert(i.format,i.encoding),a=s.convert(i.type),l=E(i.internalFormat,o,a,i.encoding),h=z(t);e.renderbufferStorageMultisample(36161,h,l,t.width,t.height),e.framebufferRenderbuffer(36160,36064+n,36161,c.__webglColorRenderbuffer[n])}e.bindRenderbuffer(36161,null),t.depthBuffer&&(c.__webglDepthRenderbuffer=e.createRenderbuffer(),O(c.__webglDepthRenderbuffer,t,!0)),n.bindFramebuffer(36160,null)}}if(u){n.bindTexture(34067,h.__webglTexture),D(34067,l,p);for(let e=0;e<6;e++)F(c.__webglFramebuffer[e],t,l,36064,34069+e);x(l,p)&&_(34067),n.unbindTexture()}else if(d){const e=t.texture;for(let i=0,s=e.length;i<s;i++){const s=e[i],o=r.get(s);n.bindTexture(3553,o.__webglTexture),D(3553,s,p),F(c.__webglFramebuffer,t,s,36064+i,3553),x(s,p)&&_(3553)}n.unbindTexture()}else{let e=3553;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(a?e=t.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(e,h.__webglTexture),D(e,l,p),F(c.__webglFramebuffer,t,l,36064,e),x(l,p)&&_(e),n.unbindTexture()}t.depthBuffer&&B(t)},this.updateRenderTargetMipmap=function(e){const t=w(e)||a,i=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let s=0,o=i.length;s<o;s++){const o=i[s];if(x(o,t)){const t=e.isWebGLCubeRenderTarget?34067:3553,i=r.get(o).__webglTexture;n.bindTexture(t,i),_(t),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(t){if(a&&t.samples>0&&!1===U(t)){const i=t.isWebGLMultipleRenderTargets?t.texture:[t.texture],s=t.width,o=t.height;let a=16384;const l=[],c=t.stencilBuffer?33306:36096,h=r.get(t),u=!0===t.isWebGLMultipleRenderTargets;if(u)for(let t=0;t<i.length;t++)n.bindFramebuffer(36160,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+t,36161,null),n.bindFramebuffer(36160,h.__webglFramebuffer),e.framebufferTexture2D(36009,36064+t,3553,null,0);n.bindFramebuffer(36008,h.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,h.__webglFramebuffer);for(let n=0;n<i.length;n++){l.push(36064+n),t.depthBuffer&&l.push(c);const d=void 0!==h.__ignoreDepthValues&&h.__ignoreDepthValues;if(!1===d&&(t.depthBuffer&&(a|=256),t.stencilBuffer&&(a|=1024)),u&&e.framebufferRenderbuffer(36008,36064,36161,h.__webglColorRenderbuffer[n]),!0===d&&(e.invalidateFramebuffer(36008,[c]),e.invalidateFramebuffer(36009,[c])),u){const t=r.get(i[n]).__webglTexture;e.framebufferTexture2D(36009,36064,3553,t,0)}e.blitFramebuffer(0,0,s,o,0,0,s,o,a,9728),p&&e.invalidateFramebuffer(36008,l)}if(n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),u)for(let t=0;t<i.length;t++){n.bindFramebuffer(36160,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+t,36161,h.__webglColorRenderbuffer[t]);const s=r.get(i[t]).__webglTexture;n.bindFramebuffer(36160,h.__webglFramebuffer),e.framebufferTexture2D(36009,36064+t,3553,s,0)}n.bindFramebuffer(36009,h.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=B,this.setupFrameBufferTexture=F,this.useMultisampledRTT=U}function yP(e,t,n){const r=n.isWebGL2;return{convert(n,i=null){let s;if(1009===n)return 5121;if(1017===n)return 32819;if(1018===n)return 32820;if(1010===n)return 5120;if(1011===n)return 5122;if(1012===n)return 5123;if(1013===n)return 5124;if(1014===n)return 5125;if(1015===n)return 5126;if(1016===n)return r?5131:(s=t.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(1021===n)return 6406;if(1023===n)return 6408;if(1024===n)return 6409;if(1025===n)return 6410;if(1026===n)return 6402;if(1027===n)return 34041;if(1028===n)return 6403;if(1022===n)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(1035===n)return s=t.get("EXT_sRGB"),null!==s?s.SRGB_ALPHA_EXT:null;if(1029===n)return 36244;if(1030===n)return 33319;if(1031===n)return 33320;if(1033===n)return 36249;if(33776===n||33777===n||33778===n||33779===n)if(3001===i){if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(33776===n)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(33777===n)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(33778===n)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(33779===n)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=t.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(33776===n)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===n)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===n)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===n)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===n||35841===n||35842===n||35843===n){if(s=t.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(35840===n)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===n)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===n)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===n)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===n)return s=t.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(37492===n||37496===n){if(s=t.get("WEBGL_compressed_texture_etc"),null===s)return null;if(37492===n)return 3001===i?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(37496===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(37808===n||37809===n||37810===n||37811===n||37812===n||37813===n||37814===n||37815===n||37816===n||37817===n||37818===n||37819===n||37820===n||37821===n){if(s=t.get("WEBGL_compressed_texture_astc"),null===s)return null;if(37808===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(37816===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===n)return 3001===i?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(36492===n){if(s=t.get("EXT_texture_compression_bptc"),null===s)return null;if(36492===n)return 3001===i?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}return 1020===n?r?34042:(s=t.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0!==e[n]?e[n]:null}}}class bP extends kT{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class vP extends kC{constructor(){super(),this.isGroup=!0,this.type="Group"}}const wP={type:"move"};class xP{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new vP,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new vP,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new RA,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new RA),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new vP,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new RA,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new RA),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,n){let r=null,i=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState){if(l&&e.hand){s=!0;for(const r of e.hand.values()){const e=t.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const e=new vP;e.matrixAutoUpdate=!1,e.visible=!1,l.joints[r.jointName]=e,l.add(e)}const i=l.joints[r.jointName];null!==e&&(i.matrix.fromArray(e.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=e.radius),i.visible=null!==e}const r=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],o=r.position.distanceTo(i.position),a=.02,c=.005;l.inputState.pinching&&o>a+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&o<=a-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==a&&e.gripSpace&&(i=t.getPose(e.gripSpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1));null!==o&&(r=t.getPose(e.targetRaySpace,n),null===r&&null!==i&&(r=i),null!==r&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(wP)))}return null!==o&&(o.visible=null!==r),null!==a&&(a.visible=null!==i),null!==l&&(l.visible=null!==s),this}}class _P extends AA{constructor(e,t,n,r,i,s,o,a,l,c){if(1026!==(c=void 0!==c?c:1026)&&1027!==c)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&1026===c&&(n=1014),void 0===n&&1027===c&&(n=1020),super(null,r,i,s,o,a,c,n,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=void 0!==o?o:1003,this.minFilter=void 0!==a?a:1003,this.flipY=!1,this.generateMipmaps=!1}}class EP extends ZM{constructor(e,t){super();const n=this;let r=null,i=1,s=null,o="local-floor",a=null,l=null,c=null,h=null,u=null,d=null;const p=t.getContextAttributes();let f=null,m=null;const g=[],y=[],b=new kT;b.layers.enable(1),b.viewport=new CA;const v=new kT;v.layers.enable(2),v.viewport=new CA;const w=[b,v],x=new bP;x.layers.enable(1),x.layers.enable(2);let _=null,E=null;function S(e){const t=y.indexOf(e.inputSource);if(-1===t)return;const n=g[t];void 0!==n&&n.dispatchEvent({type:e.type,data:e.inputSource})}function M(){r.removeEventListener("select",S),r.removeEventListener("selectstart",S),r.removeEventListener("selectend",S),r.removeEventListener("squeeze",S),r.removeEventListener("squeezestart",S),r.removeEventListener("squeezeend",S),r.removeEventListener("end",M),r.removeEventListener("inputsourceschange",A);for(let e=0;e<g.length;e++){const t=y[e];null!==t&&(y[e]=null,g[e].disconnect(t))}_=null,E=null,e.setRenderTarget(f),u=null,h=null,c=null,r=null,m=null,P.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function A(e){for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=y.indexOf(n);r>=0&&(y[r]=null,g[r].dispatchEvent({type:"disconnected",data:n}))}for(let t=0;t<e.added.length;t++){const n=e.added[t];let r=y.indexOf(n);if(-1===r){for(let e=0;e<g.length;e++){if(e>=y.length){y.push(n),r=e;break}if(null===y[e]){y[e]=n,r=e;break}}if(-1===r)break}const i=g[r];i&&i.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=e=>{let t=g[e];return void 0===t&&(t=new xP,g[e]=t),t.getTargetRaySpace()},this.getControllerGrip=e=>{let t=g[e];return void 0===t&&(t=new xP,g[e]=t),t.getGripSpace()},this.getHand=e=>{let t=g[e];return void 0===t&&(t=new xP,g[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=e=>{i=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=e=>{o=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=()=>a||s,this.setReferenceSpace=e=>{a=e},this.getBaseLayer=()=>null!==h?h:u,this.getBinding=()=>c,this.getFrame=()=>d,this.getSession=()=>r,this.setSession=async function(l){if(r=l,null!==r){if(f=e.getRenderTarget(),r.addEventListener("select",S),r.addEventListener("selectstart",S),r.addEventListener("selectend",S),r.addEventListener("squeeze",S),r.addEventListener("squeezestart",S),r.addEventListener("squeezeend",S),r.addEventListener("end",M),r.addEventListener("inputsourceschange",A),!0!==p.xrCompatible&&await t.makeXRCompatible(),void 0===r.renderState.layers||!1===e.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||p.antialias,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:i};u=new XRWebGLLayer(r,t,n),r.updateRenderState({baseLayer:u}),m=new TA(u.framebufferWidth,u.framebufferHeight,{format:1023,type:1009,encoding:e.outputEncoding})}else{let n=null,s=null,o=null;p.depth&&(o=p.stencil?35056:33190,n=p.stencil?1027:1026,s=p.stencil?1020:1014);const a={colorFormat:32856,depthFormat:o,scaleFactor:i};c=new XRWebGLBinding(r,t),h=c.createProjectionLayer(a),r.updateRenderState({layers:[h]}),m=new TA(h.textureWidth,h.textureHeight,{format:1023,type:1009,depthTexture:new _P(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:p.stencil,encoding:e.outputEncoding,samples:p.antialias?4:0});e.properties.get(m).__ignoreDepthValues=h.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(1),a=null,s=await r.requestReferenceSpace(o),P.setContext(r),P.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const C=new RA,T=new RA;function I(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=e=>{if(null===r)return;x.near=v.near=b.near=e.near,x.far=v.far=b.far=e.far,(_!==x.near||E!==x.far)&&(r.updateRenderState({depthNear:x.near,depthFar:x.far}),_=x.near,E=x.far);const t=e.parent,n=x.cameras;I(x,t);for(let e=0;e<n.length;e++)I(n[e],t);x.matrixWorld.decompose(x.position,x.quaternion,x.scale),e.position.copy(x.position),e.quaternion.copy(x.quaternion),e.scale.copy(x.scale),e.matrix.copy(x.matrix),e.matrixWorld.copy(x.matrixWorld);const i=e.children;for(let e=0,t=i.length;e<t;e++)i[e].updateMatrixWorld(!0);2===n.length?function(e,t,n){C.setFromMatrixPosition(t.matrixWorld),T.setFromMatrixPosition(n.matrixWorld);const r=C.distanceTo(T),i=t.projectionMatrix.elements,s=n.projectionMatrix.elements,o=i[14]/(i[10]-1),a=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],h=(i[8]-1)/i[0],u=(s[8]+1)/s[0],d=o*h,p=o*u,f=r/(-h+u),m=f*-h;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(m),e.translateZ(f),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const g=o+f,y=a+f,b=d-m,v=p+(r-m),w=l*a/y*g,x=c*a/y*g;e.projectionMatrix.makePerspective(b,v,w,x,g,y)}(x,b,v):x.projectionMatrix.copy(b.projectionMatrix)},this.getCamera=()=>x,this.getFoveation=()=>null!==h?h.fixedFoveation:null!==u?u.fixedFoveation:void 0,this.setFoveation=e=>{null!==h&&(h.fixedFoveation=e),null!==u&&void 0!==u.fixedFoveation&&(u.fixedFoveation=e)};let L=null;const P=new jT;P.setAnimationLoop(function(t,n){if(l=n.getViewerPose(a||s),d=n,null!==l){const t=l.views;null!==u&&(e.setRenderTargetFramebuffer(m,u.framebuffer),e.setRenderTarget(m));let n=!1;t.length!==x.cameras.length&&(x.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const i=t[r];let s=null;if(null!==u)s=u.getViewport(i);else{const t=c.getViewSubImage(h,i);s=t.viewport,0===r&&(e.setRenderTargetTextures(m,t.colorTexture,h.ignoreDepthValues?void 0:t.depthStencilTexture),e.setRenderTarget(m))}let o=w[r];void 0===o&&(o=new kT,o.layers.enable(r),o.viewport=new CA,w[r]=o),o.matrix.fromArray(i.transform.matrix),o.projectionMatrix.fromArray(i.projectionMatrix),o.viewport.set(s.x,s.y,s.width,s.height),0===r&&x.matrix.copy(o.matrix),!0===n&&x.cameras.push(o)}}for(let e=0;e<g.length;e++){const t=y[e],r=g[e];null!==t&&void 0!==r&&r.update(t,n,a||s)}L&&L(t,n),d=null}),this.setAnimationLoop=e=>{L=e},this.dispose=()=>{}}}function SP(e,t){function n(n,r){n.opacity.value=r.opacity,r.color&&n.diffuse.value.copy(r.color),r.emissive&&n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(n.map.value=r.map),r.alphaMap&&(n.alphaMap.value=r.alphaMap),r.bumpMap&&(n.bumpMap.value=r.bumpMap,n.bumpScale.value=r.bumpScale,1===r.side&&(n.bumpScale.value*=-1)),r.displacementMap&&(n.displacementMap.value=r.displacementMap,n.displacementScale.value=r.displacementScale,n.displacementBias.value=r.displacementBias),r.emissiveMap&&(n.emissiveMap.value=r.emissiveMap),r.normalMap&&(n.normalMap.value=r.normalMap,n.normalScale.value.copy(r.normalScale),1===r.side&&n.normalScale.value.negate()),r.specularMap&&(n.specularMap.value=r.specularMap),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest);const i=t.get(r).envMap;if(i&&(n.envMap.value=i,n.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,n.reflectivity.value=r.reflectivity,n.ior.value=r.ior,n.refractionRatio.value=r.refractionRatio),r.lightMap){n.lightMap.value=r.lightMap;const t=!0!==e.physicallyCorrectLights?Math.PI:1;n.lightMapIntensity.value=r.lightMapIntensity*t}let s,o;r.aoMap&&(n.aoMap.value=r.aoMap,n.aoMapIntensity.value=r.aoMapIntensity),r.map?s=r.map:r.specularMap?s=r.specularMap:r.displacementMap?s=r.displacementMap:r.normalMap?s=r.normalMap:r.bumpMap?s=r.bumpMap:r.roughnessMap?s=r.roughnessMap:r.metalnessMap?s=r.metalnessMap:r.alphaMap?s=r.alphaMap:r.emissiveMap?s=r.emissiveMap:r.clearcoatMap?s=r.clearcoatMap:r.clearcoatNormalMap?s=r.clearcoatNormalMap:r.clearcoatRoughnessMap?s=r.clearcoatRoughnessMap:r.iridescenceMap?s=r.iridescenceMap:r.iridescenceThicknessMap?s=r.iridescenceThicknessMap:r.specularIntensityMap?s=r.specularIntensityMap:r.specularColorMap?s=r.specularColorMap:r.transmissionMap?s=r.transmissionMap:r.thicknessMap?s=r.thicknessMap:r.sheenColorMap?s=r.sheenColorMap:r.sheenRoughnessMap&&(s=r.sheenRoughnessMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),n.uvTransform.value.copy(s.matrix)),r.aoMap?o=r.aoMap:r.lightMap&&(o=r.lightMap),void 0!==o&&(o.isWebGLRenderTarget&&(o=o.texture),!0===o.matrixAutoUpdate&&o.updateMatrix(),n.uv2Transform.value.copy(o.matrix))}return{refreshFogUniforms(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms(e,r,i,s,o){r.isMeshBasicMaterial||r.isMeshLambertMaterial?n(e,r):r.isMeshToonMaterial?(n(e,r),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,r)):r.isMeshPhongMaterial?(n(e,r),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,r)):r.isMeshStandardMaterial?(n(e,r),function(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}(e,r),r.isMeshPhysicalMaterial&&function(e,t,n){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap)),t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,1===t.side&&e.clearcoatNormalScale.value.negate())),t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap)),t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=n.texture,e.transmissionSamplerSize.value.set(n.width,n.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor)),e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap)}(e,r,o)):r.isMeshMatcapMaterial?(n(e,r),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,r)):r.isMeshDepthMaterial?n(e,r):r.isMeshDistanceMaterial?(n(e,r),function(e,t){e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,r)):r.isMeshNormalMaterial?n(e,r):r.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,r),r.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,r)):r.isPointsMaterial?function(e,t,n,r){let i;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*r,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest),t.map?i=t.map:t.alphaMap&&(i=t.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),e.uvTransform.value.copy(i.matrix))}(e,r,i,s):r.isSpriteMaterial?function(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}(e,r):r.isShadowMaterial?(e.color.value.copy(r.color),e.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function MP(e,t,n,r){let i={},s={},o=[];const a=n.isWebGL2?e.getParameter(35375):0;function l(e,t,n){const r=e.value;if(void 0===n[t])return n[t]="number"==typeof r?r:r.clone(),!0;if("number"==typeof r){if(n[t]!==r)return n[t]=r,!0}else{const e=n[t];if(!1===e.equals(r))return e.copy(r),!0}return!1}function c(e){const t=e.value,n={boundary:0,storage:0};return"number"==typeof t?(n.boundary=4,n.storage=4):t.isVector2?(n.boundary=8,n.storage=8):t.isVector3||t.isColor?(n.boundary=16,n.storage=12):t.isVector4?(n.boundary=16,n.storage=16):t.isMatrix3?(n.boundary=48,n.storage=48):t.isMatrix4?(n.boundary=64,n.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),n}function h(t){const n=t.target;n.removeEventListener("dispose",h);const r=o.indexOf(n.__bindingPointIndex);o.splice(r,1),e.deleteBuffer(i[n.id]),delete i[n.id],delete s[n.id]}return{bind(e,t){const n=t.program;r.uniformBlockBinding(e,n)},update(n,u){let d=i[n.id];void 0===d&&(function(e){const t=e.uniforms;let n=0;const r=16;let i=0;for(let e=0,s=t.length;e<s;e++){const s=t[e],o=c(s);if(s.__data=new Float32Array(o.storage/Float32Array.BYTES_PER_ELEMENT),s.__offset=n,e>0){i=n%r;0!==i&&r-i-o.boundary<0&&(n+=r-i,s.__offset=n)}n+=o.storage}i=n%r,i>0&&(n+=r-i),e.__size=n,e.__cache={}}(n),d=function(t){const n=function(){for(let e=0;e<a;e++)if(-1===o.indexOf(e))return o.push(e),e;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();t.__bindingPointIndex=n;const r=e.createBuffer(),i=t.__size,s=t.usage;return e.bindBuffer(35345,r),e.bufferData(35345,i,s),e.bindBuffer(35345,null),e.bindBufferBase(35345,n,r),r}(n),i[n.id]=d,n.addEventListener("dispose",h));const p=u.program;r.updateUBOMapping(n,p);const f=t.render.frame;s[n.id]!==f&&(function(t){const n=i[t.id],r=t.uniforms,s=t.__cache;e.bindBuffer(35345,n);for(let t=0,n=r.length;t<n;t++){const n=r[t];if(!0===l(n,t,s)){const t=n.value,r=n.__offset;"number"==typeof t?(n.__data[0]=t,e.bufferSubData(35345,r,n.__data)):(n.value.isMatrix3?(n.__data[0]=n.value.elements[0],n.__data[1]=n.value.elements[1],n.__data[2]=n.value.elements[2],n.__data[3]=n.value.elements[0],n.__data[4]=n.value.elements[3],n.__data[5]=n.value.elements[4],n.__data[6]=n.value.elements[5],n.__data[7]=n.value.elements[0],n.__data[8]=n.value.elements[6],n.__data[9]=n.value.elements[7],n.__data[10]=n.value.elements[8],n.__data[11]=n.value.elements[0]):t.toArray(n.__data),e.bufferSubData(35345,r,n.__data))}}e.bindBuffer(35345,null)}(n),s[n.id]=f)},dispose(){for(const t in i)e.deleteBuffer(i[t]);o=[],i={},s={}}}}function AP(e={}){this.isWebGLRenderer=!0;const t=void 0!==e.canvas?e.canvas:function(){const e=cA("canvas");return e.style.display="block",e}(),n=void 0!==e.context?e.context:null,r=void 0===e.depth||e.depth,i=void 0===e.stencil||e.stencil,s=void 0!==e.antialias&&e.antialias,o=void 0===e.premultipliedAlpha||e.premultipliedAlpha,a=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,l=void 0!==e.powerPreference?e.powerPreference:"default",c=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let h;h=null!==n?n.getContextAttributes().alpha:void 0!==e.alpha&&e.alpha;let u=null,d=null;const p=[],f=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const m=this;let g=!1,y=0,b=0,v=null,w=-1,x=null;const _=new CA,E=new CA;let S=null,M=t.width,A=t.height,C=1,T=null,I=null;const L=new CA(0,0,M,A),P=new CA(0,0,M,A);let R=!1;const D=new WT;let k=!1,N=!1,F=null;const O=new cC,B=new oA,z=new RA,U={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function H(){return null===v?C:1}let q,V,G,W,j,$,K,X,Y,Z,J,Q,ee,te,ne,re,ie,se,oe,ae,le,ce,he,ue,de=n;function pe(e,n){for(let r=0;r<e.length;r++){const i=e[r],s=t.getContext(i,n);if(null!==s)return s}return null}try{const e={alpha:!0,depth:r,stencil:i,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r"+$M),t.addEventListener("webglcontextlost",ge,!1),t.addEventListener("webglcontextrestored",ye,!1),t.addEventListener("webglcontextcreationerror",be,!1),null===de){const t=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&t.shift(),de=pe(t,e),null===de)throw pe(t)?Error("Error creating WebGL context with your selected attributes."):Error("Error creating WebGL context.")}void 0===de.getShaderPrecisionFormat&&(de.getShaderPrecisionFormat=()=>({rangeMin:1,rangeMax:1,precision:1}))}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function fe(){q=new wI(de),V=new tI(de,q,e),q.init(V),ce=new yP(de,q,V),G=new mP(de,q,V),W=new EI,j=new tP,$=new gP(de,q,G,j,V,ce,W),K=new rI(m),X=new vI(m),Y=new $T(de,V),he=new QT(de,q,Y,V),Z=new xI(de,Y,W,he),J=new TI(de,Z,Y,W),oe=new CI(de,V,$),re=new nI(j),Q=new eP(m,K,X,q,V,he,re),ee=new SP(m,j),te=new sP,ne=new uP(q,V),se=new JT(m,K,G,J,h,o),ie=new fP(m,J,V),ue=new MP(de,W,V,G),ae=new eI(de,q,W,V),le=new _I(de,q,W,V),W.programs=Q.programs,m.capabilities=V,m.extensions=q,m.properties=j,m.renderLists=te,m.shadowMap=ie,m.state=G,m.info=W}fe();const me=new EP(m,de);function ge(e){e.preventDefault(),g=!0}function ye(){g=!1;const e=W.autoReset,t=ie.enabled,n=ie.autoUpdate,r=ie.needsUpdate,i=ie.type;fe(),W.autoReset=e,ie.enabled=t,ie.autoUpdate=n,ie.needsUpdate=r,ie.type=i}function be(e){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}function ve(e){const t=e.target;t.removeEventListener("dispose",ve),function(e){(function(e){const t=j.get(e).programs;void 0!==t&&(t.forEach(e=>{Q.releaseProgram(e)}),e.isShaderMaterial&&Q.releaseShaderCache(e))})(e),j.remove(e)}(t)}this.xr=me,this.getContext=()=>de,this.getContextAttributes=()=>de.getContextAttributes(),this.forceContextLoss=()=>{const e=q.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=()=>{const e=q.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=()=>C,this.setPixelRatio=function(e){void 0!==e&&(C=e,this.setSize(M,A,!1))},this.getSize=e=>e.set(M,A),this.setSize=function(e,n,r){me.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(M=e,A=n,t.width=Math.floor(e*C),t.height=Math.floor(n*C),!1!==r&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=e=>e.set(M*C,A*C).floor(),this.setDrawingBufferSize=function(e,n,r){M=e,A=n,C=r,t.width=Math.floor(e*r),t.height=Math.floor(n*r),this.setViewport(0,0,e,n)},this.getCurrentViewport=e=>e.copy(_),this.getViewport=e=>e.copy(L),this.setViewport=(e,t,n,r)=>{e.isVector4?L.set(e.x,e.y,e.z,e.w):L.set(e,t,n,r),G.viewport(_.copy(L).multiplyScalar(C).floor())},this.getScissor=e=>e.copy(P),this.setScissor=(e,t,n,r)=>{e.isVector4?P.set(e.x,e.y,e.z,e.w):P.set(e,t,n,r),G.scissor(E.copy(P).multiplyScalar(C).floor())},this.getScissorTest=()=>R,this.setScissorTest=e=>{G.setScissorTest(R=e)},this.setOpaqueSort=e=>{T=e},this.setTransparentSort=e=>{I=e},this.getClearColor=e=>e.copy(se.getClearColor()),this.setClearColor=function(){se.setClearColor.apply(se,arguments)},this.getClearAlpha=()=>se.getClearAlpha(),this.setClearAlpha=function(){se.setClearAlpha.apply(se,arguments)},this.clear=(e=!0,t=!0,n=!0)=>{let r=0;e&&(r|=16384),t&&(r|=256),n&&(r|=1024),de.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=()=>{t.removeEventListener("webglcontextlost",ge,!1),t.removeEventListener("webglcontextrestored",ye,!1),t.removeEventListener("webglcontextcreationerror",be,!1),te.dispose(),ne.dispose(),j.dispose(),K.dispose(),X.dispose(),J.dispose(),he.dispose(),ue.dispose(),Q.dispose(),me.dispose(),me.removeEventListener("sessionstart",xe),me.removeEventListener("sessionend",_e),F&&(F.dispose(),F=null),Ee.stop()},this.renderBufferDirect=(e,t,n,r,i,s)=>{null===t&&(t=U);const o=i.isMesh&&i.matrixWorld.determinant()<0,a=function(e,t,n,r,i){!0!==t.isScene&&(t=U),$.resetTextureUnits();const s=t.fog,o=r.isMeshStandardMaterial?t.environment:null,a=null===v?m.outputEncoding:!0===v.isXRRenderTarget?v.texture.encoding:3e3,l=(r.isMeshStandardMaterial?X:K).get(r.envMap||o),c=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!r.normalMap&&!!n.attributes.tangent,u=!!n.morphAttributes.position,p=!!n.morphAttributes.normal,f=!!n.morphAttributes.color,g=r.toneMapped?m.toneMapping:0,y=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,b=void 0!==y?y.length:0,_=j.get(r),E=d.state.lights;if(!0===k&&(!0===N||e!==x)){const t=e===x&&r.id===w;re.setState(r,e,t)}let S=!1;r.version===_.__version?(_.needsLights&&_.lightsStateVersion!==E.state.version||_.outputEncoding!==a||i.isInstancedMesh&&!1===_.instancing||!i.isInstancedMesh&&!0===_.instancing||i.isSkinnedMesh&&!1===_.skinning||!i.isSkinnedMesh&&!0===_.skinning||_.envMap!==l||!0===r.fog&&_.fog!==s||void 0!==_.numClippingPlanes&&(_.numClippingPlanes!==re.numPlanes||_.numIntersection!==re.numIntersection)||_.vertexAlphas!==c||_.vertexTangents!==h||_.morphTargets!==u||_.morphNormals!==p||_.morphColors!==f||_.toneMapping!==g||!0===V.isWebGL2&&_.morphTargetsCount!==b)&&(S=!0):(S=!0,_.__version=r.version);let M=_.currentProgram;!0===S&&(M=Te(r,t,i));let T=!1,I=!1,L=!1;const P=M.getUniforms(),R=_.uniforms;if(G.useProgram(M.program)&&(T=!0,I=!0,L=!0),r.id!==w&&(w=r.id,I=!0),T||x!==e){if(P.setValue(de,"projectionMatrix",e.projectionMatrix),V.logarithmicDepthBuffer&&P.setValue(de,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),x!==e&&(x=e,I=!0,L=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const t=P.map.cameraPosition;void 0!==t&&t.setValue(de,z.setFromMatrixPosition(e.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&P.setValue(de,"isOrthographic",!0===e.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||i.isSkinnedMesh)&&P.setValue(de,"viewMatrix",e.matrixWorldInverse)}if(i.isSkinnedMesh){P.setOptional(de,i,"bindMatrix"),P.setOptional(de,i,"bindMatrixInverse");const e=i.skeleton;e&&(V.floatVertexTextures?(null===e.boneTexture&&e.computeBoneTexture(),P.setValue(de,"boneTexture",e.boneTexture,$),P.setValue(de,"boneTextureSize",e.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const D=n.morphAttributes;if((void 0!==D.position||void 0!==D.normal||void 0!==D.color&&!0===V.isWebGL2)&&oe.update(i,n,r,M),(I||_.receiveShadow!==i.receiveShadow)&&(_.receiveShadow=i.receiveShadow,P.setValue(de,"receiveShadow",i.receiveShadow)),I&&(P.setValue(de,"toneMappingExposure",m.toneMappingExposure),_.needsLights&&function(e,t){e.ambientLightColor.needsUpdate=t,e.lightProbe.needsUpdate=t,e.directionalLights.needsUpdate=t,e.directionalLightShadows.needsUpdate=t,e.pointLights.needsUpdate=t,e.pointLightShadows.needsUpdate=t,e.spotLights.needsUpdate=t,e.spotLightShadows.needsUpdate=t,e.rectAreaLights.needsUpdate=t,e.hemisphereLights.needsUpdate=t}(R,L),s&&!0===r.fog&&ee.refreshFogUniforms(R,s),ee.refreshMaterialUniforms(R,r,C,A,F),RL.upload(de,_.uniformsList,R,$)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(RL.upload(de,_.uniformsList,R,$),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&P.setValue(de,"center",i.center),P.setValue(de,"modelViewMatrix",i.modelViewMatrix),P.setValue(de,"normalMatrix",i.normalMatrix),P.setValue(de,"modelMatrix",i.matrixWorld),r.isShaderMaterial||r.isRawShaderMaterial){const e=r.uniformsGroups;for(let t=0,n=e.length;t<n;t++)if(V.isWebGL2){const n=e[t];ue.update(n,M),ue.bind(n,M)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return M}(e,t,n,r,i);G.setMaterial(r,o);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let h=1;!0===r.wireframe&&(l=Z.getWireframeAttribute(n),h=2),he.setup(i,r,a,n,l);let u,p=ae;null!==l&&(u=Y.get(l),p=le,p.setIndex(u));const f=null!==l?l.count:c.count,g=n.drawRange.start*h,y=n.drawRange.count*h,b=null!==s?s.start*h:0,_=null!==s?s.count*h:1/0,E=Math.max(g,b),S=Math.max(0,Math.min(f,g+y,b+_)-1-E+1);if(0!==S){if(i.isMesh)!0===r.wireframe?(G.setLineWidth(r.wireframeLinewidth*H()),p.setMode(1)):p.setMode(4);else if(i.isLine){let e=r.linewidth;void 0===e&&(e=1),G.setLineWidth(e*H()),i.isLineSegments?p.setMode(1):i.isLineLoop?p.setMode(2):p.setMode(3)}else i.isPoints?p.setMode(0):i.isSprite&&p.setMode(4);if(i.isInstancedMesh)p.renderInstances(E,S,i.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);p.renderInstances(E,S,e)}else p.render(E,S)}},this.compile=(e,t)=>{d=ne.get(e),d.init(),f.push(d),e.traverseVisible(e=>{e.isLight&&e.layers.test(t.layers)&&(d.pushLight(e),e.castShadow&&d.pushShadow(e))}),d.setupLights(m.physicallyCorrectLights),e.traverse(t=>{const n=t.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++){Te(n[r],e,t)}else Te(n,e,t)}),f.pop(),d=null};let we=null;function xe(){Ee.stop()}function _e(){Ee.start()}const Ee=new jT;function Se(e,t,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)d.pushLight(e),e.castShadow&&d.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||D.intersectsSprite(e)){r&&z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(O);const t=J.update(e),i=e.material;i.visible&&u.push(e,t,i,n,z.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==W.render.frame&&(e.skeleton.update(),e.skeleton.frame=W.render.frame),!e.frustumCulled||D.intersectsObject(e))){r&&z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(O);const t=J.update(e),i=e.material;if(Array.isArray(i)){const r=t.groups;for(let s=0,o=r.length;s<o;s++){const o=r[s],a=i[o.materialIndex];a&&a.visible&&u.push(e,t,a,n,z.z,o)}}else i.visible&&u.push(e,t,i,n,z.z,null)}const i=e.children;for(let e=0,s=i.length;e<s;e++)Se(i[e],t,n,r)}function Me(e,t,n,r){const i=e.opaque,o=e.transmissive,a=e.transparent;d.setupLightsView(n),o.length>0&&function(e,t,n){const r=V.isWebGL2;null===F&&(F=new TA(1,1,{generateMipmaps:!0,type:q.has("EXT_color_buffer_half_float")?1016:1009,minFilter:1008,samples:r&&!0===s?4:0})),m.getDrawingBufferSize(B),r?F.setSize(B.x,B.y):F.setSize(sA(B.x),sA(B.y));const i=m.getRenderTarget();m.setRenderTarget(F),m.clear();const o=m.toneMapping;m.toneMapping=0,Ae(e,t,n),m.toneMapping=o,$.updateMultisampleRenderTarget(F),$.updateRenderTargetMipmap(F),m.setRenderTarget(i)}(i,t,n),r&&G.viewport(_.copy(r)),i.length>0&&Ae(i,t,n),o.length>0&&Ae(o,t,n),a.length>0&&Ae(a,t,n),G.buffers.depth.setTest(!0),G.buffers.depth.setMask(!0),G.buffers.color.setMask(!0),G.setPolygonOffset(!1)}function Ae(e,t,n){const r=!0===t.isScene?t.overrideMaterial:null;for(let i=0,s=e.length;i<s;i++){const s=e[i],o=s.object,a=s.geometry,l=null===r?s.material:r,c=s.group;o.layers.test(n.layers)&&Ce(o,t,n,a,l,c)}}function Ce(e,t,n,r,i,s){e.onBeforeRender(m,t,n,r,i,s),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),i.onBeforeRender(m,t,n,r,e,s),!0===i.transparent&&2===i.side?(i.side=1,i.needsUpdate=!0,m.renderBufferDirect(n,t,r,i,e,s),i.side=0,i.needsUpdate=!0,m.renderBufferDirect(n,t,r,i,e,s),i.side=2):m.renderBufferDirect(n,t,r,i,e,s),e.onAfterRender(m,t,n,r,i,s)}function Te(e,t,n){!0!==t.isScene&&(t=U);const r=j.get(e),i=d.state.lights,s=d.state.shadowsArray,o=i.state.version,a=Q.getParameters(e,i.state,s,t,n),l=Q.getProgramCacheKey(a);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=(e.isMeshStandardMaterial?X:K).get(e.envMap||r.environment),void 0===c&&(e.addEventListener("dispose",ve),c=new Map,r.programs=c);let h=c.get(l);if(void 0!==h){if(r.currentProgram===h&&r.lightsStateVersion===o)return Ie(e,a),h}else a.uniforms=Q.getUniforms(e),e.onBuild(n,a,m),e.onBeforeCompile(a,m),h=Q.acquireProgram(a,l),c.set(l,h),r.uniforms=a.uniforms;const u=r.uniforms;(!e.isShaderMaterial&&!e.isRawShaderMaterial||!0===e.clipping)&&(u.clippingPlanes=re.uniform),Ie(e,a),r.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),r.lightsStateVersion=o,r.needsLights&&(u.ambientLightColor.value=i.state.ambient,u.lightProbe.value=i.state.probe,u.directionalLights.value=i.state.directional,u.directionalLightShadows.value=i.state.directionalShadow,u.spotLights.value=i.state.spot,u.spotLightShadows.value=i.state.spotShadow,u.rectAreaLights.value=i.state.rectArea,u.ltc_1.value=i.state.rectAreaLTC1,u.ltc_2.value=i.state.rectAreaLTC2,u.pointLights.value=i.state.point,u.pointLightShadows.value=i.state.pointShadow,u.hemisphereLights.value=i.state.hemi,u.directionalShadowMap.value=i.state.directionalShadowMap,u.directionalShadowMatrix.value=i.state.directionalShadowMatrix,u.spotShadowMap.value=i.state.spotShadowMap,u.spotShadowMatrix.value=i.state.spotShadowMatrix,u.pointShadowMap.value=i.state.pointShadowMap,u.pointShadowMatrix.value=i.state.pointShadowMatrix);const p=h.getUniforms(),f=RL.seqWithValue(p.seq,u);return r.currentProgram=h,r.uniformsList=f,h}function Ie(e,t){const n=j.get(e);n.outputEncoding=t.outputEncoding,n.instancing=t.instancing,n.skinning=t.skinning,n.morphTargets=t.morphTargets,n.morphNormals=t.morphNormals,n.morphColors=t.morphColors,n.morphTargetsCount=t.morphTargetsCount,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas,n.vertexTangents=t.vertexTangents,n.toneMapping=t.toneMapping}Ee.setAnimationLoop(function(e){we&&we(e)}),typeof self<"u"&&Ee.setContext(self),this.setAnimationLoop=e=>{we=e,me.setAnimationLoop(e),null===e?Ee.stop():Ee.start()},me.addEventListener("sessionstart",xe),me.addEventListener("sessionend",_e),this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===g)return;!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===me.enabled&&!0===me.isPresenting&&(!0===me.cameraAutoUpdate&&me.updateCamera(t),t=me.getCamera()),!0===e.isScene&&e.onBeforeRender(m,e,t,v),d=ne.get(e,f.length),d.init(),f.push(d),O.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),D.setFromProjectionMatrix(O),N=this.localClippingEnabled,k=re.init(this.clippingPlanes,N,t),u=te.get(e,p.length),u.init(),p.push(u),Se(e,t,0,m.sortObjects),u.finish(),!0===m.sortObjects&&u.sort(T,I),!0===k&&re.beginShadows();const n=d.state.shadowsArray;if(ie.render(n,e,t),!0===k&&re.endShadows(),!0===this.info.autoReset&&this.info.reset(),se.render(u,e),d.setupLights(m.physicallyCorrectLights),t.isArrayCamera){const n=t.cameras;for(let t=0,r=n.length;t<r;t++){const r=n[t];Me(u,e,r,r.viewport)}}else Me(u,e,t);null!==v&&($.updateMultisampleRenderTarget(v),$.updateRenderTargetMipmap(v)),!0===e.isScene&&e.onAfterRender(m,e,t),he.resetDefaultState(),w=-1,x=null,f.pop(),d=f.length>0?f[f.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=()=>y,this.getActiveMipmapLevel=()=>b,this.getRenderTarget=()=>v,this.setRenderTargetTextures=(e,t,n)=>{j.get(e.texture).__webglTexture=t,j.get(e.depthTexture).__webglTexture=n;const r=j.get(e);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0===q.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=(e,t)=>{const n=j.get(e);n.__webglFramebuffer=t,n.__useDefaultFramebuffer=void 0===t},this.setRenderTarget=(e,t=0,n=0)=>{v=e,y=t,b=n;let r=!0;if(e){const t=j.get(e);void 0!==t.__useDefaultFramebuffer?(G.bindFramebuffer(36160,null),r=!1):void 0===t.__webglFramebuffer?$.setupRenderTarget(e):t.__hasExternalTextures&&$.rebindTextures(e,j.get(e.texture).__webglTexture,j.get(e.depthTexture).__webglTexture)}let i=null,s=!1,o=!1;if(e){const n=e.texture;(n.isData3DTexture||n.isDataArrayTexture)&&(o=!0);const r=j.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(i=r[t],s=!0):i=V.isWebGL2&&e.samples>0&&!1===$.useMultisampledRTT(e)?j.get(e).__webglMultisampledFramebuffer:r,_.copy(e.viewport),E.copy(e.scissor),S=e.scissorTest}else _.copy(L).multiplyScalar(C).floor(),E.copy(P).multiplyScalar(C).floor(),S=R;if(G.bindFramebuffer(36160,i)&&V.drawBuffers&&r&&G.drawBuffers(e,i),G.viewport(_),G.scissor(E),G.setScissorTest(S),s){const r=j.get(e.texture);de.framebufferTexture2D(36160,36064,34069+t,r.__webglTexture,n)}else if(o){const r=j.get(e.texture),i=t||0;de.framebufferTextureLayer(36160,36064,r.__webglTexture,n||0,i)}w=-1},this.readRenderTargetPixels=(e,t,n,r,i,s,o)=>{if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=j.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){G.bindFramebuffer(36160,a);try{const o=e.texture,a=o.format,l=o.type;if(1023!==a&&ce.convert(a)!==de.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=1016===l&&(q.has("EXT_color_buffer_half_float")||V.isWebGL2&&q.has("EXT_color_buffer_float"));if(!(1009===l||ce.convert(l)===de.getParameter(35738)||1015===l&&(V.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-r&&n>=0&&n<=e.height-i&&de.readPixels(t,n,r,i,ce.convert(a),ce.convert(l),s)}finally{const e=null!==v?j.get(v).__webglFramebuffer:null;G.bindFramebuffer(36160,e)}}},this.copyFramebufferToTexture=(e,t,n=0)=>{const r=Math.pow(2,-n),i=Math.floor(t.image.width*r),s=Math.floor(t.image.height*r);$.setTexture2D(t,0),de.copyTexSubImage2D(3553,n,0,0,e.x,e.y,i,s),G.unbindTexture()},this.copyTextureToTexture=(e,t,n,r=0)=>{const i=t.image.width,s=t.image.height,o=ce.convert(n.format),a=ce.convert(n.type);$.setTexture2D(n,0),de.pixelStorei(37440,n.flipY),de.pixelStorei(37441,n.premultiplyAlpha),de.pixelStorei(3317,n.unpackAlignment),t.isDataTexture?de.texSubImage2D(3553,r,e.x,e.y,i,s,o,a,t.image.data):t.isCompressedTexture?de.compressedTexSubImage2D(3553,r,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,o,t.mipmaps[0].data):de.texSubImage2D(3553,r,e.x,e.y,o,a,t.image),0===r&&n.generateMipmaps&&de.generateMipmap(3553),G.unbindTexture()},this.copyTextureToTexture3D=(e,t,n,r,i=0)=>{if(m.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=e.max.x-e.min.x+1,o=e.max.y-e.min.y+1,a=e.max.z-e.min.z+1,l=ce.convert(r.format),c=ce.convert(r.type);let h;if(r.isData3DTexture)$.setTexture3D(r,0),h=32879;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");$.setTexture2DArray(r,0),h=35866}de.pixelStorei(37440,r.flipY),de.pixelStorei(37441,r.premultiplyAlpha),de.pixelStorei(3317,r.unpackAlignment);const u=de.getParameter(3314),d=de.getParameter(32878),p=de.getParameter(3316),f=de.getParameter(3315),g=de.getParameter(32877),y=n.isCompressedTexture?n.mipmaps[0]:n.image;de.pixelStorei(3314,y.width),de.pixelStorei(32878,y.height),de.pixelStorei(3316,e.min.x),de.pixelStorei(3315,e.min.y),de.pixelStorei(32877,e.min.z),n.isDataTexture||n.isData3DTexture?de.texSubImage3D(h,i,t.x,t.y,t.z,s,o,a,l,c,y.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),de.compressedTexSubImage3D(h,i,t.x,t.y,t.z,s,o,a,l,y.data)):de.texSubImage3D(h,i,t.x,t.y,t.z,s,o,a,l,c,y),de.pixelStorei(3314,u),de.pixelStorei(32878,d),de.pixelStorei(3316,p),de.pixelStorei(3315,f),de.pixelStorei(32877,g),0===i&&r.generateMipmaps&&de.generateMipmap(h),G.unbindTexture()},this.initTexture=e=>{e.isCubeTexture?$.setTextureCube(e,0):e.isData3DTexture?$.setTexture3D(e,0):e.isDataArrayTexture?$.setTexture2DArray(e,0):$.setTexture2D(e,0),G.unbindTexture()},this.resetState=()=>{y=0,b=0,v=null,G.reset(),he.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}(class extends AP{}).prototype.isWebGL1Renderer=!0;class CP extends kC{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}class TP extends AA{constructor(e,t,n,r,i,s,o,a,l){super(e,t,n,r,i,s,o,a,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class IP extends lT{constructor(e=1,t=1,n=1,r=8,i=1,s=!1,o=0,a=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:o,thetaLength:a};const l=this;r=Math.floor(r),i=Math.floor(i);const c=[],h=[],u=[],d=[];let p=0;const f=[],m=n/2;let g=0;function y(n){const i=p,s=new oA,f=new RA;let y=0;const b=!0===n?e:t,v=!0===n?1:-1;for(let e=1;e<=r;e++)h.push(0,m*v,0),u.push(0,v,0),d.push(.5,.5),p++;const w=p;for(let e=0;e<=r;e++){const t=e/r*a+o,n=Math.cos(t),i=Math.sin(t);f.x=b*i,f.y=m*v,f.z=b*n,h.push(f.x,f.y,f.z),u.push(0,v,0),s.x=.5*n+.5,s.y=.5*i*v+.5,d.push(s.x,s.y),p++}for(let e=0;e<r;e++){const t=i+e,r=w+e;!0===n?c.push(r,r+1,t):c.push(r+1,r,t),y+=3}l.addGroup(g,y,!0===n?1:2),g+=y}(function(){const s=new RA,y=new RA;let b=0;const v=(t-e)/n;for(let l=0;l<=i;l++){const c=[],g=l/i,b=g*(t-e)+e;for(let e=0;e<=r;e++){const t=e/r,i=t*a+o,l=Math.sin(i),f=Math.cos(i);y.x=b*l,y.y=-g*n+m,y.z=b*f,h.push(y.x,y.y,y.z),s.set(l,v,f).normalize(),u.push(s.x,s.y,s.z),d.push(t,1-g),c.push(p++)}f.push(c)}for(let e=0;e<r;e++)for(let t=0;t<i;t++){const n=f[t][e],r=f[t+1][e],i=f[t+1][e+1],s=f[t][e+1];c.push(n,r,s),c.push(r,i,s),b+=6}l.addGroup(g,b,0),g+=b})(),!1===s&&(e>0&&y(!0),t>0&&y(!1)),this.setIndex(c),this.setAttribute("position",new eT(h,3)),this.setAttribute("normal",new eT(u,3)),this.setAttribute("uv",new eT(d,2))}static fromJSON(e){return new IP(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class LP extends $C{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new wA(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class PP extends $C{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new wA(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new oA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class RP extends $C{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new wA(16777215),this.specular=new wA(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new oA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class DP extends kC{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new wA(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}class kP extends DP{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(kC.DefaultUp),this.updateMatrix(),this.groundColor=new wA(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const NP=new cC,FP=new RA,OP=new RA;class BP{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new oA(512,512),this.map=null,this.mapPass=null,this.matrix=new cC,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new WT,this._frameExtents=new oA(1,1),this._viewportCount=1,this._viewports=[new CA(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;FP.setFromMatrixPosition(e.matrixWorld),t.position.copy(FP),OP.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(OP),t.updateMatrixWorld(),NP.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(NP),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class zP extends BP{constructor(){super(new kT(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=2*eA*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;(n!==t.fov||r!==t.aspect||i!==t.far)&&(t.fov=n,t.aspect=r,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class UP extends DP{constructor(e,t,n=0,r=Math.PI/3,i=0,s=1){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(kC.DefaultUp),this.updateMatrix(),this.target=new kC,this.distance=n,this.angle=r,this.penumbra=i,this.decay=s,this.shadow=new zP}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:$M}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=$M);class HP{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new VP);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new VP);const n=this.elements,r=e.x,i=e.y,s=e.z;return t.x=n[0]*r+n[1]*i+n[2]*s,t.y=n[3]*r+n[4]*i+n[5]*s,t.z=n[6]*r+n[7]*i+n[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new HP);const n=this.elements,r=e.elements,i=t.elements,s=n[0],o=n[1],a=n[2],l=n[3],c=n[4],h=n[5],u=n[6],d=n[7],p=n[8],f=r[0],m=r[1],g=r[2],y=r[3],b=r[4],v=r[5],w=r[6],x=r[7],_=r[8];return i[0]=s*f+o*y+a*w,i[1]=s*m+o*b+a*x,i[2]=s*g+o*v+a*_,i[3]=l*f+c*y+h*w,i[4]=l*m+c*b+h*x,i[5]=l*g+c*v+h*_,i[6]=u*f+d*y+p*w,i[7]=u*m+d*b+p*x,i[8]=u*g+d*v+p*_,t}scale(e,t){void 0===t&&(t=new HP);const n=this.elements,r=t.elements;for(let t=0;3!==t;t++)r[3*t+0]=e.x*n[3*t+0],r[3*t+1]=e.y*n[3*t+1],r[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new VP);const n=[];let r,i;for(r=0;r<12;r++)n.push(0);for(r=0;r<3;r++)for(i=0;i<3;i++)n[r+4*i]=this.elements[r+3*i];n[3]=e.x,n[7]=e.y,n[11]=e.z;let s=3;const o=s;let a;let l;do{if(r=o-s,0===n[r+4*r])for(i=r+1;i<o;i++)if(0!==n[r+4*i]){a=4;do{l=4-a,n[l+4*r]+=n[l+4*i]}while(--a);break}if(0!==n[r+4*r])for(i=r+1;i<o;i++){const e=n[r+4*i]/n[r+4*r];a=4;do{l=4-a,n[l+4*i]=l<=r?0:n[l+4*i]-n[l+4*r]*e}while(--a)}}while(--s);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new HP);const t=qP;let n,r;for(n=0;n<3;n++)for(r=0;r<3;r++)t[n+6*r]=this.elements[n+3*r];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let i=3;const s=i;let o;let a;do{if(n=s-i,0===t[n+6*n])for(r=n+1;r<s;r++)if(0!==t[n+6*r]){o=6;do{a=6-o,t[a+6*n]+=t[a+6*r]}while(--o);break}if(0!==t[n+6*n])for(r=n+1;r<s;r++){const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=a<=n?0:t[a+6*r]-t[a+6*n]*e}while(--o)}}while(--i);n=2;do{r=n-1;do{const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=t[a+6*r]-t[a+6*n]*e}while(--o)}while(r--)}while(--n);n=2;do{const e=1/t[n+6*n];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]*e}while(--o)}while(n--);n=2;do{r=2;do{if(a=t[3+r+6*n],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,r,a)}while(r--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,r=e.z,i=e.w,s=t+t,o=n+n,a=r+r,l=t*s,c=t*o,h=t*a,u=n*o,d=n*a,p=r*a,f=i*s,m=i*o,g=i*a,y=this.elements;return y[0]=1-(u+p),y[1]=c-g,y[2]=h+m,y[3]=c+g,y[4]=1-(l+p),y[5]=d-f,y[6]=h-m,y[7]=d+f,y[8]=1-(l+u),this}transpose(e){void 0===e&&(e=new HP);const t=this.elements,n=e.elements;let r;return n[0]=t[0],n[4]=t[4],n[8]=t[8],r=t[1],n[1]=t[3],n[3]=r,r=t[2],n[2]=t[6],n[6]=r,r=t[5],n[5]=t[7],n[7]=r,e}}const qP=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class VP{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new VP);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z;return t.x=o*i-a*r,t.y=a*n-s*i,t.z=s*r-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new VP(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new VP(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new HP([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,r=Math.sqrt(e*e+t*t+n*n);if(r>0){const e=1/r;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return r}unit(e){void 0===e&&(e=new VP);const t=this.x,n=this.y,r=this.z;let i=Math.sqrt(t*t+n*n+r*r);return i>0?(i=1/i,e.x=t*i,e.y=n*i,e.z=r*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return Math.sqrt((i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r))}distanceSquared(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return(i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r)}scale(e,t){void 0===t&&(t=new VP);const n=this.x,r=this.y,i=this.z;return t.x=e*n,t.y=e*r,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new VP),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new VP),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new VP),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const r=GP,i=1/n;r.set(this.x*i,this.y*i,this.z*i);const s=WP;Math.abs(r.x)<.9?(s.set(1,0,0),r.cross(s,e)):(s.set(0,1,0),r.cross(s,e)),r.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const r=this.x,i=this.y,s=this.z;n.x=r+(e.x-r)*t,n.y=i+(e.y-i)*t,n.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(jP),jP.almostEquals(e,t)}clone(){return new VP(this.x,this.y,this.z)}}VP.ZERO=new VP(0,0,0),VP.UNIT_X=new VP(1,0,0),VP.UNIT_Y=new VP(0,1,0),VP.UNIT_Z=new VP(0,0,1);const GP=new VP,WP=new VP,jP=new VP;class $P{constructor(e){void 0===e&&(e={}),this.lowerBound=new VP,this.upperBound=new VP,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,r){const i=this.lowerBound,s=this.upperBound,o=n;i.copy(e[0]),o&&o.vmult(i,i),s.copy(i);for(let t=1;t<e.length;t++){let n=e[t];o&&(o.vmult(n,KP),n=KP),n.x>s.x&&(s.x=n.x),n.x<i.x&&(i.x=n.x),n.y>s.y&&(s.y=n.y),n.y<i.y&&(i.y=n.y),n.z>s.z&&(s.z=n.z),n.z<i.z&&(i.z=n.z)}return t&&(t.vadd(i,i),t.vadd(s,s)),r&&(i.x-=r,i.y-=r,i.z-=r,s.x+=r,s.y+=r,s.z+=r),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new $P).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound,s=r.x<=n.x&&n.x<=i.x||t.x<=i.x&&i.x<=n.x,o=r.y<=n.y&&n.y<=i.y||t.y<=i.y&&i.y<=n.y,a=r.z<=n.z&&n.z<=i.z||t.z<=i.z&&i.z<=n.z;return s&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound;return t.x<=r.x&&n.x>=i.x&&t.y<=r.y&&n.y>=i.y&&t.z<=r.z&&n.z>=i.z}getCorners(e,t,n,r,i,s,o,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),n.set(c.x,c.y,l.z),r.set(l.x,c.y,c.z),i.set(c.x,l.y,c.z),s.set(l.x,c.y,l.z),o.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const n=XP,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],h=n[7];this.getCorners(r,i,s,o,a,l,c,h);for(let t=0;8!==t;t++){const r=n[t];e.pointToLocal(r,r)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=XP,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],h=n[7];this.getCorners(r,i,s,o,a,l,c,h);for(let t=0;8!==t;t++){const r=n[t];e.pointToWorld(r,r)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,r=1/t.x,i=1/t.y,s=1/t.z,o=(this.lowerBound.x-n.x)*r,a=(this.upperBound.x-n.x)*r,l=(this.lowerBound.y-n.y)*i,c=(this.upperBound.y-n.y)*i,h=(this.lowerBound.z-n.z)*s,u=(this.upperBound.z-n.z)*s,d=Math.max(Math.max(Math.min(o,a),Math.min(l,c)),Math.min(h,u)),p=Math.min(Math.min(Math.max(o,a),Math.max(l,c)),Math.max(h,u));return!(p<0||d>p)}}const KP=new VP,XP=[new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP];class YP{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:r}=t;if(r>n){const e=r;r=n,n=e}return this.matrix[(n*(n+1)>>1)+r-1]}set(e,t,n){let{index:r}=e,{index:i}=t;if(i>r){const e=i;i=r,r=e}this.matrix[(r*(r+1)>>1)+i-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class ZP{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const r=n[e].indexOf(t);return-1!==r&&n[e].splice(r,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,r=t.length;n<r;n++)t[n].call(this,e)}return this}}class JP{constructor(e,t,n,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===r&&(r=1),this.x=e,this.y=t,this.z=n,this.w=r}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new VP),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=QP,n=eR;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new JP);const n=this.x,r=this.y,i=this.z,s=this.w,o=e.x,a=e.y,l=e.z,c=e.w;return t.x=n*c+s*o+r*l-i*a,t.y=r*c+s*a+i*o-n*l,t.z=i*c+s*l+n*a-r*o,t.w=s*c-n*o-r*a-i*l,t}inverse(e){void 0===e&&(e=new JP);const t=this.x,n=this.y,r=this.z,i=this.w;this.conjugate(e);const s=1/(t*t+n*n+r*r+i*i);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new JP),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new VP);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z,l=this.w,c=l*n+o*i-a*r,h=l*r+a*n-s*i,u=l*i+s*r-o*n,d=-s*n-o*r-a*i;return t.x=c*l+d*-s+h*-a-u*-o,t.y=h*l+d*-o+u*-s-c*-a,t.z=u*l+d*-a+c*-o-h*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,r,i;void 0===t&&(t="YZX");const s=this.x,o=this.y,a=this.z,l=this.w;if("YZX"!==t)throw Error(`Euler order ${t} not supported yet.`);{const e=s*o+a*l;if(e>.499&&(n=2*Math.atan2(s,l),r=Math.PI/2,i=0),e<-.499&&(n=-2*Math.atan2(s,l),r=-Math.PI/2,i=0),void 0===n){const t=s*s,c=a*a;n=Math.atan2(2*o*l-2*s*a,1-2*(o*o)-2*c),r=Math.asin(2*e),i=Math.atan2(2*s*l-2*o*a,1-2*t-2*c)}}e.y=n,e.z=r,e.x=i}setFromEuler(e,t,n,r){void 0===r&&(r="XYZ");const i=Math.cos(e/2),s=Math.cos(t/2),o=Math.cos(n/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(n/2);return"XYZ"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o-a*l*c):"YXZ"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o+a*l*c):"ZXY"===r?(this.x=a*s*o-i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o-a*l*c):"ZYX"===r?(this.x=a*s*o-i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o+a*l*c):"YZX"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o-a*l*c):"XZY"===r&&(this.x=a*s*o-i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o+a*l*c),this}clone(){return new JP(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new JP);const r=this.x,i=this.y,s=this.z,o=this.w;let a,l,c,h,u,d=e.x,p=e.y,f=e.z,m=e.w;return l=r*d+i*p+s*f+o*m,l<0&&(l=-l,d=-d,p=-p,f=-f,m=-m),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),h=Math.sin((1-t)*a)/c,u=Math.sin(t*a)/c):(h=1-t,u=t),n.x=h*r+u*d,n.y=h*i+u*p,n.z=h*s+u*f,n.w=h*o+u*m,n}integrate(e,t,n,r){void 0===r&&(r=new JP);const i=e.x*n.x,s=e.y*n.y,o=e.z*n.z,a=this.x,l=this.y,c=this.z,h=this.w,u=.5*t;return r.x+=u*(i*h+s*c-o*l),r.y+=u*(s*h+o*a-i*c),r.z+=u*(o*h+i*l-s*a),r.w+=u*(-i*a-s*l-o*c),r}}const QP=new VP,eR=new VP;class tR{constructor(e){void 0===e&&(e={}),this.id=tR.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw"computeBoundingSphereRadius() not implemented for shape type "+this.type}volume(){throw"volume() not implemented for shape type "+this.type}calculateLocalInertia(e,t){throw"calculateLocalInertia() not implemented for shape type "+this.type}calculateWorldAABB(e,t,n,r){throw"calculateWorldAABB() not implemented for shape type "+this.type}}tR.idCounter=0,tR.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class nR{constructor(e){void 0===e&&(e={}),this.position=new VP,this.quaternion=new JP,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return nR.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return nR.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new VP),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,r){return void 0===r&&(r=new VP),n.vsub(e,r),t.conjugate(rR),rR.vmult(r,r),r}static pointToWorldFrame(e,t,n,r){return void 0===r&&(r=new VP),t.vmult(n,r),r.vadd(e,r),r}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new VP),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,r){return void 0===r&&(r=new VP),t.w*=-1,t.vmult(n,r),t.w*=-1,r}}const rR=new JP;class iR extends tR{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:r=[],axes:i,boundingSphereRadius:s}=e;super({type:tR.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=r,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const r=new VP;for(let i=0;i!==e.length;i++){const s=e[i],o=s.length;for(let e=0;e!==o;e++){const i=(e+1)%o;t[s[e]].vsub(t[s[i]],r),r.normalize();let a=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(r)||n[e].almostEquals(r)){a=!0;break}a||n.push(r.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new VP;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],r=this.vertices[n[0]],i=this.vertices[n[1]],s=this.vertices[n[2]];iR.computeNormal(r,i,s,t)}static computeNormal(e,t,n,r){const i=new VP,s=new VP;t.vsub(e,s),n.vsub(t,i),i.cross(s,r),r.isZero()||r.normalize()}clipAgainstHull(e,t,n,r,i,s,o,a,l){const c=new VP;let h=-1,u=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){c.copy(n.faceNormals[e]),i.vmult(c,c);const t=c.dot(s);t>u&&(u=t,h=e)}const d=[];for(let e=0;e<n.faces[h].length;e++){const t=n.vertices[n.faces[h][e]],s=new VP;s.copy(t),i.vmult(s,s),r.vadd(s,s),d.push(s)}h>=0&&this.clipFaceAgainstHull(s,e,t,d,o,a,l)}findSeparatingAxis(e,t,n,r,i,s,o,a){const l=new VP,c=new VP,h=new VP,u=new VP,d=new VP,p=new VP;let f=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){n.vmult(m.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,n,r,i);if(!1===a)return!1;a<f&&(f=a,s.copy(l))}else{const a=o?o.length:m.faces.length;for(let c=0;c<a;c++){const a=o?o[c]:c;l.copy(m.faceNormals[a]),n.vmult(l,l);const h=m.testSepAxis(l,e,t,n,r,i);if(!1===h)return!1;h<f&&(f=h,s.copy(l))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){i.vmult(e.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,n,r,i);if(!1===a)return!1;a<f&&(f=a,s.copy(c))}else{const o=a?a.length:e.faces.length;for(let l=0;l<o;l++){const o=a?a[l]:l;c.copy(e.faceNormals[o]),i.vmult(c,c);const h=m.testSepAxis(c,e,t,n,r,i);if(!1===h)return!1;h<f&&(f=h,s.copy(c))}}for(let o=0;o!==m.uniqueEdges.length;o++){n.vmult(m.uniqueEdges[o],u);for(let o=0;o!==e.uniqueEdges.length;o++)if(i.vmult(e.uniqueEdges[o],d),u.cross(d,p),!p.almostZero()){p.normalize();const o=m.testSepAxis(p,e,t,n,r,i);if(!1===o)return!1;o<f&&(f=o,s.copy(p))}}return r.vsub(t,h),h.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,n,r,i,s){iR.project(this,e,n,r,sR),iR.project(t,e,i,s,oR);const o=sR[0],a=sR[1],l=oR[0],c=oR[1];if(o<c||l<a)return!1;const h=o-c,u=l-a;return h<u?h:u}calculateLocalInertia(e,t){const n=new VP,r=new VP;this.computeLocalAABB(r,n);const i=n.x-r.x,s=n.y-r.y,o=n.z-r.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*i*2*i+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],r=this.vertices[t[0]];return-n.dot(r)}clipFaceAgainstHull(e,t,n,r,i,s,o){const a=new VP,l=new VP,c=new VP,h=new VP,u=new VP,d=new VP,p=new VP,f=new VP,m=this,g=r,y=[];let b=-1,v=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),n.vmult(a,a);const r=a.dot(e);r<v&&(v=r,b=t)}if(b<0)return;const w=m.faces[b];w.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==w.indexOf(m.faces[e][t])&&e!==b&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const x=w.length;for(let e=0;e<x;e++){const r=m.vertices[w[e]],i=m.vertices[w[(e+1)%x]];r.vsub(i,l),c.copy(l),n.vmult(c,c),t.vadd(c,c),h.copy(this.faceNormals[b]),n.vmult(h,h),t.vadd(h,h),c.cross(h,u),u.negate(u),d.copy(r),n.vmult(d,d),t.vadd(d,d);const s=w.connectedFaces[e];p.copy(this.faceNormals[s]);const o=this.getPlaneConstantOfFace(s);f.copy(p),n.vmult(f,f);const a=o-f.dot(t);for(this.clipFaceAgainstPlane(g,y,f,a);g.length;)g.shift();for(;y.length;)g.push(y.shift())}p.copy(this.faceNormals[b]);const _=this.getPlaneConstantOfFace(b);f.copy(p),n.vmult(f,f);const E=_-f.dot(t);for(let e=0;e<g.length;e++){let t=f.dot(g[e])+E;if(t<=i&&(t=i),t<=s){const n=g[e];if(t<=1e-6){const e={point:n,normal:f,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,r){let i,s;const o=e.length;if(o<2)return t;let a=e[e.length-1],l=e[0];i=n.dot(a)+r;for(let c=0;c<o;c++){if(l=e[c],s=n.dot(l)+r,i<0)if(s<0){const e=new VP;e.copy(l),t.push(e)}else{const e=new VP;a.lerp(l,i/(i-s),e),t.push(e)}else if(s<0){const e=new VP;a.lerp(l,i/(i-s),e),t.push(e),t.push(l)}a=l,i=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new VP);const n=this.vertices,r=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(n[i],r[i]),e.vadd(r[i],r[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let r=0;r<this.vertices.length;r++){const i=n[r];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new VP);const n=this.faceNormals,r=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(n[i],r[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const r=t[n].lengthSquared();r>e&&(e=r)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,r){const i=this.vertices;let s,o,a,l,c,h,u=new VP;for(let n=0;n<i.length;n++){u.copy(i[n]),t.vmult(u,u),e.vadd(u,u);const r=u;(void 0===s||r.x<s)&&(s=r.x),(void 0===l||r.x>l)&&(l=r.x),(void 0===o||r.y<o)&&(o=r.y),(void 0===c||r.y>c)&&(c=r.y),(void 0===a||r.z<a)&&(a=r.z),(void 0===h||r.z>h)&&(h=r.z)}n.set(s,o,a),r.set(l,c,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new VP);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,r=this.vertices;if(t){for(let e=0;e<n;e++){const n=r[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=r[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,r=this.faceNormals,i=new VP;this.getAveragePointLocal(i);for(let s=0;s<this.faces.length;s++){let o=r[s];const a=t[n[s][0]],l=new VP;e.vsub(a,l);const c=o.dot(l),h=new VP;i.vsub(a,h);const u=o.dot(h);if(c<0&&u>0||c>0&&u<0)return!1}return-1}static project(e,t,n,r,i){const s=e.vertices.length,o=aR;let a=0,l=0;const c=lR,h=e.vertices;c.setZero(),nR.vectorToLocalFrame(n,r,t,o),nR.pointToLocalFrame(n,r,c,c);const u=c.dot(o);l=a=h[0].dot(o);for(let e=1;e<s;e++){const t=h[e].dot(o);t>a&&(a=t),t<l&&(l=t)}if(l-=u,a-=u,l>a){const e=l;l=a,a=e}i[0]=a,i[1]=l}}const sR=[],oR=[];new VP;const aR=new VP,lR=new VP;class cR extends tR{constructor(e){super({type:tR.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,r=VP,i=[new r(-e,-t,-n),new r(e,-t,-n),new r(e,t,-n),new r(-e,t,-n),new r(-e,-t,n),new r(e,-t,n),new r(e,t,n),new r(-e,t,n)],s=[new r(0,0,1),new r(0,1,0),new r(1,0,0)],o=new iR({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new VP),cR.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const r=e;n.x=1/12*t*(2*r.y*2*r.y+2*r.z*2*r.z),n.y=1/12*t*(2*r.x*2*r.x+2*r.z*2*r.z),n.z=1/12*t*(2*r.y*2*r.y+2*r.x*2*r.x)}getSideNormals(e,t){const n=e,r=this.halfExtents;if(n[0].set(r.x,0,0),n[1].set(0,r.y,0),n[2].set(0,0,r.z),n[3].set(-r.x,0,0),n[4].set(0,-r.y,0),n[5].set(0,0,-r.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const r=this.halfExtents,i=[[r.x,r.y,r.z],[-r.x,r.y,r.z],[-r.x,-r.y,r.z],[-r.x,-r.y,-r.z],[r.x,-r.y,-r.z],[r.x,r.y,-r.z],[-r.x,r.y,-r.z],[r.x,-r.y,r.z]];for(let r=0;r<i.length;r++)hR.set(i[r][0],i[r][1],i[r][2]),t.vmult(hR,hR),e.vadd(hR,hR),n(hR.x,hR.y,hR.z)}calculateWorldAABB(e,t,n,r){const i=this.halfExtents;uR[0].set(i.x,i.y,i.z),uR[1].set(-i.x,i.y,i.z),uR[2].set(-i.x,-i.y,i.z),uR[3].set(-i.x,-i.y,-i.z),uR[4].set(i.x,-i.y,-i.z),uR[5].set(i.x,i.y,-i.z),uR[6].set(-i.x,i.y,-i.z),uR[7].set(i.x,-i.y,i.z);const s=uR[0];t.vmult(s,s),e.vadd(s,s),r.copy(s),n.copy(s);for(let i=1;i<8;i++){const s=uR[i];t.vmult(s,s),e.vadd(s,s);const o=s.x,a=s.y,l=s.z;o>r.x&&(r.x=o),a>r.y&&(r.y=a),l>r.z&&(r.z=l),o<n.x&&(n.x=o),a<n.y&&(n.y=a),l<n.z&&(n.z=l)}}}const hR=new VP,uR=[new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP],dR=1,pR=2,fR=4,mR=0,gR=1,yR=2;class bR extends ZP{constructor(e){void 0===e&&(e={}),super(),this.id=bR.idCounter++,this.index=-1,this.world=null,this.vlambda=new VP,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new VP,this.previousPosition=new VP,this.interpolatedPosition=new VP,this.initPosition=new VP,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new VP,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new VP,this.force=new VP;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?bR.STATIC:bR.DYNAMIC,typeof e.type==typeof bR.STATIC&&(this.type=e.type),this.allowSleep=!(typeof e.allowSleep<"u")||e.allowSleep,this.sleepState=bR.AWAKE,this.sleepSpeedLimit=typeof e.sleepSpeedLimit<"u"?e.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof e.sleepTimeLimit<"u"?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new VP,this.quaternion=new JP,this.initQuaternion=new JP,this.previousQuaternion=new JP,this.interpolatedQuaternion=new JP,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new VP,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new VP,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new VP,this.invInertia=new VP,this.invInertiaWorld=new HP,this.invMassSolve=0,this.invInertiaSolve=new VP,this.invInertiaWorldSolve=new HP,this.fixedRotation=typeof e.fixedRotation<"u"&&e.fixedRotation,this.angularDamping=typeof e.angularDamping<"u"?e.angularDamping:.01,this.linearFactor=new VP(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new VP(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new $P,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new VP,this.isTrigger=!!e.isTrigger,e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=bR.AWAKE,this.wakeUpAfterNarrowphase=!1,e===bR.SLEEPING&&this.dispatchEvent(bR.wakeupEvent)}sleep(){this.sleepState=bR.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),r=this.sleepSpeedLimit**2;t===bR.AWAKE&&n<r?(this.sleepState=bR.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(bR.sleepyEvent)):t===bR.SLEEPY&&n>r?this.wakeUp():t===bR.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(bR.sleepEvent))}}updateSolveMassProperties(){this.sleepState===bR.SLEEPING||this.type===bR.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new VP),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new VP),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new VP),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new VP),this.quaternion.vmult(e,t),t}addShape(e,t,n){const r=new VP,i=new JP;return t&&r.copy(t),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(r),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let r=0;for(let i=0;i!==n;i++){const n=e[i];n.updateBoundingSphereRadius();const s=t[i].length(),o=n.boundingSphereRadius;s+o>r&&(r=s+o)}this.boundingRadius=r}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,r=e.length,i=vR,s=wR,o=this.quaternion,a=this.aabb,l=xR;for(let c=0;c!==r;c++){const r=e[c];o.vmult(t[c],i),i.vadd(this.position,i),o.mult(n[c],s),r.calculateWorldAABB(i,s,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=_R,n=ER;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new VP),this.type!==bR.DYNAMIC)return;this.sleepState===bR.SLEEPING&&this.wakeUp();const n=SR;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new VP),this.type!==bR.DYNAMIC)return;const n=MR,r=AR;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyForce(n,r)}applyTorque(e){this.type===bR.DYNAMIC&&(this.sleepState===bR.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new VP),this.type!==bR.DYNAMIC)return;this.sleepState===bR.SLEEPING&&this.wakeUp();const n=t,r=CR;r.copy(e),r.scale(this.invMass,r),this.velocity.vadd(r,this.velocity);const i=TR;n.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new VP),this.type!==bR.DYNAMIC)return;const n=IR,r=LR;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyImpulse(n,r)}updateMassProperties(){const e=PR;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),cR.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new VP;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==bR.DYNAMIC&&this.type!==bR.KINEMATIC||this.sleepState===bR.SLEEPING)return;const r=this.velocity,i=this.angularVelocity,s=this.position,o=this.force,a=this.torque,l=this.quaternion,c=this.invMass,h=this.invInertiaWorld,u=this.linearFactor,d=c*e;r.x+=o.x*d*u.x,r.y+=o.y*d*u.y,r.z+=o.z*d*u.z;const p=h.elements,f=this.angularFactor,m=a.x*f.x,g=a.y*f.y,y=a.z*f.z;i.x+=e*(p[0]*m+p[1]*g+p[2]*y),i.y+=e*(p[3]*m+p[4]*g+p[5]*y),i.z+=e*(p[6]*m+p[7]*g+p[8]*y),s.x+=r.x*e,s.y+=r.y*e,s.z+=r.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}bR.idCounter=0,bR.COLLIDE_EVENT_NAME="collide",bR.DYNAMIC=dR,bR.STATIC=pR,bR.KINEMATIC=fR,bR.AWAKE=mR,bR.SLEEPY=gR,bR.SLEEPING=yR,bR.wakeupEvent={type:"wakeup"},bR.sleepyEvent={type:"sleepy"},bR.sleepEvent={type:"sleep"};const vR=new VP,wR=new JP,xR=new $P,_R=new HP,ER=new HP;new HP;const SR=new VP,MR=new VP,AR=new VP,CR=new VP,TR=new VP,IR=new VP,LR=new VP,PR=new VP;class RR{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return!(0===(e.collisionFilterGroup&t.collisionFilterMask)||0===(t.collisionFilterGroup&e.collisionFilterMask)||(0!==(e.type&bR.STATIC)||e.sleepState===bR.SLEEPING)&&(0!==(t.type&bR.STATIC)||t.sleepState===bR.SLEEPING))}intersectionTest(e,t,n,r){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,r):this.doBoundingSphereBroadphase(e,t,n,r)}doBoundingSphereBroadphase(e,t,n,r){const i=DR;t.position.vsub(e.position,i);const s=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<s&&(n.push(e),r.push(t))}doBoundingBoxBroadphase(e,t,n,r){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),r.push(t))}makePairsUnique(e,t){const n=kR,r=NR,i=FR,s=e.length;for(let n=0;n!==s;n++)r[n]=e[n],i[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=r[e].id,s=i[e].id,o=t<s?`${t},${s}`:`${s},${t}`;n[o]=e,n.keys.push(o)}for(let s=0;s!==n.keys.length;s++){const s=n.keys.pop(),o=n[s];e.push(r[o]),t.push(i[o]),delete n[s]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new VP;e.position.vsub(t.position,n);const r=e.shapes[0],i=t.shapes[0];return Math.pow(r.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const DR=new VP;new VP,new JP,new VP;const kR={keys:[]},NR=[],FR=[];new VP,new VP,new VP;class OR extends RR{constructor(){super()}collisionPairs(e,t,n){const r=e.bodies,i=r.length;let s,o;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)s=r[e],o=r[i],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let r=0;r<e.bodies.length;r++){const i=e.bodies[r];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&n.push(i)}return n}}class BR{constructor(){this.rayFromWorld=new VP,this.rayToWorld=new VP,this.hitNormalWorld=new VP,this.hitPointWorld=new VP,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,r,i,s,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(r),this.shape=i,this.body=s,this.distance=o}}let zR,UR,HR,qR,VR,GR,WR;const jR=1,$R=2,KR=4;zR=tR.types.SPHERE,UR=tR.types.PLANE,HR=tR.types.BOX,qR=tR.types.CYLINDER,VR=tR.types.CONVEXPOLYHEDRON,GR=tR.types.HEIGHTFIELD,WR=tR.types.TRIMESH;class XR{get[zR](){return this._intersectSphere}get[UR](){return this._intersectPlane}get[HR](){return this._intersectBox}get[qR](){return this._intersectConvex}get[VR](){return this._intersectConvex}get[GR](){return this._intersectHeightfield}get[WR](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new VP),void 0===t&&(t=new VP),this.from=e.clone(),this.to=t.clone(),this.direction=new VP,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=XR.ANY,this.result=new BR,this.hasHit=!1,this.callback=()=>{}}intersectWorld(e,t){return this.mode=t.mode||XR.ANY,this.result=t.result||new BR,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=typeof t.collisionFilterMask<"u"?t.collisionFilterMask:-1,this.collisionFilterGroup=typeof t.collisionFilterGroup<"u"?t.collisionFilterGroup:-1,this.checkCollisionResponse=!(typeof t.checkCollisionResponse<"u")||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(YR),ZR.length=0,e.broadphase.aabbQuery(e,YR,ZR),this.intersectBodies(ZR),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse||0===(this.collisionFilterGroup&e.collisionFilterMask)||0===(e.collisionFilterGroup&this.collisionFilterMask))return;const r=eD,i=tD;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!n||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],r),r.vadd(e.position,r),this.intersectShape(s,i,r,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,r){if(function(e,t,n){n.vsub(e,_D);const r=_D.dot(t);return t.scale(r,ED),ED.vadd(e,ED),n.distanceTo(ED)}(this.from,this.direction,n)>e.boundingSphereRadius)return;const i=this[e.type];i&&i.call(this,e,t,n,r,e)}_intersectBox(e,t,n,r,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,r,i)}_intersectPlane(e,t,n,r,i){const s=this.from,o=this.to,a=this.direction,l=new VP(0,0,1);t.vmult(l,l);const c=new VP;s.vsub(n,c);const h=c.dot(l);o.vsub(n,c);if(h*c.dot(l)>0||s.distanceTo(o)<h)return;const u=l.dot(a);if(Math.abs(u)<this.precision)return;const d=new VP,p=new VP,f=new VP;s.vsub(n,d);const m=-l.dot(d)/u;a.scale(m,p),s.vadd(p,f),this.reportIntersection(l,f,i,r,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,r=this.to,i=this.from;t.x=Math.min(r.x,i.x),t.y=Math.min(r.y,i.y),t.z=Math.min(r.z,i.z),n.x=Math.max(r.x,i.x),n.y=Math.max(r.y,i.y),n.z=Math.max(r.z,i.z)}_intersectHeightfield(e,t,n,r,i){e.data,e.elementSize;const s=lD;s.from.copy(this.from),s.to.copy(this.to),nR.pointToLocalFrame(n,t,s.from,s.from),nR.pointToLocalFrame(n,t,s.to,s.to),s.updateDirection();const o=cD;let a,l,c,h;a=l=0,c=h=e.data.length-1;const u=new $P;s.getAABB(u),e.getIndexOfPosition(u.lowerBound.x,u.lowerBound.y,o,!0),a=Math.max(a,o[0]),l=Math.max(l,o[1]),e.getIndexOfPosition(u.upperBound.x,u.upperBound.y,o,!0),c=Math.min(c,o[0]+1),h=Math.min(h,o[1]+1);for(let o=a;o<c;o++)for(let a=l;a<h;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,u),u.overlapsRay(s)){if(e.getConvexTrianglePillar(o,a,!1),nR.pointToWorldFrame(n,t,e.pillarOffset,aD),this._intersectConvex(e.pillarConvex,t,aD,r,i,oD),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),nR.pointToWorldFrame(n,t,e.pillarOffset,aD),this._intersectConvex(e.pillarConvex,t,aD,r,i,oD)}}}_intersectSphere(e,t,n,r,i){const s=this.from,o=this.to,a=e.radius,l=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2,c=2*((o.x-s.x)*(s.x-n.x)+(o.y-s.y)*(s.y-n.y)+(o.z-s.z)*(s.z-n.z)),h=c**2-4*l*((s.x-n.x)**2+(s.y-n.y)**2+(s.z-n.z)**2-a**2),u=hD,d=uD;if(!(h<0))if(0===h)s.lerp(o,h,u),u.vsub(n,d),d.normalize(),this.reportIntersection(d,u,i,r,-1);else{const e=(-c-Math.sqrt(h))/(2*l),t=(-c+Math.sqrt(h))/(2*l);if(e>=0&&e<=1&&(s.lerp(o,e,u),u.vsub(n,d),d.normalize(),this.reportIntersection(d,u,i,r,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(o,t,u),u.vsub(n,d),d.normalize(),this.reportIntersection(d,u,i,r,-1))}}_intersectConvex(e,t,n,r,i,s){const o=dD,a=pD,l=s&&s.faceList||null,c=e.faces,h=e.vertices,u=e.faceNormals,d=this.direction,p=this.from,f=this.to,m=p.distanceTo(f),g=l?l.length:c.length,y=this.result;for(let e=0;!y.shouldStop&&e<g;e++){const s=l?l[e]:e,f=c[s],g=u[s],b=t,v=n;a.copy(h[f[0]]),b.vmult(a,a),a.vadd(v,a),a.vsub(p,a),b.vmult(g,o);const w=d.dot(o);if(Math.abs(w)<this.precision)continue;const x=o.dot(a)/w;if(!(x<0)){d.scale(x,nD),nD.vadd(p,nD),rD.copy(h[f[0]]),b.vmult(rD,rD),v.vadd(rD,rD);for(let e=1;!y.shouldStop&&e<f.length-1;e++){iD.copy(h[f[e]]),sD.copy(h[f[e+1]]),b.vmult(iD,iD),b.vmult(sD,sD),v.vadd(iD,iD),v.vadd(sD,sD);const t=nD.distanceTo(p);!XR.pointInTriangle(nD,rD,iD,sD)&&!XR.pointInTriangle(nD,iD,rD,sD)||t>m||this.reportIntersection(o,nD,i,r,s)}}}}_intersectTrimesh(e,t,n,r,i,s){const o=fD,a=wD,l=xD,c=pD,h=mD,u=gD,d=yD,p=vD,f=bD,m=e.indices;e.vertices;const g=this.from,y=this.to,b=this.direction;l.position.copy(n),l.quaternion.copy(t),nR.vectorToLocalFrame(n,t,b,h),nR.pointToLocalFrame(n,t,g,u),nR.pointToLocalFrame(n,t,y,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,u.x*=e.scale.x,u.y*=e.scale.y,u.z*=e.scale.z,d.vsub(u,h),h.normalize();const v=u.distanceSquared(d);e.tree.rayQuery(this,l,a);for(let s=0,l=a.length;!this.result.shouldStop&&s!==l;s++){const l=a[s];e.getNormal(l,o),e.getVertex(m[3*l],rD),rD.vsub(u,c);const d=h.dot(o),g=o.dot(c)/d;if(g<0)continue;h.scale(g,nD),nD.vadd(u,nD),e.getVertex(m[3*l+1],iD),e.getVertex(m[3*l+2],sD);const y=nD.distanceSquared(u);!XR.pointInTriangle(nD,iD,rD,sD)&&!XR.pointInTriangle(nD,rD,iD,sD)||y>v||(nR.vectorToWorldFrame(t,o,f),nR.pointToWorldFrame(n,t,nD,p),this.reportIntersection(f,p,i,r,l))}a.length=0}reportIntersection(e,t,n,r,i){const s=this.from,o=this.to,a=s.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case XR.ALL:this.hasHit=!0,l.set(s,o,e,t,n,r,a),l.hasHit=!0,this.callback(l);break;case XR.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,r,a));break;case XR.ANY:this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,r,a),l.shouldStop=!0}}static pointInTriangle(e,t,n,r){r.vsub(t,_D),n.vsub(t,JR),e.vsub(t,QR);const i=_D.dot(_D),s=_D.dot(JR),o=_D.dot(QR),a=JR.dot(JR),l=JR.dot(QR);let c,h;return(c=a*o-s*l)>=0&&(h=i*l-s*o)>=0&&c+h<i*a-s*s}}XR.CLOSEST=jR,XR.ANY=$R,XR.ALL=KR;const YR=new $P,ZR=[],JR=new VP,QR=new VP,eD=new VP,tD=new JP,nD=new VP,rD=new VP,iD=new VP,sD=new VP;new VP,new BR;const oD={faceList:[0]},aD=new VP,lD=new XR,cD=[],hD=new VP,uD=new VP,dD=new VP;new VP,new VP;const pD=new VP,fD=new VP,mD=new VP,gD=new VP,yD=new VP,bD=new VP,vD=new VP;new $P;const wD=[],xD=new nR,_D=new VP,ED=new VP;class SD{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class MD{constructor(){this.spatial=new VP,this.rotational=new VP}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class AD{constructor(e,t,n,r){void 0===n&&(n=-1e6),void 0===r&&(r=1e6),this.id=AD.idCounter++,this.minForce=n,this.maxForce=r,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new MD,this.jacobianElementB=new MD,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const r=t,i=e,s=n;this.a=4/(s*(1+4*r)),this.b=4*r/(1+4*r),this.eps=4/(s*s*i*(1+4*r))}computeB(e,t,n){const r=this.computeGW();return-this.computeGq()*e-r*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.position,s=r.position;return e.spatial.dot(i)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.velocity,s=r.velocity,o=n.angularVelocity,a=r.angularVelocity;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.vlambda,s=r.vlambda,o=n.wlambda,a=r.wlambda;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.force,s=n.torque,o=r.force,a=r.torque,l=n.invMassSolve,c=r.invMassSolve;return i.scale(l,CD),o.scale(c,TD),n.invInertiaWorldSolve.vmult(s,ID),r.invInertiaWorldSolve.vmult(a,LD),e.multiplyVectors(CD,ID)+t.multiplyVectors(TD,LD)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.invMassSolve,s=r.invMassSolve,o=n.invInertiaWorldSolve,a=r.invInertiaWorldSolve;let l=i+s;return o.vmult(e.rotational,PD),l+=PD.dot(e.rotational),a.vmult(t.rotational,PD),l+=PD.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,r=this.bi,i=this.bj,s=RD;r.vlambda.addScaledVector(r.invMassSolve*e,t.spatial,r.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,n.spatial,i.vlambda),r.invInertiaWorldSolve.vmult(t.rotational,s),r.wlambda.addScaledVector(e,s,r.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}AD.idCounter=0;const CD=new VP,TD=new VP,ID=new VP,LD=new VP,PD=new VP,RD=new VP;class DD extends AD{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new VP,this.rj=new VP,this.ni=new VP}computeB(e){const t=this.a,n=this.b,r=this.bi,i=this.bj,s=this.ri,o=this.rj,a=kD,l=ND,c=r.velocity,h=r.angularVelocity;r.force,r.torque;const u=i.velocity,d=i.angularVelocity;i.force,i.torque;const p=FD,f=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;s.cross(g,a),o.cross(g,l),g.negate(f.spatial),a.negate(f.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(i.position),p.vadd(o,p),p.vsub(r.position,p),p.vsub(s,p);const y=g.dot(p),b=this.restitution+1;return-y*t-(b*u.dot(g)-b*c.dot(g)+d.dot(l)-h.dot(a))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=OD,t=BD,n=zD,r=UD,i=HD;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,r),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(r,t),e.vsub(t,i),this.ni.dot(i)}}const kD=new VP,ND=new VP,FD=new VP,OD=new VP,BD=new VP,zD=new VP,UD=new VP,HD=new VP;new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP;class qD extends AD{constructor(e,t,n){super(e,t,-n,n),this.ri=new VP,this.rj=new VP,this.t=new VP}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,r=this.rj,i=VD,s=GD,o=this.t;n.cross(o,i),r.cross(o,s);const a=this.jacobianElementA,l=this.jacobianElementB;o.negate(a.spatial),i.negate(a.rotational),l.spatial.copy(o),l.rotational.copy(s);return-this.computeGW()*t-e*this.computeGiMf()}}const VD=new VP,GD=new VP;class WD{constructor(e,t,n){n=SD.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=WD.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}WD.idCounter=0;class jD{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=jD.idCounter++,this.friction=typeof e.friction<"u"?e.friction:-1,this.restitution=typeof e.restitution<"u"?e.restitution:-1}}jD.idCounter=0,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new XR,new VP,new VP,new VP,new VP(1,0,0),new VP(0,1,0),new VP(0,0,1),new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP;class $D extends iR{constructor(e,t,n,r){if(void 0===e&&(e=1),void 0===t&&(t=1),void 0===n&&(n=1),void 0===r&&(r=8),e<0)throw Error("The cylinder radiusTop cannot be negative.");if(t<0)throw Error("The cylinder radiusBottom cannot be negative.");const i=r,s=[],o=[],a=[],l=[],c=[],h=Math.cos,u=Math.sin;s.push(new VP(-t*u(0),.5*-n,t*h(0))),l.push(0),s.push(new VP(-e*u(0),.5*n,e*h(0))),c.push(1);for(let r=0;r<i;r++){const d=2*Math.PI/i*(r+1),p=2*Math.PI/i*(r+.5);r<i-1?(s.push(new VP(-t*u(d),.5*-n,t*h(d))),l.push(2*r+2),s.push(new VP(-e*u(d),.5*n,e*h(d))),c.push(2*r+3),a.push([2*r,2*r+1,2*r+3,2*r+2])):a.push([2*r,2*r+1,1,0]),(i%2==1||r<i/2)&&o.push(new VP(-u(p),0,h(p)))}a.push(l),o.push(new VP(0,1,0));const d=[];for(let e=0;e<c.length;e++)d.push(c[c.length-e-1]);a.push(d),super({vertices:s,faces:a,axes:o}),this.type=tR.types.CYLINDER,this.radiusTop=e,this.radiusBottom=t,this.height=n,this.numSegments=r}}class KD extends tR{constructor(){super({type:tR.types.PLANE}),this.worldNormal=new VP,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(e){const t=this.worldNormal;t.set(0,0,1),e.vmult(t,t),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(e,t){return void 0===t&&(t=new VP),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,n,r){XD.set(0,0,1),t.vmult(XD,XD);const i=Number.MAX_VALUE;n.set(-i,-i,-i),r.set(i,i,i),1===XD.x?r.x=e.x:-1===XD.x&&(n.x=e.x),1===XD.y?r.y=e.y:-1===XD.y&&(n.y=e.y),1===XD.z?r.z=e.z:-1===XD.z&&(n.z=e.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const XD=new VP;new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new $P,new VP,new $P,new VP,new VP,new VP,new VP,new VP,new VP,new VP,new $P,new VP,new nR,new $P;class YD{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){e.enabled&&!e.bi.isTrigger&&!e.bj.isTrigger&&this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class ZD extends YD{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const r=this.iterations,i=this.tolerance*this.tolerance,s=this.equations,o=s.length,a=t.bodies,l=a.length,c=e;let h,u,d,p,f,m;if(0!==o)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const g=QD,y=ek,b=JD;g.length=o,y.length=o,b.length=o;for(let e=0;e!==o;e++){const t=s[e];b[e]=0,y[e]=t.computeB(c),g[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==l;e++){const t=a[e],n=t.vlambda,r=t.wlambda;n.set(0,0,0),r.set(0,0,0)}for(n=0;n!==r;n++){p=0;for(let e=0;e!==o;e++){const t=s[e];h=y[e],u=g[e],m=b[e],f=t.computeGWlambda(),d=u*(h-f-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),b[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<i)break}for(let e=0;e!==l;e++){const t=a[e],n=t.velocity,r=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),r.vadd(t.wlambda,r)}let e=s.length;const t=1/c;for(;e--;)s[e].multiplier=b[e]*t}return n}}const JD=[],QD=[],ek=[];class tk{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class nk extends tk{constructor(){super(...arguments),this.type=VP}constructObject(){return new VP}}const rk=tR.types.SPHERE,ik=tR.types.SPHERE|tR.types.PLANE,sk=tR.types.BOX|tR.types.BOX,ok=tR.types.SPHERE|tR.types.BOX,ak=tR.types.PLANE|tR.types.BOX,lk=tR.types.CONVEXPOLYHEDRON,ck=tR.types.SPHERE|tR.types.CONVEXPOLYHEDRON,hk=tR.types.PLANE|tR.types.CONVEXPOLYHEDRON,uk=tR.types.BOX|tR.types.CONVEXPOLYHEDRON,dk=tR.types.SPHERE|tR.types.HEIGHTFIELD,pk=tR.types.BOX|tR.types.HEIGHTFIELD,fk=tR.types.CONVEXPOLYHEDRON|tR.types.HEIGHTFIELD,mk=tR.types.PARTICLE|tR.types.SPHERE,gk=tR.types.PLANE|tR.types.PARTICLE,yk=tR.types.BOX|tR.types.PARTICLE,bk=tR.types.PARTICLE|tR.types.CONVEXPOLYHEDRON,vk=tR.types.CYLINDER,wk=tR.types.SPHERE|tR.types.CYLINDER,xk=tR.types.PLANE|tR.types.CYLINDER,_k=tR.types.BOX|tR.types.CYLINDER,Ek=tR.types.CONVEXPOLYHEDRON|tR.types.CYLINDER,Sk=tR.types.HEIGHTFIELD|tR.types.CYLINDER,Mk=tR.types.PARTICLE|tR.types.CYLINDER,Ak=tR.types.SPHERE|tR.types.TRIMESH,Ck=tR.types.PLANE|tR.types.TRIMESH;class Tk{get[rk](){return this.sphereSphere}get[ik](){return this.spherePlane}get[sk](){return this.boxBox}get[ok](){return this.sphereBox}get[ak](){return this.planeBox}get[lk](){return this.convexConvex}get[ck](){return this.sphereConvex}get[hk](){return this.planeConvex}get[uk](){return this.boxConvex}get[dk](){return this.sphereHeightfield}get[pk](){return this.boxHeightfield}get[fk](){return this.convexHeightfield}get[mk](){return this.sphereParticle}get[gk](){return this.planeParticle}get[yk](){return this.boxParticle}get[bk](){return this.convexParticle}get[vk](){return this.convexConvex}get[wk](){return this.sphereConvex}get[xk](){return this.planeConvex}get[_k](){return this.boxConvex}get[Ek](){return this.convexConvex}get[Sk](){return this.heightfieldCylinder}get[Mk](){return this.particleCylinder}get[Ak](){return this.sphereTrimesh}get[Ck](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new nk,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,r,i,s){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new DD(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&r.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=n.material||e.material,c=r.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(o.restitution=l.restitution*c.restitution),o.si=i||n,o.sj=s||r,o}createFrictionEquationsFromContact(e,t){const n=e.bi,r=e.bj,i=e.si,s=e.sj,o=this.world,a=this.currentContactMaterial;let l=a.friction;const c=i.material||n.material,h=s.material||r.material;if(c&&h&&c.friction>=0&&h.friction>=0&&(l=c.friction*h.friction),l>0){const i=l*(o.frictionGravity||o.gravity).length();let s=n.invMass+r.invMass;s>0&&(s=1/s);const c=this.frictionEquationPool,h=c.length?c.pop():new qD(n,r,i*s),u=c.length?c.pop():new qD(n,r,i*s);return h.bi=u.bi=n,h.bj=u.bj=r,h.minForce=u.minForce=-i*s,h.maxForce=u.maxForce=i*s,h.ri.copy(e.ri),h.rj.copy(e.rj),u.ri.copy(e.ri),u.rj.copy(e.rj),e.ni.tangents(h.t,u.t),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.enabled=u.enabled=e.enabled,t.push(h,u),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],r=this.frictionResult[this.frictionResult.length-1];Ik.setZero(),Lk.setZero(),Pk.setZero();const i=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==i?(Ik.vadd(t.ni,Ik),Lk.vadd(t.ri,Lk),Pk.vadd(t.rj,Pk)):(Ik.vsub(t.ni,Ik),Lk.vadd(t.rj,Lk),Pk.vadd(t.ri,Pk));const s=1/e;Lk.scale(s,n.ri),Pk.scale(s,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),Ik.normalize(),Ik.tangents(n.t,r.t)}getContacts(e,t,n,r,i,s,o){this.contactPointPool=i,this.frictionEquationPool=o,this.result=r,this.frictionResult=s;const a=kk,l=Nk,c=Rk,h=Dk;for(let r=0,i=e.length;r!==i;r++){const i=e[r],s=t[r];let o=null;i.material&&s.material&&(o=n.getContactMaterial(i.material,s.material)||null);const u=i.type&bR.KINEMATIC&&s.type&bR.STATIC||i.type&bR.STATIC&&s.type&bR.KINEMATIC||i.type&bR.KINEMATIC&&s.type&bR.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],a),i.quaternion.vmult(i.shapeOffsets[e],c),c.vadd(i.position,c);const t=i.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],l),s.quaternion.vmult(s.shapeOffsets[e],h),h.vadd(s.position,h);const r=s.shapes[e];if(!(t.collisionFilterMask&r.collisionFilterGroup&&r.collisionFilterMask&t.collisionFilterGroup)||c.distanceTo(h)>t.boundingSphereRadius+r.boundingSphereRadius)continue;let d=null;t.material&&r.material&&(d=n.getContactMaterial(t.material,r.material)||null),this.currentContactMaterial=d||o||n.defaultContactMaterial;const p=this[t.type|r.type];if(p){let e=!1;e=t.type<r.type?p.call(this,t,r,c,h,a,l,i,s,t,r,u):p.call(this,r,t,h,c,l,a,s,i,t,r,u),e&&u&&(n.shapeOverlapKeeper.set(t.id,r.id),n.bodyOverlapKeeper.set(i.id,s.id))}}}}}sphereSphere(e,t,n,r,i,s,o,a,l,c,h){if(h)return n.distanceSquared(r)<(e.radius+t.radius)**2;const u=this.createContactEquation(o,a,e,t,l,c);r.vsub(n,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.scale(e.radius,u.ri),u.rj.scale(-t.radius,u.rj),u.ri.vadd(n,u.ri),u.ri.vsub(o.position,u.ri),u.rj.vadd(r,u.rj),u.rj.vsub(a.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}spherePlane(e,t,n,r,i,s,o,a,l,c,h){const u=this.createContactEquation(o,a,e,t,l,c);if(u.ni.set(0,0,1),s.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.scale(e.radius,u.ri),n.vsub(r,eN),u.ni.scale(u.ni.dot(eN),tN),eN.vsub(tN,u.rj),-eN.dot(u.ni)<=e.radius){if(h)return!0;const e=u.ri,t=u.rj;e.vadd(n,e),e.vsub(o.position,e),t.vadd(r,t),t.vsub(a.position,t),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}}boxBox(e,t,n,r,i,s,o,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,h)}sphereBox(e,t,n,r,i,s,o,a,l,c,h){const u=this.v3pool,d=hN;n.vsub(r,oN),t.getSideNormals(d,s);const p=e.radius;let f=!1;const m=dN,g=pN,y=fN;let b=null,v=0,w=0,x=0,_=null;for(let e=0,t=d.length;e!==t&&!1===f;e++){const t=aN;t.copy(d[e]);const n=t.length();t.normalize();const r=oN.dot(t);if(r<n+p&&r>0){const i=lN,s=cN;i.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const o=i.length(),a=s.length();i.normalize(),s.normalize();const l=oN.dot(i),c=oN.dot(s);if(l<o&&l>-o&&c<a&&c>-a){const e=Math.abs(r-n-p);if((null===_||e<_)&&(_=e,w=l,x=c,b=n,m.copy(t),g.copy(i),y.copy(s),v++,h))return!0}}}if(v){f=!0;const i=this.createContactEquation(o,a,e,t,l,c);m.scale(-p,i.ri),i.ni.copy(m),i.ni.negate(i.ni),m.scale(b,m),g.scale(w,g),m.vadd(g,m),y.scale(x,y),m.vadd(y,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let E=u.get();const S=uN;for(let i=0;2!==i&&!f;i++)for(let s=0;2!==s&&!f;s++)for(let u=0;2!==u&&!f;u++)if(E.set(0,0,0),i?E.vadd(d[0],E):E.vsub(d[0],E),s?E.vadd(d[1],E):E.vsub(d[1],E),u?E.vadd(d[2],E):E.vsub(d[2],E),r.vadd(E,S),S.vsub(n,S),S.lengthSquared()<p*p){if(h)return!0;f=!0;const i=this.createContactEquation(o,a,e,t,l,c);i.ri.copy(S),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(p,i.ri),i.rj.copy(E),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}u.release(E),E=null;const M=u.get(),A=u.get(),C=u.get(),T=u.get(),I=u.get(),L=d.length;for(let i=0;i!==L&&!f;i++)for(let s=0;s!==L&&!f;s++)if(i%3!=s%3){d[s].cross(d[i],M),M.normalize(),d[i].vadd(d[s],A),C.copy(n),C.vsub(A,C),C.vsub(r,C);const u=C.dot(M);M.scale(u,T);let m=0;for(;m===i%3||m===s%3;)m++;I.copy(n),I.vsub(T,I),I.vsub(A,I),I.vsub(r,I);const g=Math.abs(u),y=I.length();if(g<d[m].length()&&y<p){if(h)return!0;f=!0;const i=this.createContactEquation(o,a,e,t,l,c);A.vadd(T,i.rj),i.rj.copy(i.rj),I.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(n,i.ri),i.ri.normalize(),i.ri.scale(p,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}u.release(M,A,C,T,I)}planeBox(e,t,n,r,i,s,o,a,l,c,h){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,h)}convexConvex(e,t,n,r,i,s,o,a,l,c,h,u,d){const p=IN;if(!(n.distanceTo(r)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,i,r,s,p,u,d)){const u=[],d=LN;e.clipAgainstHull(n,i,t,r,s,p,-100,100,u);let f=0;for(let i=0;i!==u.length;i++){if(h)return!0;const s=this.createContactEquation(o,a,e,t,l,c),m=s.ri,g=s.rj;p.negate(s.ni),u[i].normal.negate(d),d.scale(u[i].depth,d),u[i].point.vadd(d,m),g.copy(u[i].point),m.vsub(n,m),g.vsub(r,g),m.vadd(n,m),m.vsub(o.position,m),g.vadd(r,g),g.vsub(a.position,g),this.result.push(s),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}}sphereConvex(e,t,n,r,i,s,o,a,l,c,h){const u=this.v3pool;n.vsub(r,mN);const d=t.faceNormals,p=t.faces,f=t.vertices,m=e.radius;let g=!1;for(let i=0;i!==f.length;i++){const u=f[i],d=vN;s.vmult(u,d),r.vadd(d,d);const p=bN;if(d.vsub(n,p),p.lengthSquared()<m*m){if(h)return!0;g=!0;const i=this.createContactEquation(o,a,e,t,l,c);return i.ri.copy(p),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(m,i.ri),d.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,y=p.length;i!==y&&!1===g;i++){const y=d[i],b=p[i],v=wN;s.vmult(y,v);const w=xN;s.vmult(f[b[0]],w),w.vadd(r,w);const x=_N;v.scale(-m,x),n.vadd(x,x);const _=EN;x.vsub(w,_);const E=_.dot(v),S=SN;if(n.vsub(w,S),E<0&&S.dot(v)>0){const i=[];for(let e=0,t=b.length;e!==t;e++){const t=u.get();s.vmult(f[b[e]],t),r.vadd(t,t),i.push(t)}if(sN(i,v,n)){if(h)return!0;g=!0;const s=this.createContactEquation(o,a,e,t,l,c);v.scale(-m,s.ri),v.negate(s.ni);const d=u.get();v.scale(-E,d);const p=u.get();v.scale(-m,p),n.vsub(r,s.rj),s.rj.vadd(p,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),u.release(d),u.release(p),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)u.release(i[e]);return}for(let d=0;d!==b.length;d++){const p=u.get(),g=u.get();s.vmult(f[b[(d+1)%b.length]],p),s.vmult(f[b[(d+2)%b.length]],g),r.vadd(p,p),r.vadd(g,g);const y=gN;g.vsub(p,y);const v=yN;y.unit(v);const w=u.get(),x=u.get();n.vsub(p,x);const _=x.dot(v);v.scale(_,w),w.vadd(p,w);const E=u.get();if(w.vsub(n,E),_>0&&_*_<y.lengthSquared()&&E.lengthSquared()<m*m){if(h)return!0;const s=this.createContactEquation(o,a,e,t,l,c);w.vsub(r,s.rj),w.vsub(n,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)u.release(i[e]);return u.release(p),u.release(g),u.release(w),u.release(E),void u.release(x)}u.release(p),u.release(g),u.release(w),u.release(E),u.release(x)}for(let e=0,t=i.length;e!==t;e++)u.release(i[e])}}}planeConvex(e,t,n,r,i,s,o,a,l,c,h){const u=MN,d=AN;d.set(0,0,1),i.vmult(d,d);let p=0;const f=CN;for(let i=0;i!==t.vertices.length;i++)if(u.copy(t.vertices[i]),s.vmult(u,u),r.vadd(u,u),u.vsub(n,f),d.dot(f)<=0){if(h)return!0;const i=this.createContactEquation(o,a,e,t,l,c),s=TN;d.scale(d.dot(f),s),u.vsub(s,s),s.vsub(n,i.ri),i.ni.copy(d),u.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,n,r,i,s,o,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,h)}sphereHeightfield(e,t,n,r,i,s,o,a,l,c,h){const u=t.data,d=e.radius,p=t.elementSize,f=GN,m=VN;nR.pointToLocalFrame(r,s,n,m);let g=Math.floor((m.x-d)/p)-1,y=Math.ceil((m.x+d)/p)+1,b=Math.floor((m.y-d)/p)-1,v=Math.ceil((m.y+d)/p)+1;if(y<0||v<0||g>u.length||b>u[0].length)return;g<0&&(g=0),y<0&&(y=0),b<0&&(b=0),v<0&&(v=0),g>=u.length&&(g=u.length-1),y>=u.length&&(y=u.length-1),v>=u[0].length&&(v=u[0].length-1),b>=u[0].length&&(b=u[0].length-1);const w=[];t.getRectMinMax(g,b,y,v,w);const x=w[0],_=w[1];if(m.z-d>_||m.z+d<x)return;const E=this.result;for(let l=g;l<y;l++)for(let c=b;c<v;c++){const u=E.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),nR.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,o,a,e,t,h)),h&&d||(t.getConvexTrianglePillar(l,c,!0),nR.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,o,a,e,t,h)),h&&d))return!0;if(E.length-u>2)return}}boxHeightfield(e,t,n,r,i,s,o,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,h)}convexHeightfield(e,t,n,r,i,s,o,a,l,c,h){const u=t.data,d=t.elementSize,p=e.boundingSphereRadius,f=HN,m=qN,g=UN;nR.pointToLocalFrame(r,s,n,g);let y=Math.floor((g.x-p)/d)-1,b=Math.ceil((g.x+p)/d)+1,v=Math.floor((g.y-p)/d)-1,w=Math.ceil((g.y+p)/d)+1;if(b<0||w<0||y>u.length||v>u[0].length)return;y<0&&(y=0),b<0&&(b=0),v<0&&(v=0),w<0&&(w=0),y>=u.length&&(y=u.length-1),b>=u.length&&(b=u.length-1),w>=u[0].length&&(w=u[0].length-1),v>=u[0].length&&(v=u[0].length-1);const x=[];t.getRectMinMax(y,v,b,w,x);const _=x[0],E=x[1];if(!(g.z-p>E||g.z+p<_))for(let l=y;l<b;l++)for(let c=v;c<w;c++){let u=!1;if(t.getConvexTrianglePillar(l,c,!1),nR.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(u=this.convexConvex(e,t.pillarConvex,n,f,i,s,o,a,null,null,h,m,null)),h&&u||(t.getConvexTrianglePillar(l,c,!0),nR.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(u=this.convexConvex(e,t.pillarConvex,n,f,i,s,o,a,null,null,h,m,null)),h&&u))return!0}}sphereParticle(e,t,n,r,i,s,o,a,l,c,h){const u=kN;if(u.set(0,0,1),r.vsub(n,u),u.lengthSquared()<=e.radius*e.radius){if(h)return!0;const n=this.createContactEquation(a,o,t,e,l,c);u.normalize(),n.rj.copy(u),n.rj.scale(e.radius,n.rj),n.ni.copy(u),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,r,i,s,o,a,l,c,h){const u=PN;u.set(0,0,1),o.quaternion.vmult(u,u);const d=RN;if(r.vsub(o.position,d),u.dot(d)<=0){if(h)return!0;const n=this.createContactEquation(a,o,t,e,l,c);n.ni.copy(u),n.ni.negate(n.ni),n.ri.set(0,0,0);const i=DN;u.scale(u.dot(r),i),r.vsub(i,i),n.rj.copy(i),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,r,i,s,o,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,h)}convexParticle(e,t,n,r,i,s,o,a,l,c,h){let u=-1;const d=ON,p=zN;let f=null;const m=FN;if(m.copy(r),m.vsub(n,m),i.conjugate(NN),NN.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];r.vsub(n[0],BN);const s=-i.dot(BN);if(null===f||Math.abs(s)<Math.abs(f)){if(h)return!0;f=s,u=t,d.copy(i)}}if(-1!==u){const i=this.createContactEquation(a,o,t,e,l,c);d.scale(f,p),p.vadd(r,p),p.vsub(n,p),i.rj.copy(p),d.negate(i.ni),i.ri.set(0,0,0);const s=i.ri,h=i.rj;s.vadd(r,s),s.vsub(a.position,s),h.vadd(n,h),h.vsub(o.position,h),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,r,i,s,o,a,l,c,h){return this.convexHeightfield(t,e,r,n,s,i,a,o,l,c,h)}particleCylinder(e,t,n,r,i,s,o,a,l,c,h){return this.convexParticle(t,e,r,n,s,i,a,o,l,c,h)}sphereTrimesh(e,t,n,r,i,s,o,a,l,c,h){const u=Vk,d=Gk,p=Wk,f=jk,m=$k,g=Kk,y=Jk,b=qk,v=Uk,w=Qk;nR.pointToLocalFrame(r,s,n,m);const x=e.radius;y.lowerBound.set(m.x-x,m.y-x,m.z-x),y.upperBound.set(m.x+x,m.y+x,m.z+x),t.getTrianglesInAABB(y,w);const _=Hk,E=e.radius*e.radius;for(let i=0;i<w.length;i++)for(let u=0;u<3;u++)if(t.getVertex(t.indices[3*w[i]+u],_),_.vsub(m,v),v.lengthSquared()<=E){if(b.copy(_),nR.pointToWorldFrame(r,s,b,_),_.vsub(n,v),h)return!0;let i=this.createContactEquation(o,a,e,t,l,c);i.ni.copy(v),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.copy(_),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<w.length;i++)for(let y=0;y<3;y++){t.getVertex(t.indices[3*w[i]+y],u),t.getVertex(t.indices[3*w[i]+(y+1)%3],d),d.vsub(u,p),m.vsub(d,g);const b=g.dot(p);m.vsub(u,g);let v=g.dot(p);if(v>0&&b<0&&(m.vsub(u,g),f.copy(p),f.normalize(),v=g.dot(f),f.scale(v,g),g.vadd(u,g),g.distanceTo(m)<e.radius)){if(h)return!0;const i=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),nR.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),nR.vectorToWorldFrame(s,i.ni,i.ni),nR.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}const S=Xk,M=Yk,A=Zk,C=zk;for(let i=0,u=w.length;i!==u;i++){t.getTriangleVertices(w[i],S,M,A),t.getNormal(w[i],C),m.vsub(S,g);let u=g.dot(C);if(C.scale(u,g),m.vsub(g,g),u=g.distanceTo(m),XR.pointInTriangle(g,S,M,A)&&u<e.radius){if(h)return!0;let i=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),nR.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),nR.vectorToWorldFrame(s,i.ni,i.ni),nR.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,r,i,s,o,a,l,c,h){const u=new VP,d=Fk;d.set(0,0,1),i.vmult(d,d);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,u);const p=new VP;p.copy(u),nR.pointToWorldFrame(r,s,p,u);const f=Ok;if(u.vsub(n,f),d.dot(f)<=0){if(h)return!0;const n=this.createContactEquation(o,a,e,t,l,c);n.ni.copy(d);const r=Bk;d.scale(f.dot(d),r),u.vsub(r,r),n.ri.copy(r),n.ri.vsub(o.position,n.ri),n.rj.copy(u),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const Ik=new VP,Lk=new VP,Pk=new VP,Rk=new VP,Dk=new VP,kk=new JP,Nk=new JP,Fk=new VP,Ok=new VP,Bk=new VP,zk=new VP,Uk=new VP;new VP;const Hk=new VP,qk=new VP,Vk=new VP,Gk=new VP,Wk=new VP,jk=new VP,$k=new VP,Kk=new VP,Xk=new VP,Yk=new VP,Zk=new VP,Jk=new $P,Qk=[],eN=new VP,tN=new VP,nN=new VP,rN=new VP,iN=new VP;function sN(e,t,n){let r=null;const i=e.length;for(let s=0;s!==i;s++){const o=e[s],a=nN;e[(s+1)%i].vsub(o,a);const l=rN;a.cross(t,l);const c=iN;n.vsub(o,c);const h=l.dot(c);if(!(null===r||h>0&&!0===r||h<=0&&!1===r))return!1;null===r&&(r=h>0)}return!0}const oN=new VP,aN=new VP,lN=new VP,cN=new VP,hN=[new VP,new VP,new VP,new VP,new VP,new VP],uN=new VP,dN=new VP,pN=new VP,fN=new VP,mN=new VP,gN=new VP,yN=new VP,bN=new VP,vN=new VP,wN=new VP,xN=new VP,_N=new VP,EN=new VP,SN=new VP;new VP,new VP;const MN=new VP,AN=new VP,CN=new VP,TN=new VP,IN=new VP,LN=new VP,PN=new VP,RN=new VP,DN=new VP,kN=new VP,NN=new JP,FN=new VP;new VP;const ON=new VP,BN=new VP,zN=new VP,UN=new VP,HN=new VP,qN=[0],VN=new VP,GN=new VP;class WN{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),r=this.current;let i=0;for(;n>r[i];)i++;if(n!==r[i]){for(let e=r.length-1;e>=i;e--)r[e+1]=r[e];r[i]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,r=this.previous,i=n.length,s=r.length;let o=0;for(let t=0;t<i;t++){let i=!1;const s=n[t];for(;s>r[o];)o++;i=s===r[o],i||jN(e,s)}o=0;for(let e=0;e<s;e++){let i=!1;const s=r[e];for(;s>n[o];)o++;i=n[o]===s,i||jN(t,s)}}}function jN(e,t){e.push((4294901760&t)>>16,65535&t)}const $N=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class KN{constructor(){this.data={keys:[]}}get(e,t){const n=$N(e,t);return this.data[n]}set(e,t,n){const r=$N(e,t);this.get(e,t)||this.data.keys.push(r),this.data[r]=n}delete(e,t){const n=$N(e,t),r=this.data.keys.indexOf(n);-1!==r&&this.data.keys.splice(r,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;){delete e[t.pop()]}}}class XN extends ZP{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new VP,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new VP,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new OR,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new ZD,this.constraints=[],this.narrowphase=new Tk(this),this.collisionMatrix=new YP,this.collisionMatrixPrevious=new YP,this.bodyOverlapKeeper=new WN,this.shapeOverlapKeeper=new WN,this.contactmaterials=[],this.contactMaterialTable=new KN,this.defaultMaterial=new jD("default"),this.defaultContactMaterial=new WD(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof BR?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,r){return void 0===n&&(n={}),n.mode=XR.ALL,n.from=e,n.to=t,n.callback=r,YN.intersectWorld(this,n)}raycastAny(e,t,n,r){return void 0===n&&(n={}),n.mode=XR.ANY,n.from=e,n.to=t,n.result=r,YN.intersectWorld(this,n)}raycastClosest(e,t,n,r){return void 0===n&&(n={}),n.mode=XR.CLOSEST,n.from=e,n.to=t,n.result=r,YN.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof bR&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,r=n.indexOf(e);if(-1!==r){n.splice(r,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const r=t[n].shapes;for(let t=0;t<r.length;t++){const n=r[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=ZN.now()/1e3;if(this.lastCallTime){const r=n-this.lastCallTime;this.step(e,r,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const r=ZN.now();let i=0;for(;this.accumulator>=e&&i<n&&(this.internalStep(e),this.accumulator-=e,i++,!(ZN.now()-r>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=rF,r=iF,i=this.bodies.length,s=this.bodies,o=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,h=bR.DYNAMIC;let u=-1/0;const d=this.constraints,p=nF;a.length();const f=a.x,m=a.y,g=a.z;let y=0;for(l&&(u=ZN.now()),y=0;y!==i;y++){const e=s[y];if(e.type===h){const t=e.force,n=e.mass;t.x+=n*f,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(u=ZN.now()),n.length=0,r.length=0,this.broadphase.collisionPairs(this,n,r),l&&(c.broadphase=ZN.now()-u);let b=d.length;for(y=0;y!==b;y++){const e=d[y];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===r[t]||e.bodyB===n[t]&&e.bodyA===r[t])&&(n.splice(t,1),r.splice(t,1))}this.collisionMatrixTick(),l&&(u=ZN.now());const v=tF,w=t.length;for(y=0;y!==w;y++)v.push(t[y]);t.length=0;const x=this.frictionEquations.length;for(y=0;y!==x;y++)p.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,r,this,t,v,this.frictionEquations,p),l&&(c.narrowphase=ZN.now()-u),l&&(u=ZN.now()),y=0;y<this.frictionEquations.length;y++)o.addEquation(this.frictionEquations[y]);const _=t.length;for(let e=0;e!==_;e++){const n=t[e],r=n.bi,i=n.bj,s=n.si,a=n.sj;let l;if(l=r.material&&i.material&&this.getContactMaterial(r.material,i.material)||this.defaultContactMaterial,l.friction,r.material&&i.material&&(r.material.friction>=0&&i.material.friction>=0&&(r.material.friction,i.material.friction),r.material.restitution>=0&&i.material.restitution>=0&&(n.restitution=r.material.restitution*i.material.restitution)),o.addEquation(n),r.allowSleep&&r.type===bR.DYNAMIC&&r.sleepState===bR.SLEEPING&&i.sleepState===bR.AWAKE&&i.type!==bR.STATIC){i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0)}if(i.allowSleep&&i.type===bR.DYNAMIC&&i.sleepState===bR.SLEEPING&&r.sleepState===bR.AWAKE&&r.type!==bR.STATIC){r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(r,i,!0),this.collisionMatrixPrevious.get(r,i)||(eF.body=i,eF.contact=n,r.dispatchEvent(eF),eF.body=r,i.dispatchEvent(eF)),this.bodyOverlapKeeper.set(r.id,i.id),this.shapeOverlapKeeper.set(s.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=ZN.now()-u,u=ZN.now()),y=0;y!==i;y++){const e=s[y];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(b=d.length,y=0;y!==b;y++){const e=d[y];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];o.addEquation(n)}}o.solve(e,this),l&&(c.solve=ZN.now()-u),o.removeAllEquations();const E=Math.pow;for(y=0;y!==i;y++){const t=s[y];if(t.type&h){const n=E(1-t.linearDamping,e),r=t.velocity;r.scale(n,r);const i=t.angularVelocity;if(i){const n=E(1-t.angularDamping,e);i.scale(n,i)}}}this.dispatchEvent(QN),l&&(u=ZN.now());const S=this.stepnumber%(this.quatNormalizeSkip+1)===0,M=this.quatNormalizeFast;for(y=0;y!==i;y++)s[y].integrate(e,S,M);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=ZN.now()-u),this.stepnumber+=1,this.dispatchEvent(JN);let A=!0;if(this.allowSleep)for(A=!1,y=0;y!==i;y++){const e=s[y];e.sleepTick(this.time),e.sleepState!==bR.SLEEPING&&(A=!0)}this.hasActiveBodies=A}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(sF,oF),e){for(let e=0,t=sF.length;e<t;e+=2)aF.bodyA=this.getBodyById(sF[e]),aF.bodyB=this.getBodyById(sF[e+1]),this.dispatchEvent(aF);aF.bodyA=aF.bodyB=null}if(t){for(let e=0,t=oF.length;e<t;e+=2)lF.bodyA=this.getBodyById(oF[e]),lF.bodyB=this.getBodyById(oF[e+1]),this.dispatchEvent(lF);lF.bodyA=lF.bodyB=null}sF.length=oF.length=0;const n=this.hasAnyEventListener("beginShapeContact"),r=this.hasAnyEventListener("endShapeContact");if((n||r)&&this.shapeOverlapKeeper.getDiff(sF,oF),n){for(let e=0,t=sF.length;e<t;e+=2){const t=this.getShapeById(sF[e]),n=this.getShapeById(sF[e+1]);cF.shapeA=t,cF.shapeB=n,t&&(cF.bodyA=t.body),n&&(cF.bodyB=n.body),this.dispatchEvent(cF)}cF.bodyA=cF.bodyB=cF.shapeA=cF.shapeB=null}if(r){for(let e=0,t=oF.length;e<t;e+=2){const t=this.getShapeById(oF[e]),n=this.getShapeById(oF[e+1]);hF.shapeA=t,hF.shapeB=n,t&&(hF.bodyA=t.body),n&&(hF.bodyB=n.body),this.dispatchEvent(hF)}hF.bodyA=hF.bodyB=hF.shapeA=hF.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new $P;const YN=new XR,ZN=globalThis.performance||{};if(!ZN.now){let e=Date.now();ZN.timing&&ZN.timing.navigationStart&&(e=ZN.timing.navigationStart),ZN.now=()=>Date.now()-e}new VP;const JN={type:"postStep"},QN={type:"preStep"},eF={type:bR.COLLIDE_EVENT_NAME,body:null,contact:null},tF=[],nF=[],rF=[],iF=[],sF=[],oF=[],aF={type:"beginContact",bodyA:null,bodyB:null},lF={type:"endContact",bodyA:null,bodyB:null},cF={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},hF={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class uF{constructor(e){"object"==typeof e&&(e=e.notation),this.set=[],this.setkeys=[],this.setid=0,this.groups=[],this.totalDice=0,this.op="",this.constant="",this.result=[],this.error=!1,this.boost=1,this.notation=e,this.vectors=[],this.owner=-1,(!e||"0"==e)&&(this.error=!0);let t,n,r=this.notation;if(r){let e=r.split("!").length-1||0;e>0&&(this.boost=4*Math.min(Math.max(e,0),3)),r=r.split("!").join(""),r=r.split(" ").join(""),r.split("(").length-1!=r.split(")").length-1&&(this.error=!0),t=r.split("@"),n=t[0]}let i,s=RegExp(/(\+|\-|\*|\/|\%|\^|){0,1}()(\d*)([a-z]+\d+|[a-z]+|)(?:\{([a-z]+)(.*?|)\}|)()/,"i"),o=RegExp(/(\b)*(\-\d+|\d+)(\b)*/,"gi"),a=0,l=0,c=0;for(;!this.error&&n.length>0&&null!==(i=s.exec(n))&&a<30;){a++,n=n.substring(i[0].length);let e=i[1],t=i[2]&&i[2].length>0,r=i[3],s=i[4],o=i[5]||"",h=i[6]||"",u=i[7]&&i[7].length>0,d=!0;t&&(l+=i[2].length),h=h.split(","),(!h||h.length<1)&&(h=""),h.shift(),1==a&&0==n.length&&!s&&e&&r?(s="d20",this.op=e,this.constant=parseInt(r),r=1):a>1&&0==n.length&&!s&&(this.op=e,this.constant=parseInt(r),d=!1),d&&this.addSet(r,s,c,l,o,h,e),u&&(l-=i[7].length,c+=i[7].length)}!this.error&&t[1]&&null!==(i=t[1].match(o))&&this.result.push(...i)}stringify(e=!0){let t="";if(this.set.length<1)return t;for(let e=0;e<this.set.length;e++){let n=this.set[e];t+=e>0&&n.op?n.op:"",t+=n.num+n.type,n.func&&(t+="{",t+=n.func?n.func:"",t+=n.args?","+(Array.isArray(n.args)?n.args.join(","):n.args):"",t+="}")}return t+=this.constant?this.op+""+Math.abs(this.constant):"",e&&this.result&&this.result.length>0&&(t+="@"+this.result.join(",")),this.boost>1&&(t+="!".repeat(this.boost/4)),t}addSet(e,t,n=0,r=0,i="",s="",o="+"){e=Math.abs(parseInt(e||1));let a=o+""+t+n+r+i+s,l=null!=this.setkeys[a],c={};l&&(c=this.set[this.setkeys[a]-1]),e>0&&(c.num=l?e+c.num:e,c.type=t,c.sid=this.setid,c.gid=n,c.glvl=r,i&&(c.func=i),s&&(c.args=s),o&&(c.op=o),l?this.set[this.setkeys[a]-1]=c:this.setkeys[a]=this.set.push(c)),l||++this.setid}}const dF={d2:{name:"d2",labels:["1","2"],values:[1,2],inertia:8,mass:400,scale:.9,system:"dweird"},dc:{type:"d2",name:"Coin",labels:["./textures/silvercoin/tail.png","./textures/silvercoin/heads.png"],setBumpMaps:["./textures/silvercoin/tail_bump.png","./textures/silvercoin/heads_bump.png"],values:[0,1],inertia:8,mass:400,scale:.9,colorset:"coin_silver"},d1:{name:"One-sided Dice",type:"d6",labels:["1"],values:[1,1],scale:.9,system:"dweird"},d3:{name:"Three-Sided Dice",type:"d6",labels:["1","2","3"],values:[1,3],scale:.9,system:"dweird"},df:{name:"Fudge Dice",type:"d6",labels:["-","0","+"],values:[-1,1],scale:.9,system:"dweird"},d4:{name:"Four-Sided Dice",labels:["1","2","3","4"],values:[1,4],inertia:5,scale:1.2},d6:{name:"Six-Sided Dice (Numbers)",labels:["1","2","3","4","5","6"],values:[1,6],scale:.9},dpip:{name:"Six-Sided Dice (Pips)",type:"d6",labels:["   \n ⬤ \n   ","⬤  \n   \n  ⬤","⬤  \n ⬤ \n  ⬤","⬤ ⬤\n   \n⬤ ⬤","⬤ ⬤\n ⬤ \n⬤ ⬤","⬤ ⬤\n⬤ ⬤\n⬤ ⬤"],values:[1,6],scale:.9,font:"monospace"},dsex:{name:"Sex-Sided Emoji Dice",type:"d6",labels:["🍆","🍑","👌","💦","🙏","💥"],values:[1,6],scale:.9,display:"labels",system:"dweird"},dpoker:{name:"Poker Dice (9-Ace)",type:"d6",labels:["A","9","10","J","Q","K"],values:[1,6],scale:.9,display:"labels",system:"dweird",font:"Times New Roman"},dspanpoker:{name:"Spanish Poker Dice (7-Ace)",type:"d8",labels:["A","7","8","9","10","J","Q","K"],values:[1,8],display:"labels",system:"dweird",font:"Times New Roman"},disotope:{name:"Radioactive Twelve-Sided Dice",type:"d12",labels:["","","","","","","","","","","","☢️"],values:[0,0,0,0,0,0,0,0,0,0,0,1],mass:350,inertia:8,scale:.9,system:"dweird"},dsuit:{name:"Four-Suited Dice",type:"d4",labels:["♠️","♥️","♦️","♣️"],values:[1,4],inertia:5,scale:1.2,display:"labels",system:"dweird"},d8:{name:"Eight-Sided Dice",labels:["1","2","3","4","5","6","7","8"],values:[1,8]},d10:{name:"Ten-Sided Dice (Single Digit)",labels:["1","2","3","4","5","6","7","8","9","0"],values:[1,10],mass:350,inertia:9,scale:.9},d100:{name:"Ten-Sided Dice (Tens Digit)",type:"d10",labels:["10","20","30","40","50","60","70","80","90","00"],values:[10,100,10],mass:350,inertia:9,scale:.9},d12:{name:"Twelve-Sided Dice",labels:["1","2","3","4","5","6","7","8","9","10","11","12"],values:[1,12],mass:350,inertia:8,scale:.9},d20:{name:"Twenty-Sided Dice",labels:["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20"],values:[1,20],mass:400,inertia:6},dabi:{name:"Star Wars RPG: Ability Dice",type:"d8",labels:["s","a","s\na","s\ns","a","s","a\na",""],values:[1,8],font:"SWRPG-Symbol-Regular",color:"#00FF00",colorset:"swrpg_abi",display:"labels",system:"swrpg"},ddif:{name:"Star Wars RPG: Difficulty Dice",type:"d8",labels:["t","f","f\nt","t","","t\nt","f\nf","t"],values:[1,8],font:"SWRPG-Symbol-Regular",color:"#8000FC",colorset:"swrpg_dif",display:"labels",system:"swrpg"},dpro:{name:"Star Wars RPG: Proficiency Dice",type:"d12",labels:["a\na","a","a\na","x","s","s\na","s","s\na","s\ns","s\na","s\ns",""],values:[1,12],mass:350,inertia:8,scale:.9,font:"SWRPG-Symbol-Regular",color:"#FFFF00",colorset:"swrpg_pro",display:"labels",system:"swrpg"},dcha:{name:"Star Wars RPG: Challenge Dice",type:"d12",labels:["t\nt","t","t\nt","t","t\nf","f","t\nf","f","f\nf","y","f\nf",""],values:[1,12],mass:350,inertia:8,scale:.9,font:"SWRPG-Symbol-Regular",color:"#FF0000",colorset:"swrpg_cha",display:"labels",system:"swrpg"},dfor:{name:"Star Wars RPG: Force Dice",type:"d12",labels:["z","Z\nZ","z","Z\nZ","z","Z\nZ","z","Z","z","Z","z","z\nz"],values:[1,12],mass:350,inertia:8,scale:.9,font:"SWRPG-Symbol-Regular",color:"#FFFFFF",colorset:"swrpg_for",display:"labels",system:"swrpg"},dboo:{name:"Star Wars RPG: Boost Dice",type:"d6",labels:["s  \n  a","a  \n  a","s","a","",""],values:[1,6],scale:.9,font:"SWRPG-Symbol-Regular",color:"#00FFFF",colorset:"swrpg_boo",display:"labels",system:"swrpg"},dset:{name:"Star Wars RPG: Setback Dice",type:"d6",labels:["","t","f"],values:[1,3],scale:.9,font:"SWRPG-Symbol-Regular",color:"#111111",colorset:"swrpg_set",display:"labels",system:"swrpg"},swar:{name:"Star Wars Armada: Red Attack Dice",type:"d8",labels:["F","F","F\nF","E","E","G","",""],values:[1,8],font:"Armada-Symbol-Regular",color:"#FF0000",colorset:"swa_red",display:"labels",system:"swarmada"},swab:{name:"Star Wars Armada: Blue Attack Dice",type:"d8",labels:["F","F","F","F","E","E","G","G"],values:[1,8],font:"Armada-Symbol-Regular",color:"#0000FF",colorset:"swa_blue",display:"labels",system:"swarmada"},swak:{name:"Star Wars Armada: Black Attack Dice",type:"d8",labels:["F","F","F","F","F\nE","F\nE","",""],values:[1,8],font:"Armada-Symbol-Regular",color:"#111111",colorset:"swa_black",display:"labels",system:"swarmada"},xwatk:{name:"Star Wars X-Wing: Red Attack Dice",type:"d8",labels:["c","d","d","d","f","f","",""],values:[1,8],font:"XWing-Symbol-Regular",color:"#FF0000",colorset:"xwing_red",display:"labels",system:"xwing"},xwdef:{name:"Star Wars X-Wing: Green Defense Dice",type:"d8",labels:["e","e","e","f","f","","",""],values:[1,8],font:"XWing-Symbol-Regular",color:"#00FF00",colorset:"xwing_green",display:"labels",system:"xwing"},swlar:{name:"Star Wars Legion: Red Attack Dice",type:"d8",labels:["h","h","h","h","h","c","o",""],values:[1,8],font:"Legion-Symbol-Regular",color:"#FF0000",colorset:"swl_atkred",display:"labels",system:"legion"},swlab:{name:"Star Wars Legion: Black Attack Dice",type:"d8",labels:["h","h","h","","","c","o",""],values:[1,8],font:"Legion-Symbol-Regular",color:"#111111",colorset:"swl_atkblack",display:"labels",system:"legion"},swlaw:{name:"Star Wars Legion: White Attack Dice",type:"d8",labels:["h","","","","","c","o",""],values:[1,8],font:"Legion-Symbol-Regular",color:"#FFFFFF",colorset:"swl_atkwhite",display:"labels",system:"legion"},swldr:{name:"Star Wars Legion: Red Defense Dice",type:"d6",labels:["s","s","s","d","",""],values:[1,6],scale:.9,font:"Legion-Symbol-Regular",color:"#FF0000",colorset:"swl_defred",display:"labels",system:"legion"},swldw:{name:"Star Wars Legion: White Defense Dice",type:"d6",labels:["s","","","d","",""],values:[1,6],scale:.9,font:"Legion-Symbol-Regular",color:"#FFFFFF",colorset:"swl_defwhite",display:"labels",system:"legion"}},pF={vertices:[[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],faces:[[1,0,2,1],[0,1,3,2],[0,3,2,3],[1,2,3,4]]},fF={vertices:[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]],faces:[[0,3,2,1,1],[1,2,6,5,2],[0,1,5,4,3],[3,7,6,2,4],[0,4,7,3,5],[4,5,6,7,6]]},mF={vertices:[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],faces:[[0,2,4,1],[0,4,3,2],[0,3,5,3],[0,5,2,4],[1,3,4,5],[1,4,2,6],[1,2,5,7],[1,5,3,8]]},gF={vertices:[[1,0,-.105],[.809,.5877,.105],[.309,.951,-.105],[-.309,.951,.105],[-.809,.5877,-.105],[-1,0,.105],[-.809,-.587,-.105],[-.309,-.951,.105],[.309,-.951,-.105],[.809,-.5877,.105],[0,0,-1],[0,0,1]],faces:[[5,6,7,11,0],[4,3,2,10,1],[1,2,3,11,2],[0,9,8,10,3],[7,8,9,11,4],[8,7,6,10,5],[9,0,1,11,6],[2,1,0,10,7],[3,4,5,11,8],[6,5,4,10,9]]},yF={vertices:[[0,.618,1.618],[0,.618,-1.618],[0,-.618,1.618],[0,-.618,-1.618],[1.618,0,.618],[1.618,0,-.618],[-1.618,0,.618],[-1.618,0,-.618],[.618,1.618,0],[.618,-1.618,0],[-.618,1.618,0],[-.618,-1.618,0],[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]],faces:[[2,14,4,12,0,1],[15,9,11,19,3,2],[16,10,17,7,6,3],[6,7,19,11,18,4],[6,18,2,0,16,5],[18,11,9,14,2,6],[1,17,10,8,13,7],[1,13,5,15,3,8],[13,8,12,4,5,9],[5,4,14,9,15,10],[0,12,8,10,16,11],[3,19,7,17,1,12]]},bF={vertices:[[-1,1.618,0],[1,1.618,0],[-1,-1.618,0],[1,-1.618,0],[0,-1,1.618],[0,1,1.618],[0,-1,-1.618],[0,1,-1.618],[1.618,0,-1],[1.618,0,1],[-1.618,0,-1],[-1.618,0,1]],faces:[[0,11,5,1],[0,5,1,2],[0,1,7,3],[0,7,10,4],[0,10,11,5],[1,5,9,6],[5,11,4,7],[11,10,2,8],[10,7,6,9],[7,1,8,10],[3,9,4,11],[3,4,2,12],[3,2,6,13],[3,6,8,14],[3,8,9,15],[4,9,5,16],[2,4,11,17],[6,2,10,18],[8,6,7,19],[9,8,1,20]]},vF={name:"",scale:1,font:"Arial",color:"",labels:[],valueMap:[],values:[],normals:[],mass:300,inertia:13,geometry:null,display:"values",system:"d20"};class wF{constructor(e){if(!dF.hasOwnProperty(e))return console.error("dice type unavailable");Object.assign(this,vF,dF[e]),this.shape=dF[e].type||e,this.type=e,this.setLabels(this.labels),this.setValues(this.values[0],this.values[1],this.values[2]),this.setValueMap(this.valueMap),this.bumpMaps&&this.setBumpMaps(this.bumpMaps)}setValues(e=1,t=20,n=1){this.values=this.range(e,t,n)}setValueMap(e){for(let t=0;t<this.values.length;t++){let n=this.values[t];null!=e[n]&&(this.valueMap[n]=e[n])}}registerFaces(e,t="labels"){let n;if(n="labels"==t?this.labels:this.normals,n.unshift(""),["d2","d10"].includes(this.shape)||n.unshift(""),"d4"==this.shape){let t=e[0],n=e[1],r=e[2],i=e[3];this.labels=[[[],[0,0,0],[n,i,r],[t,r,i],[n,t,i],[t,n,r]],[[],[0,0,0],[n,r,i],[r,t,i],[n,i,t],[r,n,t]],[[],[0,0,0],[i,r,n],[r,i,t],[i,n,t],[r,t,n]],[[],[0,0,0],[i,n,r],[t,i,r],[i,t,n],[t,r,n]]]}else[].push.apply(n,e)}setLabels(e){this.loadTextures(e,this.registerFaces.bind(this),"labels")}setBumpMaps(e){this.loadTextures(e,this.registerFaces.bind(this),"bump")}loadTextures(e,t,n){let r=0,i=e.length,s=/\.(PNG|JPG|GIF|WEBP)$/i,o=Array(e.length),a=!1;for(let l=0;l<i;l++)""!=e[l]&&e[l].match(s)?(a=!0,o[l]=new Image,o[l].onload=()=>{++r>=i&&t(o,n)},o[l].src=e[l]):(o[l]=e[l],++r);a||t(o,n)}range(e,t,n=1){for(var r=[e],i=e;i<t;)r.push(i+=n||1);return r}}const xF={none:{name:"Plastic"},perfectmetal:{name:"Perfect Metal",color:14540253,roughness:0,metalness:1,envMapIntensity:1},metal:{name:"Metal",color:14540253,roughness:.5,metalness:.6,envMapIntensity:1},wood:{name:"Wood",color:14540253,roughness:.9,metalness:0,envMapIntensity:1},glass:{name:"Glass",color:14540253,roughness:.1,metalness:0,envMapIntensity:1}},_F={baseScale:100,bumpMapping:!0},EF=class{constructor(e){this.geometries={},this.materials_cache={},this.cache_hits=0,this.cache_misses=0,this.label_color="",this.dice_color="",this.edge_color="",this.label_outline="",this.dice_texture="",this.dice_material="",this.material_options={specular:16777215,color:11908533,shininess:5,flatShading:!0},Object.assign(this,_F,e)}updateConfig(e={}){Object.assign(this,e),e.scale&&this.scaleGeometry()}setBumpMapping(e){this.bumpMapping=e,this.materials_cache={}}create(e){let t=this.get(e);if(!t)return null;let n=this.geometries[e];if(n||(n=this.createGeometry(t.shape,t.scale*this.baseScale),this.geometries[e]=n),!n)return null;this.setMaterialInfo();let r=new AT(n,this.createMaterials(t,this.baseScale/2,1));switch(r.result=[],r.shape=t.shape,r.rerolls=0,r.resultReason="natural",r.mass=t.mass,r.getFaceValue=function(){let e,t=this.resultReason,n=new RA(0,0,"d4"==this.shape?-1:1),r=2*Math.PI,i=this.geometry.getAttribute("normal").array;for(let t=0,s=this.geometry.groups.length;t<s;++t){let s=this.geometry.groups[t];if(0==s.materialIndex)continue;let o=9*t,a=new RA(i[o],i[o+1],i[o+2]).clone().applyQuaternion(this.body.quaternion).angleTo(n);a<r&&(r=a,e=s)}let s=e.materialIndex-1;const o=EF.dice[this.notation.type];if("d4"==this.shape){let e=s-1==0?5:s;return{value:s,label:o.labels[s-1][e][0],reason:t}}return["d10","d2"].includes(this.shape)&&(s+=1),{value:o.values[(s-1)%o.values.length],label:o.labels[(s-1)%(o.labels.length-2)+2],reason:t}},r.storeRolledValue=function(e){this.resultReason=e||this.resultReason,this.result.push(this.getFaceValue())},r.getLastValue=function(){return!this.result||this.result.length<1?{value:void 0,label:"",reason:""}:this.result[this.result.length-1]},r.ignoreLastValue=function(e){let t=this.getLastValue();void 0!==t.value&&(t.ignore=e,this.setLastValue(t))},r.setLastValue=function(e){if(this.result&&!(this.result.length<1)&&e&&!(e.length<1))return this.result[this.result.length-1]=e},t.color&&(r.material[0].color=new wA(t.color),r.material[0].emissive=new wA(t.color),r.material[0].emissiveIntensity=1,r.material[0].needsUpdate=!0),t.values.length){case 1:return this.fixmaterials(r,1);case 2:return this.fixmaterials(r,2);case 3:return this.fixmaterials(r,3);default:return r}}get(e){let t;return EF.dice.hasOwnProperty(e)?t=EF.dice[e]:(t=new wF(e),EF.dice[e]=t),t}getGeometry(e){return this.geometries[e]}scaleGeometry(){}createMaterials(e,t,n,r=!0,i=0){let s=[],o=e.labels;"d4"==e.shape&&(o=e.labels[i],t=this.baseScale/2,n=2*this.baseScale);for(var a=0;a<o.length;++a){var l;let i;if("none"!=this.dice_material?(l=new PP(xF[this.dice_material])).envMapIntensity=0:l=new RP(this.material_options),0==a){let s={name:"none"};"source-over"!=this.dice_texture_rand.composite&&(s=this.dice_texture_rand),i=this.createTextMaterial(e,o,a,t,n,s,this.label_color_rand,this.label_outline_rand,this.edge_color_rand,r),l.map=i.composite}else if(i=this.createTextMaterial(e,o,a,t,n,this.dice_texture_rand,this.label_color_rand,this.label_outline_rand,this.dice_color_rand,r),l.map=i.composite,this.bumpMapping){{let e=.75;t>35&&(e=1),t>40&&(e=2.5),t>45&&(e=4),l.bumpScale=e}i.bump&&(l.bumpMap=i.bump),"d4"!=e.shape&&e.normals[a]&&(l.bumpMap=new AA(e.normals[a]),l.bumpScale=4,l.bumpMap.needsUpdate=!0)}l.opacity=1,l.transparent=!0,l.depthTest=!1,l.needUpdate=!0,s.push(l)}return s}createTextMaterial(e,t,n,r,i,s,o,a,l,c){if(void 0===t[n])return null;s=s||this.dice_texture_rand,o=o||this.label_color_rand,a=a||this.label_outline_rand,l=l||this.dice_color_rand,c=null==c||c;let h=t[n],u=!1,d=h;h instanceof HTMLImageElement?d=h.src:h instanceof Array&&h.forEach(e=>{d+=e.src});let p=e.type+d+n+s.name+o+a+l;if("d4"==e.shape&&(p=e.type+d+s.name+o+a+l),c&&null!=this.materials_cache[p])return this.cache_hits++,this.materials_cache[p];let f=document.createElement("canvas"),m=f.getContext("2d",{alpha:!0});m.globalAlpha=0,m.clearRect(0,0,f.width,f.height);let g,y=document.createElement("canvas"),b=y.getContext("2d",{alpha:!0});if(b.globalAlpha=0,b.clearRect(0,0,y.width,y.height),g="d4"==e.shape?4*this.calc_texture_size(r+i):4*this.calc_texture_size(r+2*r*i),f.width=f.height=g,y.width=y.height=g,m.fillStyle=l,m.fillRect(0,0,f.width,f.height),b.fillStyle="#FFFFFF",b.fillRect(0,0,y.width,y.height),s.texture&&""!=s.name&&"none"!=s.name?(m.globalCompositeOperation=s.composite||"source-over",m.drawImage(s.texture,0,0,f.width,f.height),m.globalCompositeOperation="source-over",s.bump&&(b.globalCompositeOperation="source-over",b.drawImage(s.bump,0,0,f.width,f.height))):m.globalCompositeOperation="source-over",m.globalCompositeOperation="source-over",m.textAlign="center",m.textBaseline="middle",b.textAlign="center",b.textBaseline="middle","d4"!=e.shape){let t={d8:{even:-7.5,odd:-127.5},d10:{all:-6},d12:{all:5},d20:{all:-7.5}}[e.shape];if(t){let e;if(e=t.hasOwnProperty("all")?t.all:n>0&&n%2!=0?t.odd:t.even,e&&0!=e){var v=f.width/2,w=f.height/2;m.translate(v,w),m.rotate(e*(Math.PI/180)),m.translate(-v,-w),b.translate(v,w),b.rotate(e*(Math.PI/180)),b.translate(-v,-w)}}if(h instanceof HTMLImageElement)u=!0,m.drawImage(h,0,0,h.width,h.height,0,0,f.width,f.height);else{let t=g/(1+2*i),n=f.height/2+10,r=f.width/2;"d10"==e.shape?(t*=.75,n=1.15*n-10):"d20"==e.shape&&(r*=.98),m.font=t+"pt "+e.font,b.font=t+"pt "+e.font;let s=1.4*m.measureText("M").width,c=h.split("\n");c.length>1&&(t/=c.length,m.font=t+"pt "+e.font,b.font=t+"pt "+e.font,s=1.2*m.measureText("M").width,n-=s*c.length/2);for(let e=0,t=c.length;e<t;e++){let t=c[e].trim();"none"!=a&&a!=l&&(m.strokeStyle=a,m.lineWidth=5,m.strokeText(c[e],r,n),b.strokeStyle="#000000",b.lineWidth=5,b.strokeText(c[e],r,n),("6"==t||"9"==t)&&(m.strokeText("  .",r,n),b.strokeText("  .",r,n))),m.fillStyle=o,m.fillText(c[e],r,n),b.fillStyle="#000000",b.fillText(c[e],r,n),("6"==t||"9"==t)&&(m.fillText("  .",r,n),b.fillText("  .",r,n)),n+=1.5*s}}}else{v=f.width/2,w=f.height/2;m.font=g/128*24+"pt "+e.font,b.font=g/128*24+"pt "+e.font;for(let e=0;e<h.length;e++){if(h[e]instanceof HTMLImageElement){let t=h[e].width/f.width;m.drawImage(h[e],0,0,h[e].width,h[e].height,100/t,25/t,60/t,60/t)}else"none"!=a&&a!=l&&(m.strokeStyle=a,m.lineWidth=5,m.strokeText(h[e],v,w-.3*g),b.strokeStyle="#000000",b.lineWidth=5,b.strokeText(h[e],v,w-.3*g)),m.fillStyle=o,m.fillText(h[e],v,w-.3*g),b.fillStyle="#000000",b.fillText(h[e],v,w-.3*g);m.translate(v,w),m.rotate(2*Math.PI/3),m.translate(-v,-w),b.translate(v,w),b.rotate(2*Math.PI/3),b.translate(-v,-w)}}var x,_=new TP(f);return x=u?null:new TP(y),c&&(this.cache_misses++,this.materials_cache[p]={composite:_,bump:x}),{composite:_,bump:x}}applyColorSet(e){var t;this.colordata=e,this.label_color=e.foreground,this.dice_color=e.background,this.label_outline=e.outline,this.dice_texture=e.texture,this.dice_material=(null==(t=null==e?void 0:e.texture)?void 0:t.material)||"none",this.edge_color=e.hasOwnProperty("edge")?e.edge:e.background}setMaterialInfo(e=""){let t=this.colordata,n=this.dice_texture,r=this.dice_material;if(this.dice_color_rand="",this.label_color_rand="",this.label_outline_rand="",this.dice_texture_rand="",this.dice_material_rand="",this.edge_color_rand="",Array.isArray(this.dice_color)){var i=Math.floor(Math.random()*this.dice_color.length);Array.isArray(this.label_color)&&this.label_color.length==this.dice_color.length&&(this.label_color_rand=this.label_color[i],Array.isArray(this.label_outline)&&this.label_outline.length==this.label_color.length&&(this.label_outline_rand=this.label_outline[i])),Array.isArray(this.dice_texture)&&this.dice_texture.length==this.dice_color.length&&(this.dice_texture_rand=this.dice_texture[i],this.dice_material_rand=this.dice_texture_rand.material),Array.isArray(this.edge_color)&&this.edge_color.length==this.dice_color.length&&(this.edge_color_rand=this.edge_color[i]),this.dice_color_rand=this.dice_color[i]}else this.dice_color_rand=this.dice_color;if(""==this.edge_color_rand)if(Array.isArray(this.edge_color)){i=Math.floor(Math.random()*this.edge_color.length);this.edge_color_rand=this.edge_color[i]}else this.edge_color_rand=this.edge_color;if(""==this.label_color_rand&&Array.isArray(this.label_color)){i=this.label_color[Math.floor(Math.random()*this.label_color.length)];Array.isArray(this.label_outline)&&this.label_outline.length==this.label_color.length&&(this.label_outline_rand=this.label_outline[i]),this.label_color_rand=this.label_color[i]}else""==this.label_color_rand&&(this.label_color_rand=this.label_color);if(""==this.label_outline_rand&&Array.isArray(this.label_outline)){i=this.label_outline[Math.floor(Math.random()*this.label_outline.length)];this.label_outline_rand=this.label_outline[i]}else""==this.label_outline_rand&&(this.label_outline_rand=this.label_outline);""==this.dice_texture_rand&&Array.isArray(this.dice_texture)?(this.dice_texture_rand=this.dice_texture[Math.floor(Math.random()*this.dice_texture.length)],this.dice_material_rand=this.dice_texture_rand.material||this.dice_material):""==this.dice_texture_rand&&(this.dice_texture_rand=this.dice_texture,this.dice_material_rand=this.dice_texture_rand.material||this.dice_material),""==this.dice_material_rand&&Array.isArray(this.dice_material)?this.dice_material_rand=this.dice_material[Math.floor(Math.random()*this.dice_material.length)]:""==this.dice_material_rand&&(this.dice_material_rand=this.dice_material),this.colordata&&this.colordata.id!=t.id&&this.applyColorSet(t,n,r)}calc_texture_size(e){return Math.pow(2,Math.floor(Math.log(e)/Math.log(2)))}createGeometry(e,t,n=!1){const r=n?"create_shape":"create_geom";switch(e){case"d2":var i=new IP(1*t,1*t,.1*t,32);return i.cannon_shape=new $D(1*t,1*t,.1*t,8),i;case"d4":return this[r](pF.vertices,pF.faces,t,-.1,7*Math.PI/6,.96);case"d6":return this[r](fF.vertices,fF.faces,t,.1,Math.PI/4,.96);case"d8":return this[r](mF.vertices,mF.faces,t,0,-Math.PI/4/2,.965);case"d10":return this[r](gF.vertices,gF.faces,t,.3,Math.PI,.945);case"d12":return this[r](yF.vertices,yF.faces,t,.2,-Math.PI/4/2,.968);case"d20":return this[r](bF.vertices,bF.faces,t,-.2,-Math.PI/4/2,.955);default:return console.error(`Geometry for ${e} is not available`),null}}fixmaterials(e,t){for(let r=0,i=e.geometry.groups.length;r<i;++r){var n=e.geometry.groups[r].materialIndex-2;if(n<t)continue;let i=n%t;e.geometry.groups[r].materialIndex=i+2}return e.geometry.elementsNeedUpdate=!0,e}create_shape(e,t,n){for(var r=Array(e.length),i=0;i<e.length;++i)r[i]=(new RA).fromArray(e[i]).normalize();var s=Array(e.length),o=Array(t.length);for(i=0;i<r.length;++i){var a=r[i];s[i]=new VP(a.x*n,a.y*n,a.z*n)}for(i=0;i<t.length;++i)o[i]=t[i].slice(0,t[i].length-1);return new iR({vertices:s,faces:o})}make_geom(e,t,n,r,i){let s=new lT;for(let t=0;t<e.length;++t)e[t]=e[t].multiplyScalar(n);let o=[];const a=[],l=[],c=new RA,h=new RA;let u,d=0;for(let n=0;n<t.length;++n){let p=t[n],f=p.length-1,m=2*Math.PI/f;u=p[f]+1;for(let t=0;t<f-2;++t)o.push(...e[p[0]].toArray()),o.push(...e[p[t+1]].toArray()),o.push(...e[p[t+2]].toArray()),c.subVectors(e[p[t+2]],e[p[t+1]]),h.subVectors(e[p[0]],e[p[t+1]]),c.cross(h),c.normalize(),a.push(...c.toArray()),a.push(...c.toArray()),a.push(...c.toArray()),l.push((Math.cos(i)+1+r)/2/(1+r),(Math.sin(i)+1+r)/2/(1+r)),l.push((Math.cos(m*(t+1)+i)+1+r)/2/(1+r),(Math.sin(m*(t+1)+i)+1+r)/2/(1+r)),l.push((Math.cos(m*(t+2)+i)+1+r)/2/(1+r),(Math.sin(m*(t+2)+i)+1+r)/2/(1+r));let g=3*(f-2);for(let e=0;e<g/3;e++)s.addGroup(d,3,u),d+=3}return s.setAttribute("position",new eT(o,3)),s.setAttribute("normal",new eT(a,3)),s.setAttribute("uv",new eT(l,2)),s.boundingSphere=new eC(new RA,n),s}make_d10_geom(e,t,n,r,i){let s=new lT;for(let t=0;t<e.length;++t)e[t]=e[t].multiplyScalar(n);let o=[];const a=[],l=[],c=new RA,h=new RA;let u,d=0;for(let n=0;n<t.length;++n){let m=t[n],g=m.length-1,y=2*Math.PI/g;u=m[g]+1;var p=1-.85,f=1-.895/1.105*.85;for(let s=0;s<g-2;++s)o.push(...e[m[0]].toArray()),o.push(...e[m[s+1]].toArray()),o.push(...e[m[s+2]].toArray()),c.subVectors(e[m[s+2]],e[m[s+1]]),h.subVectors(e[m[0]],e[m[s+1]]),c.cross(h),c.normalize(),a.push(...c.toArray()),a.push(...c.toArray()),a.push(...c.toArray()),-1==t[n][t[n].length-1]||s>=2?(l.push((Math.cos(i)+1+r)/2/(1+r),(Math.sin(i)+1+r)/2/(1+r)),l.push((Math.cos(y*(s+1)+i)+1+r)/2/(1+r),(Math.sin(y*(s+1)+i)+1+r)/2/(1+r)),l.push((Math.cos(y*(s+2)+i)+1+r)/2/(1+r),(Math.sin(y*(s+2)+i)+1+r)/2/(1+r))):0==s?(l.push(.175,f),l.push(.5,p),l.push(.825,f)):1==s&&(l.push(.175,f),l.push(.825,f),l.push(.5,1));let b=3*(g-2);for(let e=0;e<b/3;e++)s.addGroup(d,3,u),d+=3}return s.setAttribute("position",new eT(o,3)),s.setAttribute("normal",new eT(a,3)),s.setAttribute("uv",new eT(l,2)),s.boundingSphere=new eC(new RA,n),s}chamfer_geom(e,t,n){for(var r=[],i=[],s=Array(e.length),o=0;o<e.length;++o)s[o]=[];for(o=0;o<t.length;++o){for(var a=t[o],l=a.length-1,c=new RA,h=Array(l),u=0;u<l;++u){var d=e[a[u]].clone();c.add(d),s[a[u]].push(h[u]=r.push(d)-1)}c.divideScalar(l);for(u=0;u<l;++u){(d=r[h[u]]).subVectors(d,c).multiplyScalar(n).addVectors(d,c)}h.push(a[l]),i.push(h)}for(o=0;o<t.length-1;++o)for(u=o+1;u<t.length;++u){for(var p=[],f=-1,m=0;m<t[o].length-1;++m){var g=t[u].indexOf(t[o][m]);g>=0&&g<t[u].length-1&&(f>=0&&m!=f+1?p.unshift([o,m],[u,g]):p.push([o,m],[u,g]),f=m)}4==p.length&&i.push([i[p[0][0]][p[0][1]],i[p[1][0]][p[1][1]],i[p[3][0]][p[3][1]],i[p[2][0]][p[2][1]],-1])}for(o=0;o<s.length;++o){for(var y=s[o],b=(h=[y[0]],y.length-1);b;){for(m=t.length;m<i.length;++m){var v=i[m].indexOf(h[h.length-1]);if(v>=0&&v<4){-1==--v&&(v=3);var w=i[m][v];if(y.indexOf(w)>=0){h.push(w);break}}}--b}h.push(-1),i.push(h)}return{vectors:r,faces:i}}create_geom(e,t,n,r,i,s){for(var o=Array(e.length),a=0;a<e.length;++a)o[a]=(new RA).fromArray(e[a]).normalize();var l=this.chamfer_geom(o,t,s);if(10!=t.length)var c=this.make_geom(l.vectors,l.faces,n,r,i);else c=this.make_d10_geom(l.vectors,l.faces,n,r,i);return c.cannon_shape=this.create_shape(e,t,n),c.name="d"+t.length,c}};let SF=EF;((e,t,n)=>{((e,t,n)=>{t in e?jM(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,t+"",n)})(SF,"dice",{});const MF={cloudy:{name:"Clouds (Transparent)",composite:"destination-in",source:"./textures/cloudy.webp",source_bump:"./textures/cloudy.alt.webp"},cloudy_2:{name:"Clouds",composite:"multiply",source:"./textures/cloudy.alt.webp",source_bump:"./textures/cloudy.alt.webp"},fire:{name:"Fire",composite:"multiply",source:"./textures/fire.webp",source_bump:"./textures/fire.webp",material:"metal"},marble:{name:"Marble",composite:"multiply",source:"./textures/marble.webp",source_bump:"",material:"glass"},water:{name:"Water",composite:"destination-in",source:"./textures/water.webp",source_bump:"./textures/water.webp",material:"glass"},ice:{name:"Ice",composite:"destination-in",source:"./textures/ice.webp",source_bump:"./textures/ice.webp",material:"glass"},paper:{name:"Paper",composite:"multiply",source:"./textures/paper.webp",source_bump:"./textures/paper-bump.webp",material:"wood"},speckles:{name:"Speckles",composite:"multiply",source:"./textures/speckles.webp",source_bump:"./textures/speckles.webp",material:"none"},glitter:{name:"Glitter",composite:"multiply",source:"./textures/glitter.webp",source_bump:"./textures/glitter-bump.webp",material:"none"},glitter_2:{name:"Glitter (Transparent)",composite:"destination-in",source:"./textures/glitter-alpha.webp",source_bump:"",material:"none"},stars:{name:"Stars",composite:"multiply",source:"./textures/stars.webp",source_bump:"./textures/stars.webp",material:"none"},stainedglass:{name:"Stained Glass",composite:"multiply",source:"./textures/stainedglass.webp",source_bump:"./textures/stainedglass-bump.webp",material:"glass"},wood:{name:"Wood",composite:"multiply",source:"./textures/wood.webp",source_bump:"./textures/wood.webp",material:"wood"},metal:{name:"Stainless Steel",composite:"multiply",source:"./textures/metal.webp",source_bump:"./textures/metal-bump.webp",material:"metal"},skulls:{name:"Skulls",composite:"multiply",source:"./textures/skulls.webp",source_bump:"./textures/skulls.webp"},leopard:{name:"Leopard",composite:"multiply",source:"./textures/leopard.webp",source_bump:"./textures/leopard.webp",material:"wood"},tiger:{name:"Tiger",composite:"multiply",source:"./textures/tiger.webp",source_bump:"./textures/tiger.webp",material:"wood"},cheetah:{name:"Cheetah",composite:"multiply",source:"./textures/cheetah.webp",source_bump:"./textures/cheetah.webp",material:"wood"},dragon:{name:"Dragon",composite:"multiply",source:"./textures/dragon.webp",source_bump:"./textures/dragon-bump.webp",material:"none"},lizard:{name:"Lizard",composite:"multiply",source:"./textures/lizard.webp",source_bump:"./textures/lizard.webp",material:"none"},bird:{name:"Bird",composite:"multiply",source:"./textures/feather.webp",source_bump:"./textures/feather-bump.webp",material:"wood"},astral:{name:"Astral Sea",composite:"multiply",source:"./textures/astral.webp",source_bump:"./textures/stars.webp",material:"none"},acleaf:{name:"AC Leaf",composite:"multiply",source:"./textures/acleaf.webp",source_bump:"./textures/acleaf.webp",material:"none"},thecage:{name:"Nicholas Cage",composite:"multiply",source:"./textures/thecage.webp",source_bump:"",material:"metal"},isabelle:{name:"Isabelle",composite:"source-over",source:"./textures/isabelle.webp",source_bump:"",material:"none"},bronze01:{name:"bronze01",composite:"difference",source:"./textures/bronze/bronze01.webp",source_bump:"",material:"metal"},bronze02:{name:"bronze02",composite:"difference",source:"./textures/bronze/bronze02.webp",source_bump:"",material:"metal"},bronze03:{name:"bronze03",composite:"difference",source:"./textures/bronze/bronze03.webp",source_bump:"",material:"metal"},bronze03a:{name:"bronze03a",composite:"difference",source:"./textures/bronze/bronze03a.webp",source_bump:"",material:"metal"},bronze03b:{name:"bronze03b",composite:"difference",source:"./textures/bronze/bronze03b.webp",source_bump:"",material:"metal"},bronze04:{name:"bronze04",composite:"difference",source:"./textures/bronze/bronze04.webp",source_bump:"",material:"metal"},none:{name:"none",composite:"source-over",source:"",source_bump:"",material:""},"":{name:"~ Preset ~",composite:"source-over",source:"",source_bump:"",material:""}},AF={coin_default:{name:"Gold Coin",description:"Gold Dragonhead Coin",category:"Other",foreground:"#f6c928",background:"#f6c928",outline:"none",texture:"metal"},coin_silver:{name:"Silver Coin",description:"Gold Dragonhead Coin",category:"Other",foreground:"#f6c928",background:"#f6c928",outline:"none",texture:"metal"},radiant:{name:"Radiant",category:"Damage Types",foreground:"#F9B333",background:"#FFFFFF",outline:"",texture:"paper",description:"Radiant"},fire:{name:"Fire",category:"Damage Types",foreground:"#f8d84f",background:["#f8d84f","#f9b02d","#f43c04","#910200","#4c1009"],outline:"black",texture:"fire",description:"Fire"},ice:{name:"Ice",category:"Damage Types",foreground:"#60E9FF",background:["#214fa3","#3c6ac1","#253f70","#0b56e2","#09317a"],outline:"black",texture:"ice",description:"Ice"},poison:{name:"Poison",category:"Damage Types",foreground:"#D6A8FF",background:["#313866","#504099","#66409e","#934fc3","#c949fc"],outline:"black",texture:"cloudy",description:"Poison"},acid:{name:"Acid",category:"Damage Types",foreground:"#A9FF70",background:["#a6ff00","#83b625","#5ace04","#69f006","#b0f006","#93bc25"],outline:"black",texture:"marble",description:"Acid"},thunder:{name:"Thunder",category:"Damage Types",foreground:"#FFC500",background:"#7D7D7D",outline:"black",texture:"cloudy",description:"Thunder"},lightning:{name:"Lightning",category:"Damage Types",foreground:"#FFC500",background:["#f17105","#f3ca40","#eddea4","#df9a57","#dea54b"],outline:"#7D7D7D",texture:"ice",description:"Lightning"},air:{name:"Air",category:"Damage Types",foreground:"#ffffff",background:["#d0e5ea","#c3dee5","#a4ccd6","#8dafb7","#80a4ad"],outline:"black",texture:"cloudy",description:"Air"},water:{name:"Water",category:"Damage Types",foreground:"#60E9FF",background:["#87b8c4","#77a6b2","#6b98a3","#5b8691","#4b757f"],outline:"black",texture:"water",description:"Water"},earth:{name:"Earth",category:"Damage Types",foreground:"#6C9943",background:["#346804","#184200","#527f22","#3a1d04","#56341a","#331c17","#5a352a","#302210"],outline:"black",texture:"speckles",description:"Earth"},force:{name:"Force",category:"Damage Types",foreground:"white",background:["#FF97FF","#FF68FF","#C651C6"],outline:"#570000",texture:"stars",description:"Force"},psychic:{name:"Psychic",category:"Damage Types",foreground:"#D6A8FF",background:["#313866","#504099","#66409E","#934FC3","#C949FC","#313866"],outline:"black",texture:"speckles",description:"Psychic"},necrotic:{name:"Necrotic",category:"Damage Types",foreground:"#ffffff",background:"#6F0000",outline:"black",texture:"skulls",description:"Necrotic"},breebaby:{name:"Pastel Sunset",category:"Custom Sets",foreground:["#5E175E","#564A5E","#45455E","#3D5A5E","#1E595E","#5E3F3D","#5E1E29","#283C5E","#25295E"],background:["#FE89CF","#DFD4F2","#C2C2E8","#CCE7FA","#A1D9FC","#F3C3C2","#EB8993","#8EA1D2","#7477AD"],outline:"white",texture:"marble",description:"Pastel Sunset, for Breyanna"},pinkdreams:{name:"Pink Dreams",category:"Custom Sets",foreground:"white",background:["#ff007c","#df73ff","#f400a1","#df00ff","#ff33cc"],outline:"#570000",texture:"skulls",description:"Pink Dreams, for Ethan"},inspired:{name:"Inspired",category:"Custom Sets",foreground:"#FFD800",background:"#C4C4B6",outline:"#8E8E86",texture:"none",description:"Inspired, for Austin"},bloodmoon:{name:"Blood Moon",category:"Custom Sets",foreground:"#CDB800",background:"#6F0000",outline:"black",texture:"marble",description:"Blood Moon, for Jared"},starynight:{name:"Stary Night",category:"Custom Sets",foreground:"#4F708F",background:["#091636","#233660","#4F708F","#8597AD","#E2E2E2"],outline:"white",texture:"speckles",description:"Stary Night, for Mai"},glitterparty:{name:"Glitter Party",category:"Custom Sets",foreground:"white",background:["#FFB5F5","#7FC9FF","#A17FFF"],outline:"none",texture:"glitter",description:"Glitter Party, for Austin"},astralsea:{name:"Astral Sea",category:"Custom Sets",foreground:"#565656",background:"white",outline:"none",texture:"astral",description:"The Astral Sea, for Austin"},bronze:{name:"Thylean Bronze",description:"Thylean Bronze by @SpencerThayer",category:"Custom Sets",foreground:["#FF9159","#FFB066","#FFBF59","#FFD059"],background:["#705206","#7A4E06","#643100","#7A2D06"],outline:["#3D2D03","#472D04","#301700","#471A04"],edge:["#FF5D0D","#FF7B00","#FFA20D","#FFBA0D"],texture:["bronze01","bronze02","bronze03","bronze03a","bronze03b","bronze04"]},dragons:{name:"Here be Dragons",category:"Custom Sets",foreground:"#FFFFFF",background:["#B80000","#4D5A5A","#5BB8FF","#7E934E","#FFFFFF","#F6ED7C","#7797A3","#A78437","#862C1A","#FFDF8A"],outline:"black",texture:["dragon","lizard"],description:"Here be Dragons"},birdup:{name:"Bird Up",category:"Custom Sets",foreground:"#FFFFFF",background:["#F11602","#FFC000","#6EC832","#0094BC","#05608D","#FEABB3","#F75680","#F3F0DF","#C7A57F"],outline:"black",texture:"bird",description:"Bird Up!"},tigerking:{name:"Tiger King",category:"Other",foreground:"#ffffff",background:"#FFCC40",outline:"black",texture:["leopard","tiger","cheetah"],description:"Leopard Print"},covid:{name:"COViD",category:"Other",foreground:"#A9FF70",background:["#a6ff00","#83b625","#5ace04","#69f006","#b0f006","#93bc25"],outline:"black",texture:"fire",description:"Covid-19"},acleaf:{name:"Animal Crossing",category:"Other",foreground:"#00FF00",background:"#07540A",outline:"black",texture:"acleaf",description:"Animal Crossing Leaf"},isabelle:{name:"Isabelle",category:"Other",foreground:"white",background:"#FEE5CC",outline:"black",texture:"isabelle",description:"Isabelle"},thecage:{name:"Nicholas Cage",category:"Other",foreground:"#ffffff",background:"#ffffff",outline:"black",texture:"thecage",description:"Nicholas Cage"},test:{name:"Test",category:"Colors",foreground:["#00FF00","#0000FF","#FF0000"],background:["#FF0000","#00FF00","#0000FF"],outline:"black",texture:"none",description:"Test"},rainbow:{name:"Rainblow",category:"Colors",foreground:["#FF5959","#FFA74F","#FFFF56","#59FF59","#2374FF","#00FFFF","#FF59FF"],background:["#900000","#CE3900","#BCBC00","#00B500","#00008E","#008282","#A500A5"],outline:"black",texture:"none",description:"Rainblow"},black:{name:"Black",category:"Colors",foreground:"#ffffff",background:"#000000",outline:"black",texture:"none",description:"Black"},white:{name:"White",category:"Colors",foreground:"#000000",background:"#FFFFFF",outline:"#FFFFFF",texture:"none",description:"White"},swrpg_abi:{name:"Star Wars RPG - Ability",category:"Star Wars™ RPG",foreground:"#00FF00",background:["#3D9238","#52B848","#5EAC56","#9ECB9A"],outline:"#000000",texture:"cloudy_2",description:"Star Wars™ RPG Ability Dice"},swrpg_pro:{name:"Star Wars RPG - Proficiency",category:"Star Wars™ RPG",foreground:"#FFFF00",background:["#CABB1C","#F9E33B","#FFE900","#F0E49D"],outline:"#000000",texture:"paper",description:"Star Wars™ RPG Proficiency Dice"},swrpg_dif:{name:"Star Wars RPG - Difficulty",category:"Star Wars™ RPG",foreground:"#8000FC",background:["#39165F","#664B84","#50247E","#745F88"],outline:"#000000",texture:"cloudy_2",description:"Star Wars™ RPG Difficulty Dice"},swrpg_cha:{name:"Star Wars RPG - Challenge",category:"Star Wars™ RPG",foreground:"#FF0000",background:["#A91F32","#EB4254","#E51836","#BA3645"],outline:"#000000",texture:"paper",description:"Star Wars™ RPG Challenge Dice"},swrpg_boo:{name:"Star Wars RPG - Boost",category:"Star Wars™ RPG",foreground:"#00FFFF",background:["#4B9DC6","#689FC4","#85CFF2","#8FC0D8"],outline:"#000000",texture:"glitter",description:"Star Wars™ RPG Boost Dice"},swrpg_set:{name:"Star Wars RPG - Setback",category:"Star Wars™ RPG",foreground:"#111111",background:["#252223","#241F21","#282828","#111111"],outline:"#ffffff",texture:"glitter",description:"Star Wars™ RPG Setback Dice"},swrpg_for:{name:"Star Wars RPG - Force",category:"Star Wars™ RPG",foreground:"#000000",background:["#F3F3F3","#D3D3D3","#BABABA","#FFFFFF"],outline:"#FFFFFF",texture:"stars",description:"Star Wars™ RPG Force Dice"},swa_red:{name:"Armada Attack - Red",category:"Star Wars™ Armada",foreground:"#ffffff",background:["#440D19","#8A1425","#C72336","#C04551"],outline:"none",texture:"stainedglass",description:"Star Wars™ Armada Red Attack Dice"},swa_blue:{name:"Armada Attack - Blue",category:"Star Wars™ Armada",foreground:"#ffffff",background:["#212642","#28286E","#2B348C","#3D4BB5","#5D64AB"],outline:"none",texture:"stainedglass",description:"Star Wars™ Armada Blue Attack Dice"},swa_black:{name:"Armada Attack - Black",category:"Star Wars™ Armada",foreground:"#ffffff",background:["#252223","#241F21","#282828","#111111"],outline:"none",texture:"stainedglass",description:"Star Wars™ Armada Black Attack Dice"},xwing_red:{name:"X-Wing Attack - Red",category:"Star Wars™ X-Wing",foreground:"#ffffff",background:["#440D19","#8A1425","#C72336","#C04551"],outline:"none",texture:"stars",description:"Star Wars™ X-Wing Red Attack Dice"},xwing_green:{name:"X-Wing Attack - Green",category:"Star Wars™ X-Wing",foreground:"#ffffff",background:["#3D9238","#52B848","#5EAC56","#9ECB9A"],outline:"none",texture:"stars",description:"Star Wars™ X-Wing Green Attack Dice"},swl_atkred:{name:"Legion Attack - Red",category:"Star Wars™ Legion",foreground:"#ffffff",background:["#440D19","#8A1425","#C72336","#C04551"],outline:"none",texture:"fire",description:"Star Wars™ Legion Red Attack Dice"},swl_atkblack:{name:"Legion Attack - Black",category:"Star Wars™ Legion",foreground:"#ffffff",background:["#252223","#241F21","#282828","#111111"],outline:"none",texture:"fire",description:"Star Wars™ Legion Black Attack Dice"},swl_atkwhite:{name:"Legion Attack - White",category:"Star Wars™ Legion",foreground:"#000000",background:["#ffffff","#DFF4FA","#BCBCBC","#F1EDE2","#F2ECE0"],outline:"none",texture:"fire",description:"Star Wars™ Legion White Attack Dice"},swl_defred:{name:"Legion Defense - Red",category:"Star Wars™ Legion",foreground:"#ffffff",background:["#440D19","#8A1425","#C72336","#C04551"],outline:"none",texture:"fire",description:"Star Wars™ Legion Red Defense Dice"},swl_defwhite:{name:"Legion Defense - White",category:"Star Wars™ Legion",foreground:"#000000",background:["#ffffff","#DFF4FA","#BCBCBC","#F1EDE2","#F2ECE0"],outline:"none",texture:"fire",description:"Star Wars™ Legion White Defense Dice"}};class CF{constructor(){this.colorsets=[]}async ImageLoader(e){if(Array.isArray(e)){for(let t=0,n=e.length;t<n;t++)e[t]=await this.ImageLoader(e[t]);return e}return e.source&&""!=e.source&&(e.texture=await this.loadImage(e.source)),e.source_bump&&""!=e.source_bump&&(e.bump=await this.loadImage(e.source_bump)),e}loadImage(e){return new Promise((t,n)=>{let r=new Image;r.onload=()=>t(r),r.crossOrigin="anonymous",r.src=e,r.onerror=e=>n(e)}).catch(()=>{console.error("Unable to load image texture")})}async getColorSet(e){let t,n;if("string"==typeof e&&(t=e),"object"==typeof e&&(t=e.colorset),this.colorsets.hasOwnProperty(t))return this.colorsets[t];let r=AF[t];return n=e.texture||r.texture,r.texture=this.getTexture(n),r.texture=await this.ImageLoader(r.texture),e.material&&(r.texture.material=e.material),this.colorsets[t]=r,r}async makeColorSet(e={}){if(this.colorsets.hasOwnProperty(e.name))return this.colorsets[e.name];let t=Object.assign({},AF.white,e),n=this.getTexture(t.texture);return t.texture=await this.ImageLoader(n),e.material&&(t.texture.material=e.material),"white"===t.name.toLowerCase()&&(t.name=""+Date.now()),this.colorsets[t.name]=t,t}getTexture(e){if(Array.isArray(e)){let t=[];for(let n=0,r=e.length;n<r;n++)t.push(this.getTexture(e[n]));return t}return MF.hasOwnProperty(e)?MF[e]:MF.none}}const TF={default:{name:"Solid Color",author:"MajorVictory",showColorPicker:!0,surface:"wood_tray",colors:{fg:"#9794ff",bg:"#0b1a3e"},cubeMap:["envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg"]},"blue-felt":{name:"Blue Felt",author:"MajorVictory",showColorPicker:!0,surface:"felt",colors:{fg:"#9794ff",bg:"#0b1a3e"},cubeMap:["envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg"]},"red-felt":{name:"Red Felt",author:"MajorVictory",showColorPicker:!0,surface:"felt",colors:{fg:"#ff9494",bg:"#4d1e1e"},cubeMap:["envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg"]},"green-felt":{name:"Green Felt",author:"MajorVictory",showColorPicker:!0,surface:"felt",colors:{fg:"#97ff94",bg:"#244d1e"},cubeMap:["envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg","envmap.jpg"]},taverntable:{name:"Old Tavern Table",author:"MajorVictory",showColorPicker:!0,surface:"wood_table",colors:{fg:"#9794ff",bg:"#0b1a3e"},cubeMap:["px.png","nx.png","py.png","ny.png","pz.png","nz.png"]},mahogany:{name:"(Mah-Hog-Any)",author:"MajorVictory",showColorPicker:!0,surface:"wood_table",colors:{fg:"#9794ff",bg:"#0b1a3e"},cubeMap:["px.png","nx.png","py.png","ny.png","pz.png","nz.png"]},stainless:{name:"Stainless Steel",author:"MajorVictory",showColorPicker:!0,surface:"metal",colors:{fg:"#9794ff",bg:"#0b1a3e"},cubeMap:["px.png","nx.png","py.png","ny.png","pz.png","nz.png"]},cyberpunk:{name:"Neo-New-Future-City",author:"MajorVictory",showColorPicker:!0,surface:"metal",colors:{fg:"#3494A6",bg:"#440B28"},cubeMap:["px.png","nx.png","py.png","ny.png","pz.png","nz.png"]},cagetown:{name:"Cage Town",author:"MajorVictory",showColorPicker:!0,surface:"wood_table",colors:{fg:"#D7A866",bg:"#282811"},cubeMap:["px.png","nx.png","py.png","ny.png","pz.png","nz.png"]}},IF=e=>{let t;return function(){let n=this,r=arguments;t&&window.cancelAnimationFrame(t),t=window.requestAnimationFrame(()=>{e.apply(n,r)})}},LF={framerate:1/60,sounds:!1,volume:100,color_spotlight:15720405,shadows:!0,theme_surface:"green-felt",sound_dieMaterial:"plastic",theme_customColorset:null,theme_colorset:"white",theme_texture:"",theme_material:"glass",gravity_multiplier:400,light_intensity:.7,baseScale:100,strength:1,onRollComplete(){}};class PF{constructor(e,t={}){this.container=document.querySelector(e),this.dimensions=new oA(this.container.clientWidth,this.container.clientHeight),this.adaptive_timestep=!1,this.last_time=0,this.running=!1,this.rolling=!1,this.threadid,this.display={currentWidth:null,currentHeight:null,containerWidth:null,containerHeight:null,aspect:null,scale:null},this.cameraHeight={max:null,close:null,medium:null,far:null},this.scene=new CP,this.world=new XN,this.dice_body_material=new jD,this.sounds_table={},this.sounds_dice=[],this.lastSoundType="",this.lastSoundStep=0,this.lastSound=0,this.iteration,this.renderer,this.barrier,this.camera,this.light,this.light_amb,this.desk,this.box_body={},this.bodies=[],this.meshes=[],this.diceList=[],this.soundDelay=10,this.animstate="",this.tally=!0,this.selector={animate:!0,rotate:!0,intersected:null,dice:[]},Object.assign(this,LF,t),this.DiceColors=new CF,this.DiceFactory=new SF({baseScale:this.baseScale}),this.DiceFactory.setBumpMapping(!0),this.surface=TF[this.theme_surface].surface}enableShadows(){this.shadows=!0,this.renderer&&(this.renderer.shadowMap.enabled=this.shadows),this.light&&(this.light.castShadow=this.shadows),this.desk&&(this.desk.receiveShadow=this.shadows)}disableShadows(){this.shadows=!1,this.renderer&&(this.renderer.shadowMap.enabled=this.shadows),this.light&&(this.light.castShadow=this.shadows),this.desk&&(this.desk.receiveShadow=this.shadows)}async initialize(){this.renderer=new AP({antialias:!0,alpha:!0}),this.container.appendChild(this.renderer.domElement),this.renderer.shadowMap.enabled=this.shadows,this.renderer.shadowMap.type=2,this.renderer.setClearColor(0,0),this.setDimensions(this.dimensions),this.world.gravity.set(0,0,-9.8*this.gravity_multiplier),this.world.broadphase=new OR,this.world.solver.iterations=14,this.world.allowSleep=!0,this.makeWorldBox(),this.resizeWorld(),await this.loadTheme({colorset:this.theme_colorset,texture:this.theme_texture,material:this.theme_material}).catch(()=>{throw Error("Unable to load theme")}),this.sounds&&await this.loadSounds().catch(()=>{throw Error("Unable to load sounds")}),this.renderer.render(this.scene,this.camera)}makeWorldBox(){Object.keys(this.box_body).length&&(this.world.removeBody(this.box_body.desk),this.world.removeBody(this.box_body.topWall),this.world.removeBody(this.box_body.bottomWall),this.world.removeBody(this.box_body.leftWall),this.world.removeBody(this.box_body.rightWall));const e=new jD,t=new jD;this.world.addContactMaterial(new WD(e,this.dice_body_material,{mass:0,friction:.6,restitution:.5})),this.world.addContactMaterial(new WD(t,this.dice_body_material,{mass:0,friction:.6,restitution:1})),this.world.addContactMaterial(new WD(this.dice_body_material,this.dice_body_material,{mass:0,friction:.6,restitution:.5})),this.box_body.desk=new bR({allowSleep:!1,mass:0,shape:new KD,material:e}),this.world.addBody(this.box_body.desk),this.box_body.topWall=new bR({allowSleep:!1,mass:0,shape:new KD,material:t}),this.box_body.topWall.quaternion.setFromAxisAngle(new VP(1,0,0),Math.PI/2),this.box_body.topWall.position.set(0,.93*this.display.containerHeight,0),this.world.addBody(this.box_body.topWall),this.box_body.bottomWall=new bR({allowSleep:!1,mass:0,shape:new KD,material:t}),this.box_body.bottomWall.quaternion.setFromAxisAngle(new VP(1,0,0),-Math.PI/2),this.box_body.bottomWall.position.set(0,.93*-this.display.containerHeight,0),this.world.addBody(this.box_body.bottomWall),this.box_body.leftWall=new bR({allowSleep:!1,mass:0,shape:new KD,material:t}),this.box_body.leftWall.quaternion.setFromAxisAngle(new VP(0,1,0),-Math.PI/2),this.box_body.leftWall.position.set(.93*this.display.containerWidth,0,0),this.world.addBody(this.box_body.leftWall),this.box_body.rightWall=new bR({allowSleep:!1,mass:0,shape:new KD,material:t}),this.box_body.rightWall.quaternion.setFromAxisAngle(new VP(0,1,0),Math.PI/2),this.box_body.rightWall.position.set(.93*-this.display.containerWidth,0,0),this.world.addBody(this.box_body.rightWall)}async loadTheme(e){let t;t=this.theme_customColorset?await this.DiceColors.makeColorSet(this.theme_customColorset):await this.DiceColors.getColorSet(e),this.DiceFactory.applyColorSet(t),this.colorData=t}async loadSounds(){let e={felt:7,wood_table:7,wood_tray:7,metal:9},t={coin:6,metal:12,plastic:15,wood:12};const n=this.colorData.texture.material.match(/wood|metal/g);if(this.sound_dieMaterial=n?this.colorData.texture.material:"plastic",!this.sounds_table.hasOwnProperty(this.surface)){this.sounds_table[this.surface]=[];let t=e[this.surface];for(let e=1;e<=t;++e){const t=await this.loadAudio("./sounds/surfaces/surface_"+this.surface+e+".mp3");this.sounds_table[this.surface].push(t)}}if(!this.sounds_dice.hasOwnProperty("coin")){this.sounds_dice.coin=[];let e=t.coin;for(let t=1;t<=e;++t){const e=await this.loadAudio("./sounds/dicehit/dicehit_coin"+t+".mp3");this.sounds_dice.coin.push(e)}}if(!this.sounds_dice.hasOwnProperty(this.sound_dieMaterial)){this.sounds_dice[this.sound_dieMaterial]=[];let e=t[this.sound_dieMaterial];for(let t=1;t<=e;++t){const e=await this.loadAudio("./sounds/dicehit/dicehit_"+this.sound_dieMaterial+t+".mp3");this.sounds_dice[this.sound_dieMaterial].push(e)}}}loadAudio(e){return new Promise((t,n)=>{let r=new Audio;r.oncanplaythrough=()=>t(r),r.crossOrigin="anonymous",r.src=e,r.onerror=e=>n(e)}).catch(()=>{console.error("Unable to load audio")})}async updateConfig(e={}){Object.apply(this,e),this.theme_customColorset=e.theme_customColorset?e.theme_customColorset:null,e.theme_colorset&&(this.theme_colorset=e.theme_colorset),e.theme_texture&&(this.theme_texture=e.theme_texture),e.theme_material&&(this.theme_material=e.theme_material),(e.theme_colorset||e.theme_texture||e.theme_material||e.theme_customColorset)&&await this.loadTheme({colorset:this.theme_colorset,texture:this.theme_texture,material:this.theme_material})}setDimensions(e){if("selector"===(this.display.currentWidth=this.container.clientWidth/2,this.display.currentHeight=this.container.clientHeight/2,e?(this.display.containerWidth=e.x,this.display.containerHeight=e.y):(this.display.containerWidth=this.display.currentWidth,this.display.containerHeight=this.display.currentHeight),this.display.aspect=Math.min(this.display.currentWidth/this.display.containerWidth,this.display.currentHeight/this.display.containerHeight),this.display.scale=Math.sqrt(this.display.containerWidth*this.display.containerWidth+this.display.containerHeight*this.display.containerHeight)/13,this.makeWorldBox(),this.renderer.setSize(2*this.display.currentWidth,2*this.display.currentHeight),this.cameraHeight.max=this.display.currentHeight/this.display.aspect/.17632698070846498,this.cameraHeight.medium=this.cameraHeight.max/1.5,this.cameraHeight.far=this.cameraHeight.max,this.cameraHeight.close=this.cameraHeight.max/2,this.camera&&this.scene.remove(this.camera),this.camera=new kT(20,this.display.currentWidth/this.display.currentHeight,1,1.3*this.cameraHeight.max),this.animstate))this.camera.position.z=this.selector.dice.length>9?this.cameraHeight.far:this.selector.dice.length<6?this.cameraHeight.close:this.cameraHeight.medium;else this.camera.position.z=this.cameraHeight.far;this.camera.lookAt(new RA(0,0,0));const t=Math.max(this.display.containerWidth,this.display.containerHeight);this.light&&this.scene.remove(this.light),this.light_amb&&this.scene.remove(this.light_amb),this.light=new UP(this.color_spotlight,this.light_intensity),this.light.position.set(-t/2,t/2,3*t),this.light.target.position.set(0,0,0),this.light.distance=5*t,this.light.angle=Math.PI/4,this.light.castShadow=this.shadows,this.light.shadow.camera.near=t/10,this.light.shadow.camera.far=5*t,this.light.shadow.camera.fov=50,this.light.shadow.bias=.001,this.light.shadow.mapSize.width=1024,this.light.shadow.mapSize.height=1024,this.scene.add(this.light),this.light_amb=new kP(16777147,6776689,this.light_intensity),this.scene.add(this.light_amb),this.desk&&this.scene.remove(this.desk);let n=new LP;n.opacity=.5,this.desk=new AT(new KT(6*this.display.containerWidth,6*this.display.containerHeight,1,1),n),this.desk.receiveShadow=this.shadows,this.scene.add(this.desk),this.renderer.render(this.scene,this.camera)}resizeWorld(){const e=IF(()=>{const e=this.renderer.domElement,t=this.container.clientWidth,n=this.container.clientHeight,r=e.width!==t||e.height!==n;return r&&this.setDimensions(new oA(this.container.clientWidth,this.container.clientHeight)),r});window.addEventListener("resize",e)}vectorRand({x:e,y:t}){let n=Math.random()*Math.PI/5-Math.PI/5/2,r={x:e*Math.cos(n)-t*Math.sin(n),y:e*Math.sin(n)+t*Math.cos(n)};return 0==r.x&&(r.x=.01),0==r.y&&(r.y=.01),r}getNotationVectors(e,t,n,r){let i=new uF(e);this.lastNotation=i;for(let e in i.set){const s=this.DiceFactory.get(i.set[e].type);let o=i.set[e].num,a=i.set[e].op,l=i.set[e].sid,c=i.set[e].gid,h=i.set[e].glvl,u=i.set[e].func,d=i.set[e].args;for(let e=0;e<o;e++){let e=this.vectorRand(t);e.x/=r,e.y/=r;let o={x:this.display.containerWidth*(e.x>0?-1:1)*.9,y:this.display.containerHeight*(e.y>0?-1:1)*.9,z:200*Math.random()+200},p=Math.abs(e.x/e.y);p>1?o.y/=p:o.x*=p;let f,m,g,y=this.vectorRand(t);y.x/=r,y.y/=r,"d2"!=s.shape?(f={x:y.x*n,y:y.y*n,z:-10},m={x:-(Math.random()*e.y*5+s.inertia*e.y),y:Math.random()*e.x*5+s.inertia*e.x,z:0},g={x:Math.random(),y:Math.random(),z:Math.random(),a:Math.random()}):(f={x:y.x*n/10,y:y.y*n/10,z:3e3},m={x:12*s.inertia,y:1*s.inertia,z:0},g={x:1,y:1,z:Math.random(),a:Math.random()}),i.vectors.push({type:s.type,op:a,sid:l,gid:c,glvl:h,func:u,args:d,pos:o,velocity:f,angle:m,axis:g})}}return i}swapDiceFace(e,t){const n=this.DiceFactory.get(e.notation.type);if("d4"==n.shape)return void this.swapDiceFace_D4(e,t);n.values;let r=parseInt(e.getLastValue().value);t=parseInt(t),"d10"==e.notation.type&&0==r&&(r=10),"d100"==e.notation.type&&0==r&&(r=100),"d100"==e.notation.type&&r>0&&r<10&&(r*=10),"d10"==e.notation.type&&0==t&&(t=10),"d100"==e.notation.type&&0==t&&(t=100),"d100"==e.notation.type&&t>0&&t<10&&(t*=10);let i=n.values.indexOf(r),s=n.values.indexOf(t);if(i<0||s<0||i==s)return;let o=e.geometry.clone(),a=[],l=[],c=2;"d10"==n.shape&&(c=1);let h,u=s+c;"d2"!=n.shape?(h=i+c,u=s+c):(h=i+1,u=s+1);for(var d=0,p=o.groups.length;d<p;++d){const e=o.groups[d].materialIndex;e!=h?e!=u||l.push(d):a.push(d)}if(!(a.length<=0||l.length<=0)){for(let e=0,t=l.length;e<t;e++)o.groups[l[e]].materialIndex=h;for(let e=0,t=a.length;e<t;e++)o.groups[a[e]].materialIndex=u;e.geometry=o}}swapDiceFace_D4(e,t){const n=this.DiceFactory.get(e.notation.type);let r=parseInt(e.getLastValue().value);if(!(r>=1&&r<=4))return;let i=(t=parseInt(t))-r,s=e.geometry.clone();for(let e=0,t=s.groups.length;e<t;++e){const t=s.groups[e];let n=t.materialIndex;if(0!=n){for(n+=i-1;n>4;)n-=4;for(;n<1;)n+=4;t.materialIndex=n+1}}0!=i&&(i<0&&(i+=4),e.material=this.DiceFactory.createMaterials(n,0,0,!1,i)),e.geometry=s}spawnDice(e){let t=this.DiceFactory.create(e.type,this.colorData);!t||(t.notation=e,t.result=[],t.stopped=0,t.castShadow=this.shadows,t.body=new bR({allowSleep:!0,sleepSpeedLimit:75,sleepTimeLimit:.9,mass:t.mass,shape:t.geometry.cannon_shape,material:this.dice_body_material}),t.body.type=bR.DYNAMIC,t.body.position.set(e.pos.x,e.pos.y,e.pos.z),t.body.quaternion.setFromAxisAngle(new VP(e.axis.x,e.axis.y,e.axis.z),e.axis.a*Math.PI*2),t.body.angularVelocity.set(e.angle.x,e.angle.y,e.angle.z),t.body.velocity.set(e.velocity.x,e.velocity.y,e.velocity.z),t.body.linearDamping=.1,t.body.angularDamping=.1,t.body.diceShape=t.shape,t.body.addEventListener("collide",this.eventCollide.bind(this)),this.scene.add(t),this.diceList.push(t),this.world.addBody(t.body))}eventCollide({body:e,target:t}){if("simulate"==this.animstate||!this.sounds||!e||this.volume<=0)return;let n=Date.now(),r=e.mass>0?"dice":"table";if(!((this.lastSoundStep==e.world.stepnumber||this.lastSound>n)&&"dice"!=r||(this.lastSoundStep==e.world.stepnumber||this.lastSound>n)&&"dice"==r&&"dice"==this.lastSoundType)){if(e.mass>0){let t,n=e.velocity.length();if(n<250)return;t="d2"===e.diceShape?this.sounds_dice.coin[Math.floor(Math.random()*this.sounds_dice.coin.length)]:this.sounds_dice[this.sound_dieMaterial][Math.floor(Math.random()*this.sounds_dice[this.sound_dieMaterial].length)],t&&(t.volume=Math.min(n/8e3,this.volume/100),t.play().catch(()=>{})),this.lastSoundType="dice"}else{let e=t.velocity.length();if(e<250)return;let n=this.surface,r=this.sounds_table[n],i=r[Math.floor(Math.random()*r.length)];i&&(i.volume=Math.min(e/8e3,this.volume/100),i.play().catch(()=>{})),this.lastSoundType="table"}this.lastSoundStep=e.world.stepnumber,this.lastSound=n+this.soundDelay}}resetDice(e,{pos:t,axis:n,angle:r,velocity:i}){e.stopped=0,this.world.removeBody(e.body),e.body=new bR({allowSleep:!0,sleepSpeedLimit:75,sleepTimeLimit:.9,mass:e.body.mass,shape:e.geometry.cannon_shape,material:this.dice_body_material}),e.body.type=bR.DYNAMIC,e.body.position.set(t.x,t.y,t.z),e.body.quaternion.setFromAxisAngle(new VP(n.x,n.y,n.z),n.a*Math.PI*2),e.body.angularVelocity.set(r.x,r.y,r.z),e.body.velocity.set(i.x,i.y,i.z),e.body.linearDamping=.1,e.body.angularDamping=.1,e.body.diceShape=e.shape,e.body.addEventListener("collide",this.eventCollide.bind(this)),this.world.addBody(e.body),e.body.sleepState=0}checkForRethrow(e){e.notation.func&&e.notation.func.toLowerCase();return!1}throwFinished(e){if(this.iteration>1e3)return!0;if(this.iteration<10/this.framerate)for(let e=0,t=this.diceList.length;e<t;++e){let t=this.diceList[e],n=!1;if(t.body.sleepState<bR.SLEEPING)return!1;if(t.body.sleepState==bR.SLEEPING){if(0==t.result.length?(t.storeRolledValue("natural"),n=this.checkForRethrow(t)):t.result.length>0&&t.rerolling&&(t.rerolling=!1,t.storeRolledValue("reroll"),n=this.checkForRethrow(t)),n)return t.rerolls+=1,t.rerolling=!0,t.body.wakeUp(),t.body.type=bR.DYNAMIC,t.body.angularVelocity=new VP(25,25,25),t.body.velocity=new VP(0,0,3e3),!1;t.rerolling=!1,t.body.type=bR.KINEMATIC}}return!0}simulateThrow(){for(this.animstate="simulate",this.iteration=0,this.rolling=!0;!this.throwFinished(!0);)++this.iteration,this.world.step(this.framerate)}animateThrow(e,t,n){this.animstate="throw";let r=(new Date).getTime();this.last_time=this.last_time||r-1e3*this.framerate;let i=(r-this.last_time)/1e3;++this.iteration;let s=Math.floor(i/this.framerate);this.container.style.opacity="1";for(let e=0;e<s;e++)this.world.step(this.framerate),++this.steps;for(let e in this.scene.children){let t=this.scene.children[e];null!=t.body&&(t.position.copy(t.body.position),t.quaternion.copy(t.body.quaternion))}if(this.renderer.render(this.scene,this.camera),this.last_time=this.last_time+s*this.framerate*1e3,this.running==e&&this.throwFinished())return this.running=!1,this.rolling=!1,t&&t.call(this,n),this.running=(new Date).getTime(),void this.animateAfterThrow(this.running);this.running==e&&((e,t,n,r,s)=>{!n&&i<this.framerate?setTimeout(()=>{requestAnimationFrame(()=>{e.call(this,t,r,s)})},1e3*(this.framerate-i)):requestAnimationFrame(()=>{e.call(this,t,r,s)})}).bind(this)(this.animateThrow,e,this.adaptive_timestep,t,n)}animateAfterThrow(e){this.animstate="afterthrow";let t=(new Date).getTime(),n=(t-this.last_time)/1e3;n>3&&(n=this.framerate),this.running=!1,this.last_time=t,this.renderer.render(this.scene,this.camera),this.running==e&&((e,t,r)=>{!r&&n<this.framerate?setTimeout(()=>{requestAnimationFrame(()=>{e.call(this,t)})},1e3*(this.framerate-n)):requestAnimationFrame(()=>{e.call(this,t)})}).bind(this)(this.animateAfterThrow,e,this.adaptive_timestep)}startClickThrow(e){this.rolling&&(this.clearDice(),this.rolling=!1);let t={x:(2*Math.random()-.5)*this.display.currentWidth,y:-(2*Math.random()-.5)*this.display.currentHeight},n=Math.sqrt(t.x*t.x+t.y*t.y)+100,r=(Math.random()+3)*n*this.strength;return this.getNotationVectors(e,t,r,n)}clearDice(){let e;for(this.running=!1;e=this.diceList.pop();)this.scene.remove(e),e.body&&this.world.removeBody(e.body);this.renderer.render(this.scene,this.camera),setTimeout(()=>{this.renderer.render(this.scene,this.camera)},100)}async roll(e){const t=this.startClickThrow(e);if(t)return this.diceList,new Promise(e=>{this.rollDice(t,t=>{this.onRollComplete(t);const n=new CustomEvent("rollComplete",{detail:t});document.dispatchEvent(n),e(t)})})}rollDice(e,t){if(e.error)t.call(this);else{this.camera.position.z=this.cameraHeight.far,this.clearDice();for(let t=0,n=e.vectors.length;t<n;++t)this.spawnDice(e.vectors[t]);this.simulateThrow(e),this.steps=0,this.iteration=0;for(let t=0,n=this.diceList.length;t<n;++t)!this.diceList[t]||this.resetDice(this.diceList[t],e.vectors[t]);if(e.result&&e.result.length>0)for(let t=0;t<e.result.length;t++){let n=this.diceList[t];!n||n.getLastValue().value!=e.result[t]&&this.swapDiceFace(n,e.result[t])}for(let e=0,t=this.diceList.length;e<t;++e)!this.diceList[e]||"forced"!=this.diceList[e].resultReason&&(this.diceList[e].result=[]);this.rolling=!0,this.running=(new Date).getTime(),this.last_time=0,this.animateThrow(this.running,t,e)}}}class RF extends HTMLElement{constructor(){super(),this.diceBox=null,this.currentConfig={},this.instanceCache=new Map}async initialize(e,t={}){this.currentConfig={color:e,...t},await this.initializeDiceBox()}buildConfig(){const{color:e,labelColor:t="#ffffff",outlineColor:n="#000000",texture:r="",material:i="plastic",soundsSurface:s="wood_tray",soundsVolume:o}=this.currentConfig;return{assetPath:"./",theme_customColorset:{background:e,foreground:t,outline:n,texture:r,material:i},light_intensity:1,gravity_multiplier:400,baseScale:100,theme_surface:"green-felt",strength:8,soundsSurface:s,soundsVolume:o,shadows:!1,sounds:!0,onRollComplete(){}}}getConfigKey(){const{color:e,labelColor:t,texture:n,material:r}=this.currentConfig;return`${e}-${t}-${n}-${r}`}async initializeDiceBox(){const e=this.getConfigKey();if(this.instanceCache.has(e))this.diceBox=this.instanceCache.get(e);else if(this.querySelectorAll("canvas").forEach(e=>e.remove()),this.diceBox=new PF("#dice-box-container",this.buildConfig()),await this.diceBox.initialize().catch(e=>{console.error("DiceBox initialization failed:",e)}),this.instanceCache.set(e,this.diceBox),this.instanceCache.size>3){const e=this.instanceCache.keys().next().value;this.instanceCache.delete(e)}}async updateConfig(e,t){this.currentConfig={...this.currentConfig,...e,color:t};!this.instanceCache.has(this.getConfigKey())&&await this.initializeDiceBox()}async roll(e,t,n={}){if(!this.diceBox)return;const r={texture:n.texture||this.currentConfig.texture,material:n.material||this.currentConfig.material,labelColor:n.labelColor||this.currentConfig.labelColor};(this.currentConfig.color!==t||this.currentConfig.texture!==r.texture||this.currentConfig.material!==r.material||this.currentConfig.labelColor!==r.labelColor)&&(this.currentConfig={...this.currentConfig,...r,color:t},await this.initializeDiceBox());const i=e.results.map(e=>"1d"+e.sides).join("+"),s=e.results.map(e=>e.value).join(","),o=`${i}@${s}`;try{await this.diceBox.roll(o)}catch(t){console.error("3D dice roll error:",t,e)}}}customElements.define("dice-box",RF);const DF=window.location.hash.slice(1)||"main";let kF=localStorage.getItem("playerName");if(!kF){const e=prompt("Enter your name:");kF=e?.trim()?e.trim():zS.slice(0,8),localStorage.setItem("playerName",kF)}const NF=document.querySelector("dice-settings"),FF=document.querySelector("dice-box"),OF=NF.getSettings();_M[zS]=kF,EM[zS]=OF.color,SM[zS]={texture:OF.texture,material:OF.material,labelColor:OF.labelColor},await FF.initialize(OF.color,{labelColor:OF.labelColor,material:OF.material,texture:OF.texture});try{!function(e,t){let n,r,i,s,o,a;AM=bM(DM,e),[CM,n]=AM.makeAction("diceRoll"),[TM,r]=AM.makeAction("playerName"),[IM,i]=AM.makeAction("mouseMove"),[LM,s]=AM.makeAction("playerColor"),[PM,o]=AM.makeAction("emoji"),[RM,a]=AM.makeAction("diceSettings"),document.querySelector("#room-num").innerText="Room: "+e,AM.onPeerJoin(e=>{TM(_M[zS],e),LM(EM[zS],e),SM[zS]&&RM(SM[zS],e),OM(e),IM&&IM([.93*Math.random(),.93*Math.random()],e),zM()}),AM.onPeerLeave(e=>{var t;delete _M[e],delete EM[e],delete SM[e],MM[t=e]&&(vM.removeChild(MM[t]),delete MM[t]),zM()}),n(t),r((e,t)=>{if(_M[t]=e,MM[t]){const n=MM[t].querySelector("p");n&&(n.textContent=e)}}),s((e,t)=>{if(EM[t]=e,MM[t]){const n=MM[t].querySelector("p");n&&(n.style.borderLeft="3px solid "+e)}}),a((e,t)=>{SM[t]=e}),i(BM),o(e=>{const t=document.querySelector("emoji-buttons");t?.triggerEmojiConfetti?t.triggerEmojiConfetti(e):kM(e)})}(DF,async function(e,t){const n=EM[t]||"#ffffff",r=e.strength||11,i=SM[t]||{};await FF.roll(e,n,r,i),UM(e,t)}),document.documentElement.className="ready",OM(zS,!0)}catch(e){console.error("Failed to initialize room:",e),document.documentElement.className="ready"}document.querySelector("#create-room-btn").addEventListener("click",function(){const e=prompt("Enter a name for your new room:");if(!e)return;const t=e.trim().toLowerCase().replace(/[^a-z0-9-]/g,"-");if(!t)return void alert("Please enter a valid room name (letters, numbers, and hyphens only)");const n=Date.now(),r=function(e){let t=0;for(let n=0;n<e.length;n++){t=(t<<5)-t+e.charCodeAt(n),t&=t}return Math.abs(t).toString(16).substring(0,8)}(t+n),i=`${t}-${r}`;window.location.hash=i,window.location.reload()}),document.querySelector("#name-btn").addEventListener("click",()=>{const e=prompt("Enter your name:",kF);if(e?.trim()){kF=e.trim(),_M[zS]=kF,localStorage.setItem("playerName",kF);const t=document.querySelector("#cursor-"+zS);if(t){const e=t.querySelector("p");e&&(e.textContent=kF)}!function(e){TM&&TM(e)}(kF)}}),NF.addEventListener("color-change",async e=>{const{color:t}=e.detail;EM[zS]=t,await FF.reinitialize(t),function(e){LM&&LM(e)}(t)}),addEventListener("mousemove",({clientX:e,clientY:t})=>{const n=e/innerWidth,r=t/innerHeight;BM([n,r],zS),NM([n,r])}),addEventListener("touchmove",e=>{const t=e.touches[0].clientX/innerWidth,n=e.touches[0].clientY/innerHeight;BM([t,n],zS),NM([t,n])}),NF.addEventListener("label-color-change",async e=>{const{labelColor:t}=e.detail;SM[zS].labelColor=t;const n=NF.getSettings();await FF.updateConfig({labelColor:t},n.color),FM(SM[zS])}),NF.addEventListener("material-change",async e=>{const{material:t}=e.detail;SM[zS].material=t;const n=NF.getSettings();await FF.updateConfig({material:t},n.color),FM(SM[zS])}),NF.addEventListener("texture-change",async e=>{const{texture:t}=e.detail;SM[zS].texture=t;const n=NF.getSettings();await FF.updateConfig({texture:t},n.color),FM(SM[zS])}),addEventListener("hashchange",()=>{window.location.reload()}),document.querySelector("#faq-btn").addEventListener("click",()=>{document.querySelector("#faq-dialog").showModal()}),document.querySelector("#close-faq-btn").addEventListener("click",()=>{document.querySelector("#faq-dialog").close()});